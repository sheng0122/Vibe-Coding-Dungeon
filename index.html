<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Vibe Coding Dungeon</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='50' font-size='50'>âš”ï¸</text></svg>">
    
    <!-- è¼‰å…¥åƒç´ å­—é«” -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- Three.js CDN for 3D transformation effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            overflow: hidden;
            position: relative;
        }
        
        /* æ‰‹æ©Ÿæ©«å‘æç¤º */
        #rotatePrompt {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
        }
        
        #rotatePrompt.show {
            display: flex;
        }
        
        .rotate-icon {
            font-size: 60px;
            animation: rotate 2s ease-in-out infinite;
            margin-bottom: 30px;
        }
        
        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        .rotate-text {
            color: #ffcc66;
            font-size: 14px;
            text-align: center;
            line-height: 1.5;
        }
        
        /* é–‹å§‹ç•«é¢ */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('Assets/Backgrounds/dungeon-start-bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        #startScreen.fadeOut {
            opacity: 0;
            pointer-events: none;
        }
        
        /* æš—è‰²è¦†è“‹å±¤ */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1;
        }
        
        /* ç«å…‰å‹•ç•«æ•ˆæœ */
        @keyframes fireGlow {
            0% { filter: brightness(1) drop-shadow(0 0 10px #ff6600); }
            25% { filter: brightness(1.1) drop-shadow(0 0 15px #ff8833); }
            50% { filter: brightness(0.95) drop-shadow(0 0 12px #ff6600); }
            75% { filter: brightness(1.05) drop-shadow(0 0 18px #ff9944); }
            100% { filter: brightness(1) drop-shadow(0 0 10px #ff6600); }
        }
        
        /* æ¨™é¡Œå®¹å™¨ */
        .title-container {
            position: relative;
            z-index: 2;
            text-align: center;
            animation: fireGlow 3s infinite;
            margin-bottom: 50px;
        }
        
        /* ä¸»æ¨™é¡Œ */
        .game-title {
            font-size: clamp(24px, 6vw, 48px);
            color: #ff9944;
            text-shadow: 
                3px 3px 0px #8b4513,
                6px 6px 0px #5d2f0d,
                9px 9px 20px rgba(255, 102, 0, 0.8),
                0 0 40px rgba(255, 102, 0, 0.5);
            letter-spacing: 2px;
            margin-bottom: 20px;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
        
        /* æŒ‰éˆ•å®¹å™¨ */
        .button-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        /* åœ°ä¸‹åŸé¢¨æ ¼æŒ‰éˆ• */
        .dungeon-btn {
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 3px solid #8b6914;
            padding: 15px 40px;
            font-size: clamp(14px, 2.5vw, 18px);
            color: #ffcc66;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
            box-shadow: 
                inset 0 -4px 0 #1a1410,
                0 4px 8px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 1px;
        }
        
        .dungeon-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ff6600, #ff9944, #ff6600);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            filter: blur(4px);
        }
        
        .dungeon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                inset 0 -4px 0 #1a1410,
                0 6px 12px rgba(0, 0, 0, 0.9);
            color: #ffdd88;
        }
        
        .dungeon-btn:hover::before {
            opacity: 0.6;
        }
        
        .dungeon-btn:active {
            transform: translateY(2px);
            box-shadow: 
                inset 0 -2px 0 #1a1410,
                0 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        /* ç«ç„°ç²’å­æ•ˆæœ */
        .fire-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff6600;
            border-radius: 50%;
            pointer-events: none;
            animation: floatUp 3s linear infinite;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(100vh) scale(1);
                opacity: 1;
            }
            25% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) scale(0);
                opacity: 0;
            }
        }
        
        /* éŠæˆ²å®¹å™¨ */
        #gameContainer {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #1a1a2e;
        }
        
        #gameContainer.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* éŠæˆ²ç•«å¸ƒ */
        #gameCanvas {
            border: 3px solid #8b6914;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
        }
        
        /* å¼•å°è¦–çª— */
        #guideWindow {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #2e2416 0%, #1a1410 100%);
            border: 3px solid #8b6914;
            padding: 30px;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
            max-width: 500px;
            font-family: 'Press Start 2P', cursive;
        }
        
        #guideWindow.show {
            display: block;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        
        .guide-title {
            color: #ff9944;
            font-size: 20px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }
        
        .guide-content {
            color: #cccccc;
            font-size: 14px;
            line-height: 1.8;
            margin-bottom: 20px;
        }
        
        .guide-controls {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .control-key {
            color: #ffcc66;
            background: #1a1410;
            padding: 5px 10px;
            border: 1px solid #8b6914;
        }
        
        .control-desc {
            color: #999;
            padding: 5px;
        }
        
        .guide-close {
            width: 100%;
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 2px solid #8b6914;
            padding: 10px;
            color: #ffcc66;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .guide-close:hover {
            background: linear-gradient(180deg, #5a4c38 0%, #3e3426 100%);
            transform: scale(1.05);
        }
        
        /* éŠæˆ²çµæŸç•«é¢ */
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameOverScreen.show {
            display: flex;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulseGlow {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes scaleFlash {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            20% {
                transform: scale(1.4);
                opacity: 1;
                filter: brightness(2.5);
            }
            30% {
                transform: scale(1.2);
                filter: brightness(1.2);
            }
            40% {
                transform: scale(1.3);
                filter: brightness(2.2);
            }
            50% {
                transform: scale(1.15);
                filter: brightness(1.3);
            }
            60% {
                transform: scale(1.25);
                filter: brightness(2);
            }
            70% {
                transform: scale(1.1);
                filter: brightness(1.4);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                filter: brightness(1);
            }
        }
        
        @keyframes floatImage {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        @keyframes glowPulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }
        
        @keyframes particleFloat0 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(100px) translateY(-100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat1 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(100px) translateY(100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat2 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-100px) translateY(100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat3 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-100px) translateY(-100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat4 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(0) translateY(-120px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat5 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(120px) translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat6 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(0) translateY(120px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat7 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-120px) translateY(0);
                opacity: 1;
            }
        }
        
        .game-over-title {
            font-size: clamp(30px, 8vw, 60px);
            margin-bottom: 30px;
            text-shadow: 
                3px 3px 0px #8b4513,
                6px 6px 0px #5d2f0d,
                0 0 30px rgba(255, 102, 0, 0.8);
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        .victory { color: #ffcc00; }
        .defeat { color: #ff3333; }
        
        .game-over-score {
            font-size: clamp(16px, 3vw, 24px);
            color: #cccccc;
            margin-bottom: 40px;
        }
        
        .discount-code {
            margin: 60px 0 20px 0;
            padding: 12px 30px;
            background: linear-gradient(135deg, #2a1a4e 0%, #1a0e2e 100%);
            border: 3px solid #9d4edd;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(157, 78, 221, 0.4);
            display: inline-block;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        /* å‹åˆ©æ™‚çš„æŠ˜æ‰£ç¢¼æ¨£å¼ - é‡‘è‰² */
        .discount-code.winner {
            background: linear-gradient(135deg, #4a3f1a 0%, #2e2410 100%);
            border: 3px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        /* å¤±æ•—æ™‚çš„æŠ˜æ‰£ç¢¼æ¨£å¼ - ç´…è‰² */
        .discount-code.fighter {
            background: linear-gradient(135deg, #4a1a1a 0%, #2e1010 100%);
            border: 3px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }
        
        .discount-code:hover {
            transform: scale(1.1);
        }
        
        .code-label {
            font-size: clamp(10px, 1.5vw, 12px);
            color: #c77dff;
            margin-bottom: 4px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .discount-code.winner .code-label {
            color: #ffeb3b;
        }
        
        .discount-code.fighter .code-label {
            color: #ff6b6b;
        }
        
        .code-value {
            font-size: clamp(12px, 2vw, 16px);
            color: #e0aaff;
            text-shadow: 2px 2px 0px #000;
            letter-spacing: 2px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .discount-code.winner .code-value {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        
        .discount-code.fighter .code-value {
            color: #ff6666;
            text-shadow: 0 0 10px rgba(255, 102, 102, 0.7);
        }
        
        .button-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        
        .restart-btn {
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 3px solid #8b6914;
            padding: 20px 50px;
            font-size: clamp(16px, 3vw, 22px);
            color: #ffcc66;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .template-btn {
            background: linear-gradient(180deg, #2e4a3c 0%, #1a2e24 100%);
            border: 3px solid #14898b;
            padding: 12px 30px;
            font-size: clamp(12px, 2vw, 16px);
            color: #66ffcc;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .restart-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.9);
        }
        
        .template-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(102, 255, 204, 0.8);
        }
        
        /* UIé¢æ¿ */
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            z-index: 100;
        }
        
        .ui-panel {
            background: rgba(42, 36, 22, 0.9);
            border: 2px solid #8b6914;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: #1a1410;
            border: 2px solid #8b6914;
            margin: 5px 0;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3333, #ff6666);
            transition: width 0.3s;
        }
        
        .boss-health-fill {
            background: linear-gradient(90deg, #9933ff, #cc66ff);
        }
        
        /* æ‰‹æ©Ÿæ§åˆ¶ */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 5px;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 0 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 100%);
            padding-bottom: 5px;
            padding-top: 10px;
        }
        
        .mobile-controls-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 500px;
            margin: 0 auto;
        }
        
        /* å·¦æ‰‹æ–¹å‘æ§åˆ¶å€ */
        .left-controls {
            position: relative;
            width: 150px;
            height: 150px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(139, 105, 20, 0.7);
            border: 3px solid #ffcc66;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        /* æ–¹å‘æŒ‰éˆ•ä½ç½® */
        .control-btn.btn-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .control-btn.btn-left {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        .control-btn.btn-right {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }
        
        /* å³æ‰‹æ”»æ“ŠæŒ‰éˆ• */
        .control-btn.btn-attack {
            width: 80px;
            height: 80px;
            font-size: 36px;
            position: relative;
        }
        
        .control-btn:active {
            background: rgba(255, 204, 102, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .control-btn.btn-up:active {
            transform: translateX(-50%) scale(0.95);
        }
        
        .control-btn.btn-left:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .control-btn.btn-right:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #mobileControls {
                display: block !important;
            }
            
            #gameContainer {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #000;
                width: 100vw;
                height: 100vh;
                padding: 0;
                margin: 0;
            }
            
            /* æ©«å‘æ¨¡å¼çš„éŠæˆ²çµæŸç•«é¢ */
            .extra-content {
                margin-top: 60px !important;
                gap: 20px !important;
            }
            
            #gameOverScreen {
                padding: 10px;
            }
            
            .game-over-title {
                margin-bottom: 15px;
            }
            
            .game-over-score {
                margin-bottom: 20px;
            }
            
            #gameCanvas {
                border: none;
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }
            
            #gameUI {
                font-size: 10px;
                display: none; /* éš±è—UIé¿å…å¹²æ“¾ */
            }
            
            .ui-panel {
                padding: 3px 5px;
                background: rgba(0, 0, 0, 0.7);
            }
            
            .health-bar {
                width: 80px;
                height: 12px;
            }
            
            .control-btn {
                opacity: 0.8;
                width: 45px;
                height: 45px;
                font-size: 18px;
                background: rgba(139, 105, 20, 0.6);
            }
            
            .control-btn.btn-attack {
                width: 55px;
                height: 55px;
                font-size: 24px;
            }
            
            .control-btn:active {
                opacity: 0.9;
            }
        }
        
        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer {
                display: none !important;
            }
        }
        
        /* æ‰‹æ©Ÿç‰ˆéŠæˆ²çµæŸç•«é¢ */
        @media (max-width: 768px) {
            #gameOverScreen {
                padding: 20px;
            }
            
            .game-over-title {
                font-size: clamp(24px, 6vw, 36px);
                margin-bottom: 20px;
            }
            
            .game-over-score {
                font-size: clamp(14px, 3vw, 18px);
                margin-bottom: 30px;
            }
            
            .restart-btn {
                width: 100%;
                max-width: 280px;
                padding: 15px 30px;
                font-size: clamp(14px, 3vw, 18px);
                margin: 0 auto;
                display: block;
            }
            
            /* æ‰‹æ©Ÿç‰ˆæ”¹ç‚ºå‚ç›´æ’åˆ— */
            .extra-content {
                flex-direction: column !important;
                gap: 20px !important;
                margin-top: 60px !important;
            }
            
            .template-btn {
                width: 100%;
                max-width: 200px;
                padding: 12px 25px;
                font-size: clamp(12px, 3vw, 16px);
                margin: 0 auto;
            }
            
            .discount-code {
                width: 100%;
                max-width: 200px;
                padding: 12px 25px;
                margin: 0 auto;
            }
            
            .code-label {
                font-size: clamp(10px, 2.5vw, 12px);
                margin-bottom: 8px;
            }
            
            .code-value {
                font-size: clamp(12px, 3vw, 16px);
            }
        }
    </style>
    
    <!-- Microsoft Clarity æ•¸æ“šåˆ†æè¿½è¹¤ç¢¼ -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "t38s0rk3ln");
    </script>
</head>
<body>
    <!-- éŸ³æ•ˆèˆ‡éŸ³æ¨‚ -->
    <audio id="menuBGM" loop preload="auto">
        <source src="audio/menu-bgm.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameBGM" loop preload="auto">
        <source src="audio/level1-bgm.mp3" type="audio/mpeg">
    </audio>
    
    <!-- æ‰‹æ©Ÿæ©«å‘æç¤º -->
    <div id="rotatePrompt">
        <div class="rotate-icon">ğŸ“±</div>
        <div class="rotate-text">
            è«‹æ—‹è½‰è£ç½®<br>
            ä½¿ç”¨æ©«å‘æ¨¡å¼éŠç©
        </div>
    </div>
    
    <!-- é–‹å§‹ç•«é¢ -->
    <div id="startScreen">
        <div class="title-container">
            <h1 class="game-title">VIBE CODING</h1>
            <h1 class="game-title" style="font-size: clamp(20px, 5vw, 40px); margin-top: -10px;">DUNGEON</h1>
        </div>
        <div class="button-container">
            <button class="dungeon-btn" onclick="startGame()">é–‹å§‹å†’éšª</button>
            <button class="dungeon-btn music-btn" onclick="playMenuMusic()" style="margin-top: 10px; font-size: 12px;">ğŸµ æ’­æ”¾éŸ³æ¨‚</button>
        </div>
        <div class="music-hint" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center;">
            <p style="color: #ffcc66; font-size: 10px; opacity: 0.8; animation: pulse 2s infinite;">
                é»æ“Šä»»æ„è™•é–‹å•ŸéŸ³æ¨‚
            </p>
        </div>
    </div>
    
    <!-- éŠæˆ²å®¹å™¨ -->
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <!-- UIä»‹é¢ -->
        <div id="gameUI">
            <div class="ui-panel">
                <div>HP: <span id="playerHP">100/100</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="playerHealthBar" style="width: 100%"></div>
                </div>
                <div>é€£æ“Š: <span id="combo">0</span></div>
            </div>
            
            <div class="ui-panel">
                <div>æ™‚é–“: <span id="gameTime">00:00</span></div>
                <div>åˆ†æ•¸: <span id="score">0</span></div>
            </div>
            
            <div class="ui-panel">
                <div>BOSS HP: <span id="bossHP">500/500</span></div>
                <div class="health-bar">
                    <div class="health-fill boss-health-fill" id="bossHealthBar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <!-- æ‰‹æ©Ÿæ§åˆ¶ -->
        <div id="mobileControls">
            <div class="mobile-controls-container">
                <div style="display: flex; gap: 10px;">
                    <button class="control-btn" data-key="ArrowLeft">â†</button>
                    <button class="control-btn" data-key="ArrowUp">â†‘</button>
                    <button class="control-btn" data-key="ArrowRight">â†’</button>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="control-btn btn-attack" data-key=" ">âš”</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- å¼•å°è¦–çª— -->
    <div id="guideWindow">
        <h2 class="guide-title">éŠæˆ²æŒ‡å—</h2>
        <div class="guide-content">
            å‹‡æ•¢çš„å†’éšªè€…ï¼Œæ­¡è¿ä¾†åˆ° Vibe Coding åœ°ä¸‹åŸï¼
            æ“Šæ•—å¯¶ç®±æ€ªç‰©ï¼Œè­‰æ˜ä½ çš„å¯¦åŠ›ï¼
        </div>
        <div class="guide-controls">
            <div class="control-key">â†â†’</div>
            <div class="control-desc">ç§»å‹•</div>
            <div class="control-key">â†‘</div>
            <div class="control-desc">è·³èº</div>
            <div class="control-key">ç©ºç™½éµ</div>
            <div class="control-desc">æ”»æ“Š</div>
            <div class="control-key">F</div>
            <div class="control-desc">åˆ‡æ›å…¨è¢å¹•</div>
            <div class="control-key">ESC</div>
            <div class="control-desc">é€€å‡ºå…¨è¢å¹•</div>
        </div>
        <button class="guide-close" onclick="closeGuide()">é–‹å§‹æˆ°é¬¥</button>
    </div>
    
    <!-- éŠæˆ²çµæŸç•«é¢ -->
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">VICTORY!</h1>
        <div class="game-over-score">æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></div>
        
        <!-- å†æ¬¡æŒ‘æˆ°æŒ‰éˆ• -->
        <div style="margin-top: 40px;">
            <button class="restart-btn" onclick="restartGame()">å†æ¬¡æŒ‘æˆ°</button>
        </div>
        
        <!-- æŠ˜æ‰£ç¢¼å’Œç°¡å ±æ¨¡æ¿å€å¡Š -->
        <div class="extra-content" style="margin-top: 100px; display: flex; align-items: center; justify-content: center; gap: 40px; flex-wrap: wrap;">
            <div class="discount-code" id="discountCode" style="margin: 0;">
                <div class="code-label">æŠ˜æ‰£ç¢¼:</div>
                <div class="code-value" id="codeValue">WINNER</div>
            </div>
            <button class="template-btn" onclick="openTemplate()">ç°¡å ±æ¨¡æ¿</button>
        </div>
    </div>
    
    <script>
// å‰µå»ºç«ç„°ç²’å­æ•ˆæœ
function createFireParticles() {
    const startScreen = document.getElementById('startScreen');
    
    setInterval(() => {
        const particle = document.createElement('div');
        particle.className = 'fire-particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 3 + 's';
        particle.style.width = Math.random() * 4 + 2 + 'px';
        particle.style.height = particle.style.width;
        startScreen.appendChild(particle);
        
        setTimeout(() => particle.remove(), 3000);
    }, 200);
}

// é é¢è¼‰å…¥æ™‚å‰µå»ºç«ç„°æ•ˆæœ
window.addEventListener('load', () => {
    createFireParticles();
    checkOrientation();
    
    // è¨­ç½®ä¸€æ¬¡æ€§é»æ“Šç›£è½å™¨ä¾†æ’­æ”¾éŸ³æ¨‚
    let musicStarted = false;
    const startMusic = () => {
        if (!musicStarted) {
            const menuBGM = document.getElementById('menuBGM');
            menuBGM.volume = 0.5;  // æé«˜åˆ°50%éŸ³é‡
            menuBGM.play().then(() => {
                console.log('èƒŒæ™¯éŸ³æ¨‚é–‹å§‹æ’­æ”¾');
                // æ›´æ–°éŸ³æ¨‚æŒ‰éˆ•ç‹€æ…‹
                const musicBtn = document.querySelector('.music-btn');
                if (musicBtn) {
                    musicBtn.textContent = 'ğŸ”‡ éœéŸ³';
                }
                // éš±è—æç¤ºæ–‡å­—
                const hint = document.querySelector('.music-hint');
                if (hint) {
                    hint.style.display = 'none';
                }
            }).catch(err => {
                console.log('éŸ³æ¨‚æ’­æ”¾å¤±æ•—:', err);
            });
            musicStarted = true;
            // ç§»é™¤ç›£è½å™¨
            document.removeEventListener('click', startMusic);
            document.removeEventListener('keydown', startMusic);
            document.removeEventListener('touchstart', startMusic);
        }
    };
    
    // ç›£è½ä»»ä½•ç”¨æˆ¶äº’å‹•ï¼ˆmousemove ä¸æœƒè§¸ç™¼éŸ³é »æ’­æ”¾ï¼‰
    document.addEventListener('click', startMusic);
    document.addEventListener('keydown', startMusic);
    document.addEventListener('touchstart', startMusic);
    
    // é¡å¤–å˜—è©¦ï¼šæ»‘é¼ ç§»å‹•æ™‚é¡¯ç¤ºæ›´æ˜é¡¯çš„æç¤º
    document.addEventListener('mousemove', () => {
        if (!musicStarted) {
            const hint = document.querySelector('.music-hint p');
            if (hint) {
                hint.style.fontSize = '12px';
                hint.style.opacity = '1';
                setTimeout(() => {
                    hint.style.fontSize = '10px';
                    hint.style.opacity = '0.8';
                }, 200);
            }
        }
    }, { once: true });
});

// æ’­æ”¾ä¸»é¸å–®éŸ³æ¨‚
function playMenuMusic() {
    const menuBGM = document.getElementById('menuBGM');
    const musicBtn = event.target;
    
    if (menuBGM.paused) {
        menuBGM.volume = 0.5;  // æé«˜åˆ°50%éŸ³é‡
        menuBGM.play().then(() => {
            musicBtn.textContent = 'ğŸ”‡ éœéŸ³';
        }).catch(err => {
            console.log('ç„¡æ³•æ’­æ”¾éŸ³æ¨‚:', err);
        });
    } else {
        menuBGM.pause();
        musicBtn.textContent = 'ğŸµ æ’­æ”¾éŸ³æ¨‚';
    }
}

// æª¢æ¸¬è¢å¹•æ–¹å‘
function checkOrientation() {
    const rotatePrompt = document.getElementById('rotatePrompt');
    
    if (isMobile()) {
        // æª¢æŸ¥æ˜¯å¦ç‚ºç›´å‘
        if (window.innerHeight > window.innerWidth) {
            rotatePrompt.classList.add('show');
        } else {
            rotatePrompt.classList.remove('show');
        }
    } else {
        rotatePrompt.classList.remove('show');
    }
}

// ç›£è½æ–¹å‘æ”¹è®Š
window.addEventListener('orientationchange', checkOrientation);
window.addEventListener('resize', checkOrientation);

// é–‹å§‹éŠæˆ²
function startGame() {
    const startScreen = document.getElementById('startScreen');
    const gameContainer = document.getElementById('gameContainer');
    const guideWindow = document.getElementById('guideWindow');
    
    // é¦–æ¬¡é»æ“Šæ™‚æ’­æ”¾ä¸»é¸å–®éŸ³æ¨‚ï¼ˆå¦‚æœé‚„æ²’æ’­æ”¾ï¼‰
    const menuBGM = document.getElementById('menuBGM');
    const gameBGM = document.getElementById('gameBGM');
    
    if (menuBGM.paused) {
        menuBGM.volume = 0.5;  // æé«˜åˆ°50%éŸ³é‡
        menuBGM.play().catch(err => {
            console.log('ç„¡æ³•æ’­æ”¾ä¸»é¸å–®éŸ³æ¨‚:', err);
        });
    }
    
    // çŸ­æš«å»¶é²å¾Œæ·¡å‡ºä¸»é¸å–®éŸ³æ¨‚
    setTimeout(() => {
        let fadeOutInterval = setInterval(() => {
            if (menuBGM.volume > 0.02) {
                menuBGM.volume -= 0.02;
            } else {
                menuBGM.pause();
                menuBGM.currentTime = 0;
                clearInterval(fadeOutInterval);
            }
        }, 20);
    }, 500);
    
    // æ·¡å‡ºé–‹å§‹ç•«é¢
    startScreen.classList.add('fadeOut');
    
    setTimeout(() => {
        startScreen.style.display = 'none';
        gameContainer.classList.add('active');
        
        // åˆå§‹åŒ–éŠæˆ²
        initializeGame();
        
        // è‡ªå‹•é€²å…¥å…¨è¢å¹•
        if (!isMobile()) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('ç„¡æ³•è‡ªå‹•é€²å…¥å…¨è¢å¹•:', err);
                });
            }
        }
        
        // é¡¯ç¤ºå¼•å°è¦–çª—
        setTimeout(() => {
            // ä¸éœ€è¦è¨­ç½®è§’è‰²ä½ç½®ï¼Œç›´æ¥ä½¿ç”¨åˆå§‹ä½ç½®
            
            guideWindow.classList.add('show');
            // æš«åœéŠæˆ²ç›´åˆ°å¼•å°é—œé–‰ï¼ˆé¦–æ¬¡éŠæˆ²ï¼‰
            if (game) {
                game.paused = true;
                console.log('éŠæˆ²æš«åœï¼Œç­‰å¾…å¼•å°é—œé–‰');
            }
        }, 500);
    }, 1000);
}

// é¡¯ç¤ºå¼•å°
function showGuide() {
    document.getElementById('guideWindow').classList.add('show');
    if (game) game.paused = true;
}

// é—œé–‰å¼•å°
function closeGuide() {
    document.getElementById('guideWindow').classList.remove('show');
    if (game && player && boss) {
        // ä¸éœ€è¦å…¥å ´å‹•ç•«ï¼Œä¿æŒåŸä½
        
        // é–‹å§‹æ’­æ”¾éŠæˆ²éŸ³æ¨‚
        const gameBGM = document.getElementById('gameBGM');
        gameBGM.volume = 0;
        gameBGM.play().then(() => {
            // æ·¡å…¥éŠæˆ²éŸ³æ¨‚
            let fadeInInterval = setInterval(() => {
                if (gameBGM.volume < 0.5) {
                    gameBGM.volume += 0.02;
                } else {
                    gameBGM.volume = 0.5;  // æé«˜åˆ°50%éŸ³é‡
                    clearInterval(fadeInInterval);
                }
            }, 20);
        }).catch(err => {
            console.log('ç„¡æ³•æ’­æ”¾éŠæˆ²éŸ³æ¨‚:', err);
        });
        
        // ç«‹å³è§£é™¤æš«åœï¼Œè®“å…¥å ´å‹•ç•«é–‹å§‹
        game.paused = false;
        console.log('éŠæˆ²é–‹å§‹ï¼è§’è‰²å…¥å ´ä¸­...');
        
        // å»¶é²é¡¯ç¤ºé–‹å§‹æç¤º
        setTimeout(() => {
            showGameMessage('FIGHT!', 1000);
        }, 500);
    }
}

// å…¨è¢å¹•åˆ‡æ›
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
}

// é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
function showGameOverScreen(victory) {
    const screen = document.getElementById('gameOverScreen');
    const title = document.getElementById('gameOverTitle');
    const finalScore = document.getElementById('finalScore');
    const codeValue = document.getElementById('codeValue');
    const discountCode = document.getElementById('discountCode');
    
    // åœæ­¢éŠæˆ²éŸ³æ¨‚
    const gameBGM = document.getElementById('gameBGM');
    let fadeOutInterval = setInterval(() => {
        if (gameBGM.volume > 0.02) {
            gameBGM.volume -= 0.02;
        } else {
            gameBGM.pause();
            gameBGM.currentTime = 0;
            clearInterval(fadeOutInterval);
        }
    }, 20);
    
    if (victory) {
        title.textContent = 'VICTORY!';
        title.className = 'game-over-title victory';
        codeValue.textContent = 'WINNER';
        discountCode.className = 'discount-code winner';
    } else {
        title.textContent = 'DEFEAT';
        title.className = 'game-over-title defeat';
        codeValue.textContent = 'FIGHTER';
        discountCode.className = 'discount-code fighter';
    }
    
    finalScore.textContent = game ? game.score : 0;
    screen.classList.add('show');
    
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
}

// é–‹å•Ÿç°¡å ±æ¨¡æ¿
function openTemplate() {
    // æ ¹æ“šæŠ˜æ‰£ç¢¼æ±ºå®šé–‹å•Ÿå“ªå€‹é€£çµ
    const codeValue = document.getElementById('codeValue').textContent;
    
    if (codeValue === 'WINNER') {
        // å‹åˆ©æ™‚é–‹å•Ÿ winner é€£çµ
        window.open('https://lihi.cc/op2ya', '_blank');
    } else if (codeValue === 'FIGHTER') {
        // å¤±æ•—æ™‚é–‹å•Ÿ fighter é€£çµ
        window.open('https://lihi.cc/YCw6a', '_blank');
    } else {
        // é è¨­é€£çµï¼ˆä»¥é˜²è¬ä¸€ï¼‰
        window.open('https://lihi.cc/QRztO', '_blank');
    }
}

// é è¼‰å…¥ç¦®ç›’éŸ³æ•ˆ
const giftSounds = {};
function preloadGiftSounds() {
    const soundFiles = {
        'invincible': 'Assets/Audio/GiftBox/gift_invincible.mp3',
        'speed': 'Assets/Audio/GiftBox/gift_speed.mp3',
        'vampire': 'Assets/Audio/GiftBox/gift_vampire.mp3',
        'cursed': 'Assets/Audio/GiftBox/gift_cursed.mp3'
    };
    
    for (const [key, path] of Object.entries(soundFiles)) {
        giftSounds[key] = new Audio(path);
        giftSounds[key].volume = 1.0;  // èª¿æ•´ç‚ºæœ€å¤§éŸ³é‡
        giftSounds[key].load();
        console.log('Preloading gift sound:', key, path);
    }
}

// é‡æ–°é–‹å§‹éŠæˆ²
function restartGame() {
    // åœæ­¢ç•¶å‰éŠæˆ²å¾ªç’°
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
    
    // éš±è—éŠæˆ²çµæŸç•«é¢
    document.getElementById('gameOverScreen').classList.remove('show');
    
    // é‡ç½®æ™‚é–“
    lastTime = 0;
    
    // é‡ç½®é£›æ©Ÿç³»çµ±
    airplane = null;
    airplaneSpawned = false;
    
    // é‡ç½®ç¦®ç›’ç³»çµ±
    giftBoxSystem.triggered = false;
    giftBoxSystem.dropTimer = 0;
    
    // æ¸…ç†èˆŠçš„ Three.js buff ç‰¹æ•ˆå®¹å™¨
    if (game && game.buffEffectContainer) {
        game.buffEffectContainer.remove();
    }
    
    // é‡æ–°åˆå§‹åŒ–éŠæˆ²
    initializeGame();
    
    // â­ é—œéµä¿®å¾©ï¼šç›´æ¥é–‹å§‹éŠæˆ²ï¼Œè·³éå¼•å°
    setTimeout(() => {
        if (game && player && boss) {
            // ç¢ºä¿Bossç‹€æ…‹å®Œå…¨é‡ç½®
            boss.health = boss.maxHealth;
            boss.phase = 1;
            boss.state = 'chest';
            boss.aiState = 'approach';
            boss.updateHealth();
            
            // ç¢ºä¿ç©å®¶è¡€é‡é‡ç½®
            player.health = player.maxHealth;
            player.combo = 0;
            player.updateHealth();
            
            // è¨­ç½®è§’è‰²å…¥å ´å‹•ç•«
            player.x = -50;
            player.targetX = 100;
            boss.x = 850;  // ä¿®æ­£ï¼šç›´æ¥ä½¿ç”¨æ•¸å€¼
            boss.targetX = 400;
            
            // ç¢ºä¿éŠæˆ²é–‹å§‹
            game.paused = false;
            game.gameOver = false;
            game.victory = false;
            game.score = 0;
            game.updateUI();
            
            // é‡æ–°æ’­æ”¾éŠæˆ²éŸ³æ¨‚
            const gameBGM = document.getElementById('gameBGM');
            gameBGM.volume = 0;
            gameBGM.play().then(() => {
                // æ·¡å…¥éŠæˆ²éŸ³æ¨‚
                let fadeInInterval = setInterval(() => {
                    if (gameBGM.volume < 0.5) {
                        gameBGM.volume += 0.02;
                    } else {
                        gameBGM.volume = 0.5;  // æé«˜åˆ°50%éŸ³é‡
                        clearInterval(fadeInInterval);
                    }
                }, 20);
            }).catch(err => {
                console.log('ç„¡æ³•æ’­æ”¾éŠæˆ²éŸ³æ¨‚:', err);
            });
            
            // é¡¯ç¤ºé–‹å§‹è¨Šæ¯
            setTimeout(() => {
                showGameMessage('ROUND 2!', 1000);
            }, 500);
        }
    }, 200);
}

// é¡¯ç¤ºéŠæˆ²è¨Šæ¯
function showGameMessage(message, duration) {
    if (!game || !game.ctx) return;
    
    const startTime = Date.now();
    const originalRender = game.render.bind(game);
    
    game.render = function() {
        originalRender();
        
        const elapsed = Date.now() - startTime;
        if (elapsed < duration) {
            const alpha = 1 - (elapsed / duration);
            const scale = 1 + (elapsed / duration) * 0.5;
            
            this.ctx.save();
            this.ctx.fillStyle = `rgba(255, 204, 102, ${alpha})`;
            this.ctx.font = `${30 * scale}px "Press Start 2P"`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(message, this.width/2, this.height/2);
            this.ctx.restore();
        } else {
            game.render = originalRender;
        }
    };
}

// ========== éŠæˆ²å¼•æ“ ==========
let game = null;
let player = null;
let boss = null;
let animationId = null;
let gameStartTime = 0;

// é£›æ©Ÿç³»çµ±
let airplane = null;
let airplaneSpawned = false;

// ç¦®ç›’æ‰è½ç³»çµ±å…¨å±€è®Šæ•¸
let giftBoxSystem = {
    triggered: false,
    dropTimer: 0,
    dropInterval: 10  // 10ç§’é–“éš”
};

function initializeGame() {
    const canvas = document.getElementById('gameCanvas');
    
    // é‡ç½®é£›æ©Ÿç³»çµ±
    airplane = null;
    airplaneSpawned = false;
    
    // é è¼‰å…¥ç¦®ç›’éŸ³æ•ˆ
    preloadGiftSounds();
    
    // æ¸…ç†èˆŠçš„äº‹ä»¶ç›£è½å™¨
    if (window.resizeListener) {
        window.removeEventListener('resize', window.resizeListener);
    }
    if (document.fullscreenListener) {
        document.removeEventListener('fullscreenchange', document.fullscreenListener);
    }
    
    // è¨­å®šç•«å¸ƒå¯¦éš›ç¹ªåœ–å°ºå¯¸
    canvas.width = 800;
    canvas.height = 400;
    
    // èª¿æ•´ç•«å¸ƒå¤§å°
    function resizeCanvas() {
        if (isMobile()) {
            // æ‰‹æ©Ÿç‰ˆä½¿ç”¨è¦–å£å°ºå¯¸
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            if (window.innerHeight > window.innerWidth) {
                // ç›´å‘æ¨¡å¼ - éš±è—éŠæˆ²ç•«å¸ƒ
                canvas.style.display = 'none';
            } else {
                // æ©«å‘æ¨¡å¼ - å…¨è¢å¹•é¡¯ç¤º
                canvas.style.display = 'block';
                // ä½¿ç”¨æ›´å¤§çš„ç•«é¢æ¯”ä¾‹
                const controlHeight = 80; // æ§åˆ¶æŒ‰éˆ•é«˜åº¦
                const maxHeight = vh - controlHeight;
                const maxWidth = vw;
                const ratio = Math.min(maxWidth / 800, maxHeight / 400);
                
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
                canvas.style.position = 'absolute';
                canvas.style.left = '50%';
                canvas.style.top = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';
            }
        } else {
            // æ¡Œé¢ç‰ˆ
            if (document.fullscreenElement) {
                // å…¨è¢å¹•æ¨¡å¼
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const ratio = Math.min(vw / 800, vh / 400);
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
            } else {
                // è¦–çª—æ¨¡å¼
                const maxWidth = Math.min(1000, window.innerWidth - 40);
                const maxHeight = Math.min(500, window.innerHeight - 150);
                const ratio = Math.min(maxWidth / 800, maxHeight / 400);
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
            }
        }
        
        // æ›´æ–° Three.js buff ç‰¹æ•ˆå®¹å™¨å¤§å°
        if (game && game.buffEffectContainer && game.buffRenderer) {
            // åŒæ­¥å®¹å™¨å¤§å°èˆ‡ canvas
            game.buffEffectContainer.style.width = canvas.style.width;
            game.buffEffectContainer.style.height = canvas.style.height;
            
            // ç²å–å¯¦éš›é¡¯ç¤ºå°ºå¯¸
            const displayWidth = parseInt(canvas.style.width) || 800;
            const displayHeight = parseInt(canvas.style.height) || 400;
            
            // æ›´æ–° Three.js æ¸²æŸ“å™¨
            game.buffRenderer.setSize(displayWidth, displayHeight);
            
            // æ›´æ–°ç›¸æ©ŸæŠ•å½±çŸ©é™£
            if (game.buffCamera) {
                game.buffCamera.left = 0;
                game.buffCamera.right = game.width;
                game.buffCamera.top = 0;
                game.buffCamera.bottom = game.height;
                game.buffCamera.updateProjectionMatrix();
            }
        }
    }
    
    resizeCanvas();
    
    // ä¿å­˜äº‹ä»¶ç›£è½å™¨å¼•ç”¨ä»¥ä¾¿æ¸…ç†
    window.resizeListener = resizeCanvas;
    document.fullscreenListener = resizeCanvas;
    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('fullscreenchange', resizeCanvas);
    
    // é‡ç½®éŠæˆ²æ™‚é–“
    gameStartTime = Date.now();
    
    // å‰µå»ºæ–°çš„éŠæˆ²å¼•æ“
    game = new GameEngine(canvas);
    
    // é‡ç½®éŠæˆ²ç‹€æ…‹ - é¦–æ¬¡éŠæˆ²æœƒæš«åœç­‰å¾…å¼•å°
    game.gameOver = false;
    game.paused = false;  // æœƒåœ¨é¡¯ç¤ºå¼•å°æ™‚è¨­ç‚ºtrue
    game.victory = false;
    
    // å‰µå»ºæ–°çš„ç©å®¶å’ŒBoss
    player = new Player(100, 200);
    window.player = player; // Make player globally accessible for buff effects
    boss = new MimicBoss(400, 200, game);
    
    game.entities = [player, boss];
    
    console.log('Game initialized. Entities:', game.entities.length);
    console.log('Player position:', player.x, player.y);
    console.log('Boss position:', boss.x, boss.y);
    
    // åˆå§‹åŒ–æ‰‹æ©Ÿæ§åˆ¶
    if (isMobile() || isDebugMode()) {
        initMobileControls();
        console.log('Controls initialized for:', isMobile() ? 'Mobile' : 'Debug mode');
    }
    
    // é–‹å§‹éŠæˆ²å¾ªç’°
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
    lastTime = 0;
    
    // å»¶é²å•Ÿå‹•éŠæˆ²å¾ªç’°ï¼Œç¢ºä¿ä¸€åˆ‡åˆå§‹åŒ–å®Œæˆ
    setTimeout(() => {
        gameLoop();
    }, 100);
}

// éŠæˆ²å¼•æ“é¡
class GameEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        // é—œé–‰åœ–åƒå¹³æ»‘ï¼Œç¢ºä¿åƒç´ è—è¡“é¢¨æ ¼
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.mozImageSmoothingEnabled = false;
        this.ctx.webkitImageSmoothingEnabled = false;
        this.ctx.msImageSmoothingEnabled = false;
        
        this.width = 800;
        this.height = 400;
        
        this.paused = false; // é è¨­ä¸æš«åœ
        this.gameOver = false;
        this.victory = false;
        
        this.entities = [];
        this.particles = [];
        this.projectiles = [];
        this.textEffects = []; // æ–‡å­—ç‰¹æ•ˆé™£åˆ—
        
        this.keys = {};
        this.setupInput();
        
        this.score = 0;
        this.level = 1;
        
        // è¼‰å…¥èƒŒæ™¯
        this.backgroundImage = new Image();
        this.backgroundImage.src = 'Assets/Backgrounds/castle-background.png';
        
        // åˆå§‹åŒ– Three.js buff ç‰¹æ•ˆç³»çµ±
        this.initBuffEffects();
    }
    
    setupInput() {
        document.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            // ESC éµé€€å‡ºå…¨è¢å¹•
            if (e.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
            // F éµåˆ‡æ›å…¨è¢å¹•
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('ç„¡æ³•é€²å…¥å…¨è¢å¹•:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            this.keys[e.key] = false;
        });
    }
    
    update(deltaTime) {
        if (this.paused || this.gameOver) return;
        
        // æ›´æ–°éŠæˆ²æ™‚é–“
        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('gameTime').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // æª¢æŸ¥æ˜¯å¦è¦ç”Ÿæˆé£›æ©Ÿï¼ˆé¦–æ¬¡10ç§’ï¼Œä¹‹å¾Œæ–‡å­—æ¶ˆå¤±20ç§’å¾Œï¼‰
        if (!airplaneSpawned && !airplane) {
            const currentTime = Date.now() / 1000;
            
            // åˆå§‹åŒ–é¦–æ¬¡ç”Ÿæˆæ™‚é–“
            if (!this.nextAirplaneTime) {
                this.nextAirplaneTime = currentTime + 10; // é¦–æ¬¡å›ºå®š10ç§’å¾Œ
            }
            
            if (currentTime >= this.nextAirplaneTime) {
                airplaneSpawned = true;
                airplane = new Airplane(this);
                console.log(`é£›æ©Ÿåœ¨éŠæˆ²é€²è¡Œ ${Math.floor(elapsed)} ç§’æ™‚ç”Ÿæˆï¼`);
                // ä¸‹æ¬¡ç”Ÿæˆæ™‚é–“æœƒåœ¨é£›æ©Ÿæ¶ˆå¤±æ™‚è¨­å®šï¼ˆåœ¨Airplane.updateä¸­ï¼‰
            }
        }
        
        // æ›´æ–°é£›æ©Ÿ
        if (airplane && airplane.active) {
            airplane.update(deltaTime);
        }
        
        // æ›´æ–°ç¦®ç›’æ‰è½ç³»çµ±
        if (giftBoxSystem.triggered) {
            giftBoxSystem.dropTimer += deltaTime;
            
            if (giftBoxSystem.dropTimer >= giftBoxSystem.dropInterval) {
                // ç¢ºä¿ç©å®¶é‚„å­˜åœ¨å†æ‰è½ç¦®ç›’
                if (player && !this.gameOver) {
                    player.dropGiftBox(this);
                    console.log('Recurring gift box dropped!');
                }
                giftBoxSystem.dropTimer = 0;  // é‡ç½®è¨ˆæ™‚å™¨
            }
        }
        
        // æ›´æ–°å¯¦é«”
        this.entities.forEach(entity => {
            entity.update(deltaTime, this);
        });
        
        // æ›´æ–°ç²’å­
        this.particles = this.particles.filter(p => {
            p.life -= deltaTime;
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.vy += 500 * deltaTime;
            return p.life > 0;
        });
        
        // æ›´æ–°æ–‡å­—ç‰¹æ•ˆ
        this.textEffects = this.textEffects.filter(t => {
            t.life -= deltaTime;
            t.x += t.vx * deltaTime;
            t.y += t.vy * deltaTime;
            t.vy += 50 * deltaTime; // è¼ƒæ…¢çš„å‘ä¸Šé£„é€Ÿåº¦
            
            // æ ¹æ“šæ–‡å­—é¡å‹èª¿æ•´æ·¡å‡ºé€Ÿåº¦
            const maxLife = t.text === 'ctrl+c' ? 1.3 : 1.5;
            t.opacity = Math.max(0, t.life / maxLife); // æ¼¸æ¼¸æ·¡å‡º
            t.scale = 1 + (maxLife - t.life) * 0.3; // é€æ¼¸è®Šå¤§
            
            // å¦‚æœæœ‰æ—‹è½‰é€Ÿåº¦ï¼Œæ›´æ–°æ—‹è½‰
            if (t.rotationSpeed) {
                t.rotation += t.rotationSpeed;
            }
            
            return t.life > 0;
        });
        
        // æ›´æ–°æŠ•å°„ç‰©
        this.projectiles = this.projectiles.filter(p => {
            if (p.update) p.update(deltaTime);
            return p.active;
        });
        
        // ç¢°æ’æª¢æ¸¬
        this.checkCollisions();
        
        // æ›´æ–°UI
        this.updateUI();
    }
    
    render() {
        // ç¹ªè£½èƒŒæ™¯ï¼ˆåŒ…å«åœ°æ¿ï¼‰
        if (this.backgroundImage.complete) {
            this.ctx.drawImage(this.backgroundImage, 0, 0, this.width, this.height);
        } else {
            // èƒŒæ™¯åœ–ç‰‡æœªè¼‰å…¥æ™‚çš„å‚™ç”¨ç•«é¢
            this.ctx.fillStyle = '#1a1410';
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = '#2e2416';
            this.ctx.fillRect(0, this.height - 60, this.width, 60);
        }
        
        // å¦‚æœæš«åœï¼Œé¡¯ç¤ºæš«åœæç¤º
        if (this.paused && !document.getElementById('guideWindow').classList.contains('show')) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = '#ffcc66';
            this.ctx.font = '24px "Press Start 2P"';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('PAUSED', this.width/2, this.height/2);
            this.ctx.textAlign = 'left';
        }
        
        // ç¹ªè£½å¯¦é«”
        console.log('Rendering entities:', this.entities.length);
        this.entities.forEach(entity => {
            if (entity.render) {
                console.log('Rendering entity at:', entity.x, entity.y);
                entity.render(this.ctx, this);
            }
        });
        
        // ç¹ªè£½é£›æ©Ÿ
        if (airplane && airplane.active) {
            airplane.render(this.ctx);
        }
        
        // ç¹ªè£½æŠ•å°„ç‰©
        this.projectiles.forEach(p => {
            if (p.render) p.render(this.ctx);
        });
        
        // ç¹ªè£½ç²’å­
        this.particles.forEach(p => {
            this.ctx.save();
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, p.size, p.size);
            this.ctx.restore();
        });
        
        // ç¹ªè£½æ–‡å­—ç‰¹æ•ˆ
        this.textEffects.forEach(t => {
            this.ctx.save();
            
            // å¦‚æœæœ‰æ—‹è½‰ï¼Œæ‡‰ç”¨æ—‹è½‰è®Šæ›
            if (t.rotation) {
                this.ctx.translate(t.x, t.y);
                this.ctx.rotate(t.rotation);
                this.ctx.translate(-t.x, -t.y);
            }
            
            this.ctx.globalAlpha = t.opacity;
            this.ctx.fillStyle = t.color;
            this.ctx.font = `${14 * t.scale}px "Press Start 2P", monospace`; // åƒç´ å­—é«”
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // æ·»åŠ åƒç´ é¢¨æ ¼çš„è¼ªå»“
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            this.ctx.strokeText(t.text, t.x, t.y);
            
            // ç¹ªè£½æ–‡å­—
            this.ctx.fillText(t.text, t.x, t.y);
            
            this.ctx.restore();
        });
        
        // æ›´æ–° Three.js buff ç‰¹æ•ˆ
        if (player && this.updateBuffEffects) {
            this.updateBuffEffects(player);
        }
    }
    
    checkCollisions() {
        this.projectiles.forEach(proj => {
            this.entities.forEach(entity => {
                if (proj.owner !== entity && this.isColliding(proj, entity)) {
                    if (entity.takeDamage) {
                        entity.takeDamage(proj.damage);
                        if (proj.owner && proj.owner.onHitConfirmed) {
                            proj.owner.onHitConfirmed(proj.damage);  // å‚³éå‚·å®³å€¼çµ¦å¸è¡€è¨ˆç®—
                        }
                        proj.active = false;
                    }
                }
            });
        });
        
        // æª¢æŸ¥ç©å®¶èˆ‡ç¦®ç›’çš„ç¢°æ’
        this.entities.forEach(entity => {
            if (entity.isGiftBox && player && this.isColliding(player, entity)) {
                entity.collect(player);
            }
        });
    }
    
    isColliding(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }
    
    addParticle(x, y, type) {
        const configs = {
            damage: { color: '#ff3333', size: 4, vx: (Math.random() - 0.5) * 100, vy: -100 },
            dust: { color: '#8b6914', size: 3, vx: (Math.random() - 0.5) * 50, vy: -50 },
            gold: { color: '#ffcc66', size: 5, vx: (Math.random() - 0.5) * 150, vy: -150 },
            heal: { color: '#00ff00', size: 6, vx: (Math.random() - 0.5) * 80, vy: -120 },
            blocked: { color: '#ff00ff', size: 5, vx: (Math.random() - 0.5) * 120, vy: -80 }
        };
        
        const config = configs[type] || configs.damage;
        this.particles.push({
            x, y,
            ...config,
            life: 0.5
        });
    }
    
    // æ·»åŠ æ–‡å­—ç‰¹æ•ˆ
    addTextEffect(x, y, text, color = '#ffcc66') {
        // ctrl+c å’Œ ctrl+v æœ‰ç¨å¾®ä¸åŒçš„å‹•ç•«
        const isCtrlC = text === 'ctrl+c';
        
        this.textEffects.push({
            x: x + (Math.random() - 0.5) * 10, // è¼•å¾®éš¨æ©Ÿèµ·å§‹ä½ç½®
            y: y,
            text: text,
            color: color,
            vx: (Math.random() - 0.5) * (isCtrlC ? 40 : 30), // ctrl+c æ°´å¹³ç§»å‹•æ›´å¤§
            vy: isCtrlC ? -100 : -80, // ctrl+c å‘ä¸Šé£„æ›´å¿«
            life: isCtrlC ? 1.3 : 1.5, // ctrl+c æ¶ˆå¤±æ›´å¿«
            scale: 1,
            opacity: 1,
            rotation: 0, // æ–°å¢æ—‹è½‰å±¬æ€§
            rotationSpeed: isCtrlC ? (Math.random() - 0.5) * 0.1 : 0 // ctrl+c æœ‰è¼•å¾®æ—‹è½‰
        });
    }
    
    updateUI() {
        document.getElementById('score').textContent = this.score;
    }
    
    togglePause() {
        this.paused = !this.paused;
    }
    
    initBuffEffects() {
        // å„²å­˜ç•¶å‰çš„ç‰¹æ•ˆç‰©ä»¶
        this.activeBuffEffects = {
            invincible: null,
            speed: null,
            vampire: null
        };
        
        this.buffAnimationTime = 0;
    }
    
    createInvincibleEffect(playerX, playerY) {
        console.log('Creating invincible effect at:', playerX, playerY);
        
        // ç§»é™¤èˆŠçš„ç‰¹æ•ˆ
        if (this.activeBuffEffects.invincible) {
            if (this.activeBuffEffects.invincible.element) {
                document.body.removeChild(this.activeBuffEffects.invincible.element);
            }
            this.activeBuffEffects.invincible = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        // å‰µå»ºä¸»è¦ç¾¤çµ„
        const group = new THREE.Group();
        
        // èª¿æ•´ç›¸æ©Ÿå’Œç¾¤çµ„ä½ç½®
        camera.position.z = 150;
        
        // === ç„¡æ•µ BUFF ç‰¹æ•ˆè¨­è¨ˆ ===
        // ä¸»é¡Œï¼šã€Œé€™æ˜¯ä¸€å€‹å¾ˆæ£’çš„æƒ³æ³•ã€ - å®Œç¾é˜²è­·ç½©
        
        // 1. èƒ½é‡æ ¸å¿ƒ - åƒå¿ƒè‡Ÿèˆ¬è·³å‹•çš„ç¶ è‰²æ ¸å¿ƒ
        const coreGeometry = new THREE.IcosahedronGeometry(10, 2);
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff88,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        group.add(core);
        
        // æ·»åŠ å…‰æºä¾†å¢å¼·æ•ˆæœ
        const light = new THREE.PointLight(0x00ff00, 2, 100);
        light.position.set(0, 0, 20);
        scene.add(light);
        
        // 2. å…­è§’å½¢èƒ½é‡è­·ç›¾ - ç§‘æŠ€æ„Ÿé˜²è­·ç½©
        const hexagonPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i) / 6;
            hexagonPoints.push(new THREE.Vector2(Math.cos(angle) * 35, Math.sin(angle) * 35));
        }
        const hexShape = new THREE.Shape(hexagonPoints);
        const hexGeometry = new THREE.ShapeGeometry(hexShape);
        
        // å‰µå»ºå¤šå€‹å…­è§’å½¢å±¤
        const hexShields = [];
        for (let i = 0; i < 3; i++) {
            const hexMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(0, 1, 0.5 - i * 0.2),
                transparent: true,
                opacity: 0.2 - i * 0.05,
                side: THREE.DoubleSide
            });
            const hexShield = new THREE.Mesh(hexGeometry, hexMaterial);
            hexShield.position.z = i * 5;
            hexShields.push(hexShield);
            group.add(hexShield);
        }
        
        // 3. èƒ½é‡æµå‹•ç’° - é¡¯ç¤ºèƒ½é‡æµå‹•
        const flowRings = [];
        for (let i = 0; i < 4; i++) {
            const ringGeometry = new THREE.TorusGeometry(20 + i * 8, 0.5, 16, 64);
            const ringMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3 - i * 0.05,
                transparent: true,
                opacity: 0.4 - i * 0.1
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = (Math.PI / 2) + (Math.PI / 6) * i;
            ring.rotation.y = (Math.PI / 8) * i;
            flowRings.push(ring);
            group.add(ring);
        }
        
        // 4. é˜²è­·ç²’å­ç³»çµ± - èºæ—‹ä¸Šå‡çš„èƒ½é‡ç²’å­
        const particleCount = 200;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            // èºæ—‹åˆ†ä½ˆ
            const t = i / particleCount;
            const angle = t * Math.PI * 8;
            const radius = 15 + t * 25;
            const height = (t - 0.5) * 60;
            
            positions[i * 3] = Math.cos(angle) * radius;
            positions[i * 3 + 1] = height;
            positions[i * 3 + 2] = Math.sin(angle) * radius;
            
            // æ¼¸è®Šç¶ è‰²
            colors[i * 3] = 0;
            colors[i * 3 + 1] = 0.5 + t * 0.5;
            colors[i * 3 + 2] = 0.2;
            
            // ç²’å­å¤§å°éš¨é«˜åº¦è®ŠåŒ–
            sizes[i] = Math.random() * 3 + 1;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.6,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        group.add(particleSystem);
        
        // 5. å¤–å±¤èƒ½é‡å ´ - æ³¢å‹•çš„é˜²è­·å ´
        const fieldGeometry = new THREE.SphereGeometry(45, 32, 32);
        const fieldMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ff00) }
            },
            vertexShader: `
                varying vec3 vNormal;
                uniform float time;
                void main() {
                    vNormal = normal;
                    vec3 pos = position;
                    float displacement = sin(pos.x * 10.0 + time) * sin(pos.y * 10.0 + time) * sin(pos.z * 10.0 + time) * 0.5;
                    pos += normal * displacement;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float time;
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                    gl_FragColor = vec4(color, intensity * 0.3);
                }
            `,
            transparent: true,
            side: THREE.BackSide
        });
        const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
        group.add(field);
        
        scene.add(group);
        
        // å„²å­˜æ‰€æœ‰éœ€è¦å‹•ç•«çš„å…ƒç´ 
        const animationData = {
            core,
            hexShields,
            flowRings,
            particleSystem,
            particleCount,
            field,
            light
        };
        
        // é–‹å§‹å‹•ç•«å¾ªç’°
        const animate = () => {
            try {
                if (!this.activeBuffEffects.invincible) return;
                
                requestAnimationFrame(animate);
            
            // å‹•ç•«æ•ˆæœ
            const time = Date.now() * 0.001;
            
            // æ ¸å¿ƒè·³å‹•æ•ˆæœ
            const heartbeat = 1 + Math.sin(time * 4) * 0.1;
            animationData.core.scale.set(heartbeat, heartbeat, heartbeat);
            animationData.core.rotation.x += 0.01;
            animationData.core.rotation.y += 0.02;
            
            // å…­è§’å½¢è­·ç›¾æ—‹è½‰
            animationData.hexShields.forEach((shield, i) => {
                shield.rotation.z += 0.01 * (i + 1);
                const pulse = 1 + Math.sin(time * 2 + i * 0.5) * 0.05;
                shield.scale.set(pulse, pulse, 1);
            });
            
            // èƒ½é‡ç’°æµå‹•
            animationData.flowRings.forEach((ring, i) => {
                ring.rotation.z += 0.02 * (i % 2 === 0 ? 1 : -1);
                ring.rotation.x += 0.005;
            });
            
            // ç²’å­èºæ—‹ä¸Šå‡
            animationData.particleSystem.rotation.y += 0.01;
            const particlePositions = animationData.particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < animationData.particleCount; i++) {
                particlePositions[i * 3 + 1] += 0.5;
                if (particlePositions[i * 3 + 1] > 30) {
                    particlePositions[i * 3 + 1] = -30;
                }
            }
            animationData.particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // æ›´æ–°èƒ½é‡å ´ shader
            animationData.field.material.uniforms.time.value = time;
            
            // å…‰æºè„ˆå‹•
            animationData.light.intensity = 2 + Math.sin(time * 3) * 0.5;
            
            // æ›´æ–°ä½ç½®è·Ÿéš¨ç©å®¶
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
            } catch (error) {
                console.error('Error in invincible effect animation:', error);
            }
        };
        
        animate();
        
        // å„²å­˜ç‰¹æ•ˆè³‡è¨Š
        this.activeBuffEffects.invincible = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    createSpeedEffect(playerX, playerY) {
        // ç§»é™¤èˆŠçš„ç‰¹æ•ˆ
        if (this.activeBuffEffects.speed) {
            if (this.activeBuffEffects.speed.element) {
                document.body.removeChild(this.activeBuffEffects.speed.element);
            }
            this.activeBuffEffects.speed = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        camera.position.z = 150;
        
        const group = new THREE.Group();
        
        // === é€Ÿåº¦ BUFF ç‰¹æ•ˆè¨­è¨ˆ ===
        // ä¸»é¡Œï¼šã€ŒRun Don't Walkã€ - æ¥µé€ŸåŠ é€Ÿ
        
        // 1. é€Ÿåº¦ç·šç‰¹æ•ˆ - å‹•æ…‹é€Ÿåº¦ç·š
        const speedLines = new THREE.Group();
        const lineCount = 30;
        const speedLineData = [];
        
        for (let i = 0; i < lineCount; i++) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6); // 2å€‹é»å½¢æˆä¸€æ¢ç·š
            
            const angle = (Math.PI * 2 * i) / lineCount + Math.random() * 0.2;
            const startRadius = 10 + Math.random() * 5;
            const endRadius = 40 + Math.random() * 20;
            
            // èµ·é»
            positions[0] = Math.cos(angle) * startRadius;
            positions[1] = Math.sin(angle) * startRadius;
            positions[2] = (Math.random() - 0.5) * 10;
            
            // çµ‚é»
            positions[3] = Math.cos(angle) * endRadius;
            positions[4] = Math.sin(angle) * endRadius;
            positions[5] = (Math.random() - 0.5) * 10;
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // æ¼¸è®Šé¡è‰² - å¾äº®é’åˆ°é€æ˜ç™½
            const colors = new Float32Array(6);
            colors[0] = 0; colors[1] = 1; colors[2] = 1; // é’è‰²
            colors[3] = 1; colors[4] = 1; colors[5] = 1; // ç™½è‰²
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: Math.random() * 0.5 + 0.3,
                linewidth: 2,
                blending: THREE.AdditiveBlending
            });
            
            const line = new THREE.Line(geometry, material);
            speedLineData.push({
                line: line,
                speed: Math.random() * 0.5 + 0.5,
                offset: Math.random() * Math.PI * 2
            });
            speedLines.add(line);
        }
        group.add(speedLines);
        
        // 2. é›»å­è»Œé“ç’° - é«˜é€Ÿæ—‹è½‰çš„èƒ½é‡ç’°
        const orbitRings = [];
        for (let i = 0; i < 3; i++) {
            const ringRadius = 25 + i * 10;
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(ringRadius, 0.8, 8, 64),
                new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00aaff,
                    emissiveIntensity: 0.5 - i * 0.1,
                    transparent: true,
                    opacity: 0.6 - i * 0.15
                })
            );
            
            // ä¸åŒè§’åº¦çš„è»Œé“
            if (i === 0) ring.rotation.x = Math.PI / 2;
            if (i === 1) {
                ring.rotation.x = Math.PI / 3;
                ring.rotation.y = Math.PI / 4;
            }
            if (i === 2) {
                ring.rotation.x = Math.PI / 4;
                ring.rotation.z = Math.PI / 3;
            }
            
            orbitRings.push(ring);
            group.add(ring);
        }
        
        // 3. é€Ÿåº¦ç²’å­é›² - æ®˜å½±æ•ˆæœ
        const trailParticles = [];
        const trailCount = 5;
        
        for (let t = 0; t < trailCount; t++) {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 30;
                particlePositions[i * 3] = Math.cos(angle) * radius;
                particlePositions[i * 3 + 1] = Math.sin(angle) * radius;
                particlePositions[i * 3 + 2] = -t * 5 + (Math.random() - 0.5) * 5;
                
                particleSizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: new THREE.Color(0, 1 - t * 0.1, 1),
                size: 3 - t * 0.5,
                transparent: true,
                opacity: 0.6 - t * 0.1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            trailParticles.push(particles);
            group.add(particles);
        }
        
        // 4. é€Ÿåº¦æ ¸å¿ƒ - é«˜é€Ÿæ—‹è½‰çš„èƒ½é‡æ ¸å¿ƒ
        const coreGroup = new THREE.Group();
        
        // å…§æ ¸
        const innerCore = new THREE.Mesh(
            new THREE.TetrahedronGeometry(8, 2),
            new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            })
        );
        coreGroup.add(innerCore);
        
        // å¤–æ ¸ç·šæ¡†
        const outerCore = new THREE.Mesh(
            new THREE.OctahedronGeometry(15, 0),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.4,
                wireframe: true
            })
        );
        coreGroup.add(outerCore);
        group.add(coreGroup);
        
        // æ·»åŠ é€Ÿåº¦å…‰æº
        const speedLight = new THREE.PointLight(0x00ffff, 2, 100);
        speedLight.position.set(0, 0, 20);
        scene.add(speedLight);
        
        scene.add(group);
        
        // å„²å­˜æ‰€æœ‰éœ€è¦å‹•ç•«çš„å…ƒç´ 
        const animationData = {
            speedLineData,
            orbitRings,
            trailParticles,
            innerCore,
            outerCore,
            speedLight
        };
        
        // é–‹å§‹å‹•ç•«å¾ªç’°
        const animate = () => {
            if (!this.activeBuffEffects.speed) return;
            
            requestAnimationFrame(animate);
            
            // å‹•ç•«æ•ˆæœ
            const time = Date.now() * 0.001;
            
            // é€Ÿåº¦ç·šå‹•æ…‹æµå‹•
            animationData.speedLineData.forEach((data, i) => {
                const line = data.line;
                const positions = line.geometry.attributes.position.array;
                const newAngle = data.offset + time * data.speed;
                
                // æ›´æ–°ç·šæ¢ä½ç½®ä¾†å‰µé€ æµå‹•æ•ˆæœ
                const startRadius = 10 + Math.sin(time * 3 + i) * 5;
                const endRadius = 40 + Math.sin(time * 2 + i) * 10;
                
                positions[0] = Math.cos(newAngle) * startRadius;
                positions[1] = Math.sin(newAngle) * startRadius;
                positions[3] = Math.cos(newAngle) * endRadius;
                positions[4] = Math.sin(newAngle) * endRadius;
                
                line.geometry.attributes.position.needsUpdate = true;
                line.material.opacity = 0.3 + Math.sin(time * 4 + i) * 0.3;
            });
            
            // è»Œé“ç’°é«˜é€Ÿæ—‹è½‰
            animationData.orbitRings.forEach((ring, i) => {
                ring.rotation.z += 0.1 * (i + 1);
                ring.rotation.y += 0.05 * (2 - i);
                const pulse = 1 + Math.sin(time * 5 + i) * 0.1;
                ring.scale.set(pulse, pulse, pulse);
            });
            
            // æ®˜å½±ç²’å­æµå‹•
            animationData.trailParticles.forEach((particles, t) => {
                particles.rotation.y += 0.02 * (t + 1);
                particles.position.z = -t * 3 + Math.sin(time * 3) * 2;
                particles.material.opacity = 0.6 - t * 0.1 - Math.sin(time * 2) * 0.1;
            });
            
            // æ ¸å¿ƒé«˜é€Ÿæ—‹è½‰
            animationData.innerCore.rotation.x += 0.1;
            animationData.innerCore.rotation.y += 0.15;
            animationData.innerCore.rotation.z += 0.05;
            
            animationData.outerCore.rotation.x -= 0.08;
            animationData.outerCore.rotation.y += 0.12;
            
            // æ ¸å¿ƒè„ˆå‹•
            const corePulse = 1 + Math.sin(time * 8) * 0.2;
            animationData.innerCore.scale.set(corePulse, corePulse, corePulse);
            
            // å…‰æºé–ƒçˆ
            animationData.speedLight.intensity = 2 + Math.sin(time * 10) * 1;
            
            // æ›´æ–°ä½ç½®è·Ÿéš¨ç©å®¶
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
        };
        
        animate();
        
        // å„²å­˜ç‰¹æ•ˆè³‡è¨Š
        this.activeBuffEffects.speed = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    createVampireEffect(playerX, playerY) {
        // ç§»é™¤èˆŠçš„ç‰¹æ•ˆ
        if (this.activeBuffEffects.vampire) {
            if (this.activeBuffEffects.vampire.element) {
                document.body.removeChild(this.activeBuffEffects.vampire.element);
            }
            this.activeBuffEffects.vampire = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        camera.position.z = 100;
        
        const group = new THREE.Group();
        
        // ç´«è‰²å¸è¡€å…‰ç’°ï¼ˆç¸®å°å°ºå¯¸ï¼‰
        const rings = [];
        for (let i = 0; i < 3; i++) {
            const ringGeometry = new THREE.RingGeometry(25 + i * 8, 28 + i * 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.3 - i * 0.1,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            rings.push(ring);
            group.add(ring);
        }
        
        // èºæ—‹ç²’å­ï¼ˆç¸®å°å°ºå¯¸ï¼‰
        const particleCount = 50;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            const t = i / particleCount * Math.PI * 4;
            const radius = 20 + t * 2;
            positions[i * 3] = Math.cos(t) * radius;
            positions[i * 3 + 1] = t * 3 - 50;
            positions[i * 3 + 2] = Math.sin(t) * radius;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xff00ff,
            size: 3,
            transparent: true,
            opacity: 0.7
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        group.add(particleSystem);
        
        // æ·»åŠ å…‰æº
        const vampireLight = new THREE.PointLight(0xff00ff, 2, 100);
        vampireLight.position.set(0, 0, 50);
        scene.add(vampireLight);
        
        scene.add(group);
        
        // å„²å­˜æ‰€æœ‰éœ€è¦å‹•ç•«çš„å…ƒç´ ï¼ˆä½¿ç”¨å¯¦éš›å­˜åœ¨çš„è®Šæ•¸ï¼‰
        const animationData = {
            rings,           // ä½¿ç”¨å¯¦éš›å®šç¾©çš„ rings
            particleSystem,  // ä½¿ç”¨å¯¦éš›å®šç¾©çš„ particleSystem
            particleCount,   // ç²’å­æ•¸é‡
            vampireLight     // ä½¿ç”¨å¯¦éš›å®šç¾©çš„ vampireLight
        };
        
        // é–‹å§‹å‹•ç•«å¾ªç’°
        const animate = () => {
            if (!this.activeBuffEffects.vampire) return;
            
            requestAnimationFrame(animate);
            
            // å‹•ç•«æ•ˆæœ
            const time = Date.now() * 0.001;
            
            // å…‰ç’°æ—‹è½‰
            animationData.rings.forEach((ring, i) => {
                ring.rotation.z += 0.03 * (i + 1);
                const scale = 1 + Math.sin(time * 2 + i * 0.5) * 0.15;
                ring.scale.set(scale, scale, 1);
            });
            
            // èºæ—‹ç²’å­å‹•ç•«
            const positions = animationData.particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < animationData.particleCount; i++) {
                const t = i / animationData.particleCount * Math.PI * 4 + time;
                const radius = 20 + Math.sin(t) * 5;
                positions[i * 3] = Math.cos(t) * radius;
                positions[i * 3 + 1] = Math.sin(time * 2 + i * 0.1) * 10;
                positions[i * 3 + 2] = Math.sin(t) * radius;
            }
            animationData.particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // æ•´é«”ç¾¤çµ„æ—‹è½‰
            group.rotation.y += 0.02;
            
            // å…‰æºè„ˆå‹•
            animationData.vampireLight.intensity = 2 + Math.sin(time * 4) * 0.8;
            
            // æ›´æ–°ä½ç½®è·Ÿéš¨ç©å®¶
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
        };
        
        animate();
        
        // å„²å­˜ç‰¹æ•ˆè³‡è¨Š
        this.activeBuffEffects.vampire = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    updateBuffEffects(player) {
        // è¨ˆç®—ç©å®¶ä¸­å¿ƒä½ç½®
        const x = player.x + player.width / 2;
        const y = player.y + player.height / 2;
        
        // æ›´æ–°æˆ–å‰µå»ºå°æ‡‰çš„ç‰¹æ•ˆ
        if (player.buffType === 'invincible' && player.invincible) {
            if (!this.activeBuffEffects.invincible) {
                console.log('Player has invincible buff, creating effect...');
                this.createInvincibleEffect(x, y);
            }
        } else if (this.activeBuffEffects.invincible) {
            if (this.activeBuffEffects.invincible.element) {
                document.body.removeChild(this.activeBuffEffects.invincible.element);
            }
            this.activeBuffEffects.invincible = null;
        }
        
        if (player.buffType === 'speed' && player.speedBoost) {
            if (!this.activeBuffEffects.speed) {
                this.createSpeedEffect(x, y);
            }
        } else if (this.activeBuffEffects.speed) {
            if (this.activeBuffEffects.speed.element) {
                document.body.removeChild(this.activeBuffEffects.speed.element);
            }
            this.activeBuffEffects.speed = null;
        }
        
        if (player.buffType === 'vampire' && player.lifeSteal) {
            if (!this.activeBuffEffects.vampire) {
                this.createVampireEffect(x, y);
            }
        } else if (this.activeBuffEffects.vampire) {
            if (this.activeBuffEffects.vampire.element) {
                document.body.removeChild(this.activeBuffEffects.vampire.element);
            }
            this.activeBuffEffects.vampire = null;
        }
    }
    
}

// ç©å®¶é¡
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 96;  // æ”¹ç‚º 96x96
        this.height = 96; // æ”¹ç‚º 96x96
        
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.vx = 0;
        this.vy = 0;
        this.speed = 250;
        this.baseSpeed = 250;  // åŸºç¤é€Ÿåº¦
        this.jumpPower = 450;
        this.grounded = false;
        this.facing = 1;  // 1=å³, -1=å·¦
        
        this.combo = 0;
        this.attackCooldown = 0;
        this.baseAttackCooldown = 0.5;  // åŸºç¤æ”»æ“Šå†·å»
        
        // Buff ç³»çµ±
        this.invincible = false;
        this.speedBoost = false;
        this.doubleAttack = false;
        this.lifeSteal = false;
        this.buffTimer = 0;
        this.buffType = null;
        this.attackMultiplier = 1;
        
        // å‹•ç•«ç³»çµ±
        this.animations = {
            attack: [],
            idle: [],
            walk: [],
            jump: [],
            hurt: []
        };
        this.currentAnimation = 'idle';  // é è¨­é¡¯ç¤ºå¾…æ©Ÿå‹•ç•«
        this.animationFrame = 0;
        this.animationTimer = 0;
        this.animationSpeed = 0.08; // æ¯å¹€0.08ç§’
        
        // è¼‰å…¥å‹•ç•«
        this.loadAnimations();
    }
    
    loadAnimations() {
        // è¼‰å…¥æ”»æ“Šå‹•ç•« (4å¹€)
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `Assets/Player/Sprites/Attack/player_attack_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded player attack frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load player attack frame ${i}`);
            };
            this.animations.attack.push(img);
        }
        
        // è¼‰å…¥å¾…æ©Ÿå‹•ç•« (åªä½¿ç”¨å–®ä¸€å¹€ idle-1.png)
        const idleImg = new Image();
        idleImg.src = 'Assets/Player/Sprites/Idle/idle-1.png';
        idleImg.onload = () => {
            console.log('Loaded player idle frame');
        };
        idleImg.onerror = () => {
            console.error('Failed to load player idle frame');
        };
        this.animations.idle.push(idleImg);
        
        // è¼‰å…¥è¡Œèµ°å‹•ç•« (6å¹€)
        for (let i = 1; i <= 6; i++) {
            const walkImg = new Image();
            walkImg.src = `Assets/Player/Sprites/Walk/player_walk_frame${i}.png`;
            walkImg.onload = () => {
                console.log(`Loaded player walk frame ${i}`);
            };
            walkImg.onerror = () => {
                console.error(`Failed to load player walk frame ${i}`);
            };
            this.animations.walk.push(walkImg);
        }
    }
    
    update(deltaTime, game) {
        // å®‰å…¨æª¢æŸ¥ deltaTime
        if (!deltaTime || isNaN(deltaTime)) {
            deltaTime = 0.016; // é è¨­ 60fps
        }
        
        // æ›´æ–° Buff è¨ˆæ™‚å™¨
        if (this.buffTimer > 0) {
            this.buffTimer -= deltaTime;
            
            // Buff çµæŸè™•ç†
            if (this.buffTimer <= 0) {
                this.endBuff();
            }
        }
        
        
        // å…¥å ´å‹•ç•«
        if (this.targetX !== undefined) {
            const dx = this.targetX - this.x;
            if (Math.abs(dx) > 5) {
                this.x += dx * 0.1;
            } else {
                this.x = this.targetX;
                delete this.targetX;
            }
        }
        
        // è¼¸å…¥è™•ç†
        if (!this.targetX && game.keys['ArrowLeft']) {
            this.vx = -this.speed;
            this.facing = -1;
        } else if (!this.targetX && game.keys['ArrowRight']) {
            this.vx = this.speed;
            this.facing = 1;
        } else {
            this.vx *= 0.8;
        }
        
        if (game.keys['ArrowUp'] && this.grounded) {
            this.vy = -this.jumpPower;
            this.grounded = false;
        }
        
        if (game.keys[' '] && this.attackCooldown <= 0) {
            this.attack(game);
        }
        
        // ç‰©ç†
        this.vy += 800 * deltaTime;
        
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        
        // é‚Šç•Œ
        this.x = Math.max(0, Math.min(this.x, game.width - this.width));
        
        // åœ°é¢
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
        
        // æ›´æ–°å†·å»
        if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
        }
        
        // æ›´æ–°UI
        this.updateHealth();
        document.getElementById('combo').textContent = this.combo;
        
        // æ›´æ–°å‹•ç•«
        this.updateAnimation(deltaTime);
    }
    
    playAnimation(animationName) {
        if (this.currentAnimation !== animationName) {
            this.currentAnimation = animationName;
            this.animationFrame = 0;
            this.animationTimer = 0;
        }
    }
    
    updateAnimation(deltaTime) {
        // æ±ºå®šè¦æ’­æ”¾çš„å‹•ç•«
        if (this.attackCooldown <= 0) {  // æ²’æœ‰åœ¨æ”»æ“Šæ™‚
            if (Math.abs(this.vx) > 10 && this.grounded) {
                // åœ¨åœ°é¢ä¸Šç§»å‹•æ™‚æ’­æ”¾è¡Œèµ°å‹•ç•«
                if (this.currentAnimation !== 'walk') {
                    this.playAnimation('walk');
                }
            } else if (Math.abs(this.vx) < 10 && this.grounded) {
                // åœ¨åœ°é¢ä¸Šéœæ­¢æ™‚æ’­æ”¾å¾…æ©Ÿå‹•ç•«
                if (this.currentAnimation !== 'idle') {
                    this.playAnimation('idle');
                }
            }
        }
        
        if (!this.currentAnimation || !this.animations[this.currentAnimation]) return;
        
        const frames = this.animations[this.currentAnimation];
        if (frames.length === 0) return;
        
        this.animationTimer += deltaTime;
        
        if (this.animationTimer >= this.animationSpeed) {
            this.animationTimer = 0;
            this.animationFrame++;
            
            // æ”»æ“Šå‹•ç•«æ’­æ”¾å®Œç•¢ï¼Œåˆ‡æ›åˆ°å¾…æ©Ÿæˆ–è¡Œèµ°
            if (this.currentAnimation === 'attack' && this.animationFrame >= frames.length) {
                if (Math.abs(this.vx) > 10 && this.grounded) {
                    this.playAnimation('walk');
                } else {
                    this.playAnimation('idle');
                }
            }
            
            // è¡Œèµ°å‹•ç•«å¾ªç’°
            if (this.currentAnimation === 'walk' && this.animationFrame >= frames.length) {
                this.animationFrame = 0;
            }
            
            // Idle å‹•ç•« (å–®ä¸€å¹€ï¼Œä¸éœ€è¦å¾ªç’°)
            if (this.currentAnimation === 'idle') {
                this.animationFrame = 0;  // å§‹çµ‚ä¿æŒåœ¨ç¬¬ä¸€å¹€
            }
        }
    }
    
    attack(game) {
        // é€Ÿåº¦åŠ æˆæ™‚æ”»æ“Šé€Ÿåº¦ä¹ŸåŠ å¿«
        this.attackCooldown = this.speedBoost ? this.baseAttackCooldown / 2.5 : this.baseAttackCooldown;
        
        // æ’­æ”¾æ”»æ“Šå‹•ç•«
        if (this.animations.attack.length > 0) {
            this.playAnimation('attack');
        }
        
        const baseDamage = 10;
        const attackBox = {
            x: this.x + (this.facing === 1 ? this.width : -20),
            y: this.y + 20,
            width: 20,
            height: this.height - 40,
            damage: baseDamage * this.attackMultiplier,  // æ‡‰ç”¨æ”»æ“Šå€ç‡
            owner: this,
            active: true,
            life: 0.3,  // å¢åŠ æ”»æ“Šåˆ¤å®šæ™‚é–“å¾0.1ç§’åˆ°0.3ç§’
            lifeSteal: this.lifeSteal,  // å‚³éå¸è¡€å±¬æ€§
            
            update(deltaTime) {
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // æ”»æ“Šåˆ¤å®šæ¡†ä¸é¡¯ç¤ºè¦–è¦ºæ•ˆæœ
            }
        };
        
        game.projectiles.push(attackBox);
    }
    
    onHitConfirmed(damage) {
        this.combo++;
        game.score += 10 * this.combo;
        
        // é¡¯ç¤º "ctrl+c" æˆ– "ctrl+v" æ–‡å­—ç‰¹æ•ˆï¼ˆéš¨æ©Ÿï¼‰
        if (game && game.addTextEffect) {
            // éš¨æ©Ÿé¸æ“‡æ–‡å­—ï¼ˆ70% ctrl+v, 30% ctrl+cï¼‰
            const textOptions = ['ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+c', 'ctrl+c', 'ctrl+c'];
            const randomText = textOptions[Math.floor(Math.random() * textOptions.length)];
            
            // æ ¹æ“šç‹€æ…‹é¸æ“‡é¡è‰²
            let textColor = '#ffcc66'; // é è¨­é»ƒè‰²
            if (this.buffType === 'vampire') {
                textColor = '#ff00ff'; // å¸è¡€æ™‚ç´«è‰²
            } else if (this.buffType === 'invincible') {
                textColor = '#00ff00'; // ç„¡æ•µæ™‚ç¶ è‰²
            } else if (this.buffType === 'speed') {
                textColor = '#00ffff'; // åŠ é€Ÿæ™‚é’è‰²
            } else if (this.combo > 5) {
                textColor = '#ff6600'; // é«˜é€£æ“Šæ™‚æ©™è‰²
            }
            
            // ctrl+c æ™‚å¯ä»¥ç”¨ç¨å¾®ä¸åŒçš„é¡è‰²è®ŠåŒ–
            if (randomText === 'ctrl+c' && textColor === '#ffcc66') {
                textColor = '#66ccff'; // ctrl+c é è¨­æ™‚ç”¨æ·ºè—è‰²
            }
            
            // åœ¨ç©å®¶ä¸Šæ–¹é¡¯ç¤ºæ–‡å­—
            game.addTextEffect(
                this.x + this.width/2, 
                this.y - 20, 
                randomText, 
                textColor
            );
        }
        
        // å¸è¡€æ•ˆæœ
        if (this.lifeSteal && damage) {
            this.health = Math.min(this.health + damage, this.maxHealth);
            this.updateHealth();
            // é¡¯ç¤ºå¸è¡€æ•ˆæœ
            game.addParticle(this.x + this.width/2, this.y, 'heal');
        }
    }
    
    // æ‡‰ç”¨ Buff æ•ˆæœ
    applyBuff(buffType) {
        this.buffType = buffType;
        this.buffTimer = 10; // 10ç§’æŒçºŒæ™‚é–“ï¼ˆé™¤äº†è¢«ç¥–ï¼‰
        
        switch(buffType) {
            case 'invincible':
                // "é€™æ˜¯ä¸€å€‹å¾ˆæ£’çš„æƒ³æ³•" - ç„¡æ•µ10ç§’
                this.invincible = true;
                break;
                
            case 'speed':
                // "Run Don't walk" - é€Ÿåº¦2.5å€
                this.speedBoost = true;
                this.speed = this.baseSpeed * 2.5;
                break;
                
            case 'vampire':
                // "è¤‡è£½è²¼ä¸Š" - æ”»æ“ŠåŠ›1.5å€+å¸è¡€
                this.doubleAttack = true;
                this.lifeSteal = true;
                this.attackMultiplier = 1.5;
                break;
                
            case 'cursed':
                // "è¢«ç¥–äº†" - ç›´æ¥æ­»äº¡
                this.buffTimer = 0;
                setTimeout(() => {
                    this.health = 0;
                    this.updateHealth();
                    game.gameOver = true;
                    showGameOverScreen(false);
                }, 100);
                break;
        }
    }
    
    // çµæŸ Buff æ•ˆæœ
    endBuff() {
        if (this.buffType === 'invincible') {
            // ç„¡æ•µçµæŸå¾Œè£œæ»¿è¡€
            this.health = this.maxHealth;
            this.updateHealth();
        }
        
        // é‡ç½®æ‰€æœ‰ buff ç‹€æ…‹
        this.invincible = false;
        this.speedBoost = false;
        this.speed = this.baseSpeed;
        this.doubleAttack = false;
        this.lifeSteal = false;
        this.attackMultiplier = 1;
        this.buffType = null;
    }
    
    // æ‰è½ç¦®ç›’çš„é€šç”¨æ–¹æ³•
    dropGiftBox(game) {
        // éš¨æ©Ÿä½ç½®æ‰è½ï¼ˆé¿å…å¤ªé è¿‘é‚Šç·£ï¼‰
        const x = Math.random() * (game.width - 100) + 50;
        const y = -50;  // å¾å¤©ç©ºæ‰è½
        
        const giftBox = new GiftBox(x, y, game);
        game.entities.push(giftBox);
        
        // é¡¯ç¤ºæ‰è½æç¤º
        game.addParticle(x + 25, y + 60, 'gold');
        console.log('Gift box dropped at:', x, y);
    }
    
    takeDamage(damage) {
        // ç„¡æ•µç‹€æ…‹ä¸å—å‚·å®³
        if (this.invincible) {
            return;
        }
        
        const oldHealth = this.health;
        this.health -= damage;
        this.health = Math.max(0, this.health);
        this.combo = 0;
        
        // æª¢æŸ¥æ˜¯å¦è§¸ç™¼ç¦®ç›’æ‰è½ï¼ˆè¡€é‡é¦–æ¬¡é™åˆ°50%æˆ–ä»¥ä¸‹ï¼‰
        if (!giftBoxSystem.triggered && oldHealth > this.maxHealth * 0.5 && this.health <= this.maxHealth * 0.5) {
            giftBoxSystem.triggered = true;
            giftBoxSystem.dropTimer = 0;  // é‡ç½®è¨ˆæ™‚å™¨
            this.dropGiftBox(game);
            console.log('First gift box triggered! Recurring drops every 10 seconds.');
        }
        
        this.updateHealth();
        
        if (this.health <= 0) {
            game.gameOver = true;
            showGameOverScreen(false);
        }
    }
    
    updateHealth() {
        const percent = (this.health / this.maxHealth) * 100;
        document.getElementById('playerHP').textContent = `${this.health}/${this.maxHealth}`;
        document.getElementById('playerHealthBar').style.width = percent + '%';
    }
    
    render(ctx) {
        ctx.save();
        
        // Buff å‰©é¤˜æ™‚é–“é¡¯ç¤ºï¼ˆThree.js ç‰¹æ•ˆåœ¨ GameEngine ä¸­è™•ç†ï¼‰
        if (this.buffType && this.buffTimer > 0) {
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(Math.ceil(this.buffTimer) + 's', this.x + this.width/2, this.y - 10);
            ctx.restore();
        }
        
        // å„ªå…ˆé¡¯ç¤ºå‹•ç•«ï¼ˆæ”»æ“Šæˆ–å¾…æ©Ÿï¼‰
        if (this.currentAnimation && this.animations[this.currentAnimation].length > 0) {
            const frames = this.animations[this.currentAnimation];
            const frameIndex = Math.min(this.animationFrame, frames.length - 1);
            const currentFrame = frames[frameIndex];
            
            if (currentFrame && currentFrame.complete && currentFrame.width > 0) {
                ctx.save();
                if (this.facing === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(currentFrame, -this.x - this.width, this.y, this.width, this.height);
                } else {
                    ctx.drawImage(currentFrame, this.x, this.y, this.width, this.height);
                }
                ctx.restore();
                ctx.restore();
                return; // é¡¯ç¤ºå‹•ç•«å¾Œç›´æ¥è¿”å›
            }
        }
        
        // å¦‚æœæ²’æœ‰ç•¶å‰å‹•ç•«ï¼Œå˜—è©¦é¡¯ç¤ºå¾…æ©Ÿåœ–ç‰‡
        if (!this.currentAnimation && this.animations.idle.length > 0) {
            const idleFrame = this.animations.idle[0];
            if (idleFrame && idleFrame.complete && idleFrame.width > 0) {
                ctx.save();
                if (this.facing === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(idleFrame, -this.x - this.width, this.y, this.width, this.height);
                } else {
                    ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                }
                ctx.restore();
                ctx.restore();
                return; // é¡¯ç¤ºå¾…æ©Ÿåœ–ç‰‡å¾Œç›´æ¥è¿”å›
            }
        }
        
        // é¡åƒè™•ç† - é¢å‘å·¦æ™‚ç¿»è½‰ï¼ˆåªåœ¨æ²’æœ‰å‹•ç•«æ™‚ä½¿ç”¨ï¼‰
        if (this.facing === -1) {
            ctx.scale(-1, 1);
            ctx.translate(-this.x * 2 - this.width, 0);
        }
        
        // æ”¾å¤§2å€çš„é¨å£«é€ å‹ï¼ˆæ²’æœ‰å‹•ç•«æ™‚é¡¯ç¤ºï¼‰
        // é ­ç›”
        ctx.fillStyle = '#999999';
        ctx.fillRect(this.x + 16, this.y + 8, 32, 32);
        
        // çœ¼ç›ç¸«éš™
        ctx.fillStyle = '#333333';
        ctx.fillRect(this.x + 22, this.y + 18, 8, 3);
        ctx.fillRect(this.x + 34, this.y + 18, 8, 3);
        
        // èº«é«”(ç›”ç”²)
        ctx.fillStyle = '#cccccc';
        ctx.fillRect(this.x + 16, this.y + 40, 32, 32);
        
        // ç›”ç”²ç´°ç¯€
        ctx.fillStyle = '#999999';
        ctx.fillRect(this.x + 28, this.y + 45, 8, 20);
        
        // è…¿
        ctx.fillStyle = '#777777';
        ctx.fillRect(this.x + 20, this.y + 72, 10, 24);
        ctx.fillRect(this.x + 34, this.y + 72, 10, 24);
        
        // åŠ (æ”»æ“Šæ™‚é¡¯ç¤º) - èª¿æ•´é¡¯ç¤ºæ™‚é–“ä»¥é…åˆæ–°çš„æ”»æ“Šçª—å£
        if (this.attackCooldown > 0.2) {  // å¾0.3æ”¹ç‚º0.2ï¼Œè®“åŠé¡¯ç¤ºæ›´ä¹…
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(this.x + 48, this.y + 36, 24, 6);
            ctx.fillRect(this.x + 72, this.y + 32, 6, 16);
            // åŠæŸ„
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(this.x + 44, this.y + 36, 8, 6);
        }
        
        ctx.restore();
    }
}

// Bossé¡
// é£›æ©Ÿé¡
class Airplane {
    constructor(game) {
        this.game = game;
        this.x = -100; // å¾ç•«é¢å·¦å´å¤–é–‹å§‹
        // é«˜åº¦å›ºå®šåœ¨ç•«é¢æœ€ä¸Šæ–¹ï¼ˆç•™ä¸€é»é‚Šè·ï¼‰
        this.y = 30; // å›ºå®šåœ¨ä¸Šæ–¹30åƒç´ è™•
        
        this.width = 80;
        this.height = 60;
        this.speed = 100; // é£›è¡Œé€Ÿåº¦ï¼ˆåƒç´ /ç§’ï¼‰
        this.image = new Image();
        this.image.src = 'Assets/Items/airplane.png';
        this.active = true;
        
        // æ–‡å­—è¨­ç½®
        this.text = "ã€Šåƒç´ åœ°ä¸‹åŸç°¡å ±æ¨¡æ¿ 9/5 ä¸Šæ¶ã€‹";
        this.textOffset = 5; // æ–‡å­—ç·Šè²¼é£›æ©Ÿå¾Œé¢
        this.textTrail = []; // æ–‡å­—è»Œè·¡æ•ˆæœ
    }

    update(deltaTime) {
        if (!this.active) return;
        
        // å¾å·¦å‘å³é£›è¡Œ
        this.x += this.speed * deltaTime;
        
        // è¨ˆç®—æ–‡å­—çš„å¯¦éš›å¯¬åº¦ï¼ˆä¼°è¨ˆæ–‡å­—å¯¬åº¦ç´„ç‚º350åƒç´ ï¼‰
        const textWidth = 350;
        
        // ç•¶æ–‡å­—å®Œå…¨é›¢é–‹å³å´ç•«é¢æ™‚ï¼Œæ¨™è¨˜ç‚ºéæ´»å‹•
        // é£›æ©Ÿä½ç½® - æ–‡å­—åç§» - æ–‡å­—å¯¬åº¦ > ç•«é¢å¯¬åº¦
        if (this.x - this.textOffset - textWidth > this.game.canvas.width) {
            this.active = false;
            airplane = null; // æ¸…é™¤å…¨å±€å¼•ç”¨
            airplaneSpawned = false; // å…è¨±å†æ¬¡ç”Ÿæˆ
            
            // è¨˜éŒ„æ–‡å­—æ¶ˆå¤±çš„æ™‚é–“ï¼Œä¸¦è¨­å®šä¸‹æ¬¡å‡ºç¾æ™‚é–“ï¼ˆè‡³å°‘20ç§’å¾Œï¼‰
            const currentTime = Date.now() / 1000;
            const nextDelay = Math.random() * 5 + 20; // 20-25ç§’éš¨æ©Ÿ
            this.game.nextAirplaneTime = currentTime + nextDelay;
            console.log(`é£›æ©Ÿæ–‡å­—å·²å®Œå…¨æ¶ˆå¤±ï¼Œå°‡åœ¨ ${Math.floor(nextDelay)} ç§’å¾Œå†æ¬¡å‡ºç¾`);
        }
    }

    render(ctx) {
        if (!this.active) return;
        
        ctx.save();
        
        // ç¹ªè£½è·Ÿéš¨æ–‡å­—ï¼ˆåœ¨é£›æ©Ÿå¾Œé¢ï¼‰
        const textX = this.x - this.textOffset;
        const textY = this.y + this.height / 2;
        
        // æ–‡å­—è»Œè·¡æ•ˆæœ
        ctx.font = 'bold 14px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        
        // æ–‡å­—ç™¼å…‰é™°å½±
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // æ–‡å­—æ¼¸è®Šæ•ˆæœ
        const textGradient = ctx.createLinearGradient(textX - 300, textY - 10, textX - 300, textY + 10);
        textGradient.addColorStop(0, '#FFD700');
        textGradient.addColorStop(0.5, '#FFA500');
        textGradient.addColorStop(1, '#FF6347');
        
        // ç¹ªè£½æ–‡å­—å¤–æ¡†
        ctx.strokeStyle = '#2C3E50';
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, textX, textY);
        
        // ç¹ªè£½æ–‡å­—ä¸»é«”
        ctx.fillStyle = textGradient;
        ctx.fillText(this.text, textX, textY);
        
        // é‡ç½®é™°å½±
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // å¦‚æœåœ–ç‰‡å·²è¼‰å…¥ï¼Œç¹ªè£½é£›æ©Ÿ
        if (this.image.complete && this.image.naturalHeight !== 0) {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        } else {
            // å‚™ç”¨ï¼šç¹ªè£½ç°¡å–®çš„é£›æ©Ÿå½¢ç‹€
            ctx.fillStyle = '#888';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#666';
            ctx.fillRect(this.x + this.width * 0.7, this.y + this.height * 0.3, this.width * 0.3, this.height * 0.4);
            // æ©Ÿç¿¼
            ctx.fillStyle = '#777';
            ctx.fillRect(this.x + this.width * 0.2, this.y + this.height * 0.4, this.width * 0.5, this.height * 0.2);
        }
        
        ctx.restore();
    }
}

class MimicBoss {
    constructor(x, y, game) {
        this.x = x;
        this.y = y;
        this.width = 128;  // æ”¾å¤§
        this.height = 128; // æ”¾å¤§
        this.game = game;
        
        this.maxHealth = 500;
        this.health = this.maxHealth;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.facing = -1; // é è¨­é¢å‘å·¦
        
        this.phase = 1;
        this.state = 'chest';
        this.attackCooldown = 0;
        
        // å—å‚·åƒµç›´ç³»çµ±
        this.hurtStunTime = 0;  // å—å‚·åƒµç›´æ™‚é–“
        this.maxHurtStun = 0.3;  // æœ€å¤§åƒµç›´æ™‚é–“
        this.comboTaken = 0;  // è¢«é€£æ“Šæ¬¡æ•¸
        this.maxComboBeforeEscape = 7;  // è¢«é€£æ“Š7æ¬¡å¾Œè§¸ç™¼é€ƒè„«
        this.escaping = false;  // æ˜¯å¦æ­£åœ¨é€ƒè„«
        
        // æ™ºèƒ½AIç³»çµ±
        this.aiState = 'analyze'; // analyze, approach, attack, retreat, jump, escape_corner, stalk, rush, defensive, wait
        this.aiTimer = 0;
        this.dodgeChance = 0.3;
        this.jumpAttackChance = 0.2;
        this.stuckTimer = 0;  // æª¢æ¸¬æ˜¯å¦å¡ä½
        this.lastX = x;  // è¨˜éŒ„ä¸Šä¸€æ¬¡ä½ç½®
        this.cornerEscapeTimer = 0;  // è§’è½é€ƒè„«è¨ˆæ™‚å™¨
        
        // æ™ºèƒ½æ±ºç­–åƒæ•¸
        this.aggressiveness = 0.5; // æ”»æ“Šæ€§ 0-1
        this.caution = 0.5; // è¬¹æ…åº¦ 0-1
        this.lastPlayerHealth = 100; // è¿½è¹¤ç©å®¶è¡€é‡è®ŠåŒ–
        this.decisionCooldown = 0; // æ±ºç­–å†·å»
        this.currentTactic = null; // ç•¶å‰æˆ°è¡“
        this.tacticTimer = 0; // æˆ°è¡“è¨ˆæ™‚å™¨
        
        // å‹•ç•«ç³»çµ±
        this.animations = {
            attack: [],
            closing: []  // é–‰åˆå‹•ç•«
        };
        this.currentAnimation = null;
        this.animationFrame = 0;
        this.animationTimer = 0;
        this.animationSpeed = 0.1; // æ¯å¹€0.1ç§’
        this.isClosing = false; // æ˜¯å¦æ­£åœ¨æ’­æ”¾é–‰åˆå‹•ç•«
        this.isTransforming = false; // æ˜¯å¦æ­£åœ¨è®Šèº«
        
        // è¼‰å…¥æ”»æ“Šå‹•ç•«
        this.loadAnimations();
    }
    
    loadAnimations() {
        // è¼‰å…¥å¾…æ©Ÿå‹•ç•«ï¼ˆå½è£ç‹€æ…‹ï¼‰
        this.animations.idle = [];
        const idleImg = new Image();
        idleImg.src = 'Assets/Boss/MimicBoss/Sprites/Idle/Idle_Disguise.png';
        idleImg.onload = () => {
            console.log('Loaded Boss idle disguise animation:', idleImg.width, 'x', idleImg.height);
        };
        idleImg.onerror = () => {
            console.error('Failed to load Boss idle disguise animation');
        };
        this.animations.idle.push(idleImg);
        
        // è¼‰å…¥è¦ºé†’ç‹€æ…‹å¾…æ©Ÿå‹•ç•«ï¼ˆHP > 50%ï¼‰
        this.animations.awakenedIdle = [];
        for (let i = 1; i <= 2; i++) {
            const awakenedIdleImg = new Image();
            awakenedIdleImg.src = `Assets/Boss/MimicBoss/Sprites/Awakened/Idle/awakened_idle_frame${i}.png`;
            awakenedIdleImg.onload = () => {
                console.log(`Loaded awakened idle frame ${i}`);
            };
            awakenedIdleImg.onerror = () => {
                console.error(`Failed to load awakened idle frame ${i}`);
            };
            this.animations.awakenedIdle.push(awakenedIdleImg);
        }
        
        // è¼‰å…¥è¦ºé†’ç‹€æ…‹å—å‚·å‹•ç•«
        this.animations.awakenedHurt = [];
        const awakenedHurtImg = new Image();
        awakenedHurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Awakened/Hurt/awakened_hurt_frame1.png';
        awakenedHurtImg.onload = () => {
            console.log('Loaded awakened hurt animation');
        };
        awakenedHurtImg.onerror = () => {
            console.error('Failed to load awakened hurt animation');
        };
        this.animations.awakenedHurt.push(awakenedHurtImg);
        
        // è¼‰å…¥è¦ºé†’ç‹€æ…‹ç§»å‹•å‹•ç•«ï¼ˆ5å¹€ï¼‰
        this.animations.awakenedMovement = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Awakened/Movement/awakened_move_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded awakened movement frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load awakened movement frame ${i}`);
            };
            this.animations.awakenedMovement.push(img);
        }
        
        // è¼‰å…¥ç¬¬ä¸‰éšæ®µå¾…æ©Ÿå‹•ç•«ï¼ˆè®Šèº«å¾Œä½¿ç”¨ï¼‰- 6å¹€å‹•ç•«
        this.animations.idlePhase3 = [];
        for (let i = 1; i <= 6; i++) {
            const idlePhase3Img = new Image();
            idlePhase3Img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/Idle/phase3_idle_frame${i}.png`;
            idlePhase3Img.onload = () => {
                console.log(`Loaded Phase3 idle frame ${i}`);
            };
            idlePhase3Img.onerror = () => {
                console.error(`Failed to load Phase3 idle frame ${i}`);
                // å¦‚æœè¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨å‚™ç”¨åœ–ç‰‡
                if (i === 1) {
                    idlePhase3Img.src = 'Assets/Boss/MimicBoss/Sprites/Idle/Idle_Disguise.png';
                }
            };
            this.animations.idlePhase3.push(idlePhase3Img);
        }
        
        // è¼‰å…¥7å¹€æ”»æ“Šå‹•ç•« (å¾æ–°çš„çµ„ç¹”è·¯å¾‘)
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            this.animations.attack.push(img);
        }
        
        // è¼‰å…¥ç¬¬ä¸‰éšæ®µæ”»æ“Šå‹•ç•«
        this.animations.attackPhase3 = [];
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_phase3_frame${i}.png`;
            img.onerror = () => {
                // å¦‚æœæ²’æœ‰Phase3å°ˆç”¨åœ–ç‰‡ï¼Œä½¿ç”¨åŸæœ¬çš„
                img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            };
            this.animations.attackPhase3.push(img);
        }
        
        // æœ€å¾Œ3å¹€ä½œç‚ºé–‰åˆå‹•ç•« (5, 6, 7æ˜¯ç®±å­é–‰åˆçš„å‹•ä½œ)
        for (let i = 5; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            this.animations.closing.push(img);
        }
        
        // è¼‰å…¥ç¬¬ä¸‰éšæ®µç§»å‹•å‹•ç•« (5å¹€)
        this.animations.movementPhase3 = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/Movement/phase3_move_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded phase 3 movement frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load phase 3 movement frame ${i}`);
            };
            this.animations.movementPhase3.push(img);
        }
        
        // è¼‰å…¥ç¬¬ä¸‰éšæ®µç«çƒé€£å°„å‹•ç•« (7å¹€)
        this.animations.fireballBarrage = [];
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/FireballBarrage/fireball_barrage_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded fireball barrage frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load fireball barrage frame ${i}`);
            };
            this.animations.fireballBarrage.push(img);
        }
        
        // è¼‰å…¥å’¬æ“Šå‹•ç•« (4å¹€)
        this.animations.bite = [];
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Bite/boss_bite_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded boss bite frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load boss bite frame ${i}`);
            };
            this.animations.bite.push(img);
        }
        
        // è¼‰å…¥è®Šèº«å‹•ç•« (Phase2 -> Phase3 è®Šèº«)
        this.animations.transform = [];
        for (let i = 1; i <= 9; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Transform/micmic_transform_frame_${i}.png`;
            img.onload = () => {
                console.log(`Loaded Boss transform frame ${i}: ${img.src}, size: ${img.width}x${img.height}`);
            };
            img.onerror = () => {
                console.error(`Failed to load Boss transform frame ${i}: ${img.src}`);
                // å˜—è©¦å‚™ç”¨è·¯å¾‘
                img.src = `Assets/Boss/MimicBoss/Sprites/Transform/mimic_transform_frame_${i}.png`;
                img.onerror = () => {
                    console.error(`Also failed backup path for frame ${i}`);
                };
            };
            this.animations.transform.push(img);
        }
        
        // è¼‰å…¥æ­»äº¡å‹•ç•« (5å¹€)
        this.animations.death = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Death/death_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded death animation frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load death animation frame ${i}`);
            };
            this.animations.death.push(img);
        }
        
        // è¼‰å…¥ç¬¬äºŒéšæ®µå—å‚·å‹•ç•«
        this.animations.phase2Hurt = [];
        const phase2HurtImg = new Image();
        phase2HurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Phase2/Hurt/phase2_hurt_frame1.png';
        phase2HurtImg.onload = () => {
            console.log('Loaded Phase 2 hurt animation');
        };
        phase2HurtImg.onerror = () => {
            console.error('Failed to load Phase 2 hurt animation');
        };
        this.animations.phase2Hurt.push(phase2HurtImg);
        
        // è¼‰å…¥ç¬¬ä¸‰éšæ®µå—å‚·å‹•ç•«
        this.animations.phase3Hurt = [];
        const phase3HurtImg = new Image();
        phase3HurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Phase3/Hurt/phase3_hurt_frame1.png';
        phase3HurtImg.onload = () => {
            console.log('Loaded Phase 3 hurt animation');
        };
        phase3HurtImg.onerror = () => {
            console.error('Failed to load Phase 3 hurt animation');
        };
        this.animations.phase3Hurt.push(phase3HurtImg);
        
        // åˆå§‹åŒ–ç‰¹æ®Šå‹•ç•«æ¨™è¨˜ï¼ˆé€™äº›å‹•ç•«ä½¿ç”¨ç¨‹å¼ç¹ªè£½ï¼‰
        this.animations.hit = 'programmatic';
        // death ç¾åœ¨æœ‰å¯¦éš›å‹•ç•«äº†ï¼Œä¸å†æ˜¯programmatic
        // movement ç¬¬ä¸€éšæ®µç¾åœ¨ä¹Ÿæœ‰å¯¦éš›å‹•ç•«äº†
        // movementPhase3 æœ‰å¯¦éš›çš„åœ–ç‰‡å‹•ç•«ï¼Œä¸éœ€è¦æ¨™è¨˜ç‚ºprogrammatic
        
        console.log('Boss animations loaded - Idle:', this.animations.idle.length, 'frames, Attack:', this.animations.attack.length, 'frames, Closing:', this.animations.closing.length, 'frames, Transform:', this.animations.transform.length, 'frames');
    }
    
    playAnimation(animationName) {
        // å°æ–¼ç¨‹å¼åŒ–å‹•ç•«ï¼Œåªè¨­å®šç‹€æ…‹ï¼ˆmovementç¾åœ¨å¤§éƒ¨åˆ†éƒ½æœ‰å¯¦éš›å‹•ç•«ï¼‰
        if (animationName === 'movement' && this.state !== 'monster') {
            // åªæœ‰æœªè¦ºé†’æ™‚æ‰ä½¿ç”¨ç¨‹å¼åŒ–æ•ˆæœ
            this.currentAnimation = animationName;
            this.animationTimer = 0;
            return;
        }
        
        // è™•ç†å—å‚·å‹•ç•«
        if (animationName === 'hit') {
            // ç¬¬ä¸‰éšæ®µä½¿ç”¨ç¬¬ä¸‰éšæ®µå—å‚·å‹•ç•«
            if (this.phase === 3 && this.animations.phase3Hurt && this.animations.phase3Hurt.length > 0) {
                this.currentAnimation = 'phase3Hurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // å—å‚·å‹•ç•«é€Ÿåº¦
                return;
            }
            // ç¬¬äºŒéšæ®µï¼ˆè®Šèº«ä¸­ï¼‰ä½¿ç”¨ç¬¬äºŒéšæ®µå—å‚·å‹•ç•«
            else if (this.phase === 2 && this.animations.phase2Hurt && this.animations.phase2Hurt.length > 0) {
                this.currentAnimation = 'phase2Hurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // å—å‚·å‹•ç•«é€Ÿåº¦
                return;
            }
            // è¦ºé†’ç‹€æ…‹ï¼ˆHP > 50%ï¼‰ä½¿ç”¨è¦ºé†’å—å‚·å‹•ç•«
            else if (this.phase === 1 && this.state === 'monster' && this.animations.awakenedHurt && this.animations.awakenedHurt.length > 0) {
                this.currentAnimation = 'awakenedHurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // å—å‚·å‹•ç•«é€Ÿåº¦
                return;
            } else {
                // å‚™ç”¨ï¼šä½¿ç”¨ç¨‹å¼åŒ–å—å‚·å‹•ç•«
                this.currentAnimation = animationName;
                this.animationTimer = 0;
                return;
            }
        }
        
        // ç¬¬ä¸‰éšæ®µä½¿ç”¨ä¸åŒçš„å‹•ç•«
        if (this.phase === 3) {
            if (animationName === 'attack' && this.animations.attackPhase3) {
                animationName = 'attackPhase3';
            }
            // ç«çƒé€£å°„å‹•ç•«ç›´æ¥ä½¿ç”¨
            if (animationName === 'fireballBarrage' && this.animations.fireballBarrage) {
                // ç«çƒé€£å°„æœ‰å°ˆå±¬å‹•ç•«
            }
        }
        
        if (this.animations[animationName] && this.animations[animationName].length > 0) {
            this.currentAnimation = animationName;
            this.animationFrame = 0;
            this.animationTimer = 0;
            
            // é‡å°ä¸åŒå‹•ç•«è¨­å®šä¸åŒé€Ÿåº¦
            if (animationName === 'transform') {
                this.animationSpeed = 0.12; // è®Šèº«å‹•ç•«é€Ÿåº¦
                // è¨­å®šè‡ªå®šç¾©å¹€åºåˆ—ï¼šæ¯å¹€é‡è¤‡3æ¬¡ 1-1-1-2-2-2-3-3-3...
                this.transformFrameSequence = [];
                for (let i = 0; i < 9; i++) {
                    // æ¯å¹€é‡è¤‡3æ¬¡
                    this.transformFrameSequence.push(i, i, i);
                }
                this.transformFrameIndex = 0;
                // è¨­å®šåˆå§‹å¹€
                this.animationFrame = this.transformFrameSequence[0];
                console.log('Transform animation started with sequence:', this.transformFrameSequence, 'First frame:', this.animationFrame);
            } else if (animationName === 'attack' || animationName === 'attackPhase3') {
                this.animationSpeed = 0.08; // æ”»æ“Šå‹•ç•«è¼ƒå¿«
            } else if (animationName === 'awakenedMovement') {
                this.animationSpeed = 0.1; // è¦ºé†’ç§»å‹•å‹•ç•«
            } else if (animationName === 'movementPhase3') {
                this.animationSpeed = 0.08; // ç¬¬ä¸‰éšæ®µç§»å‹•å‹•ç•«è¼ƒå¿«
            } else if (animationName === 'fireballBarrage') {
                this.animationSpeed = 0.1; // ç«çƒé€£å°„å‹•ç•«
            } else if (animationName === 'bite') {
                this.animationSpeed = 0.12; // å’¬æ“Šå‹•ç•«
            } else if (animationName === 'death') {
                this.animationSpeed = 0.15; // æ­»äº¡å‹•ç•«ç¨æ…¢
            } else {
                this.animationSpeed = 0.1; // é è¨­é€Ÿåº¦
            }
        }
    }
    
    updateAnimation(deltaTime) {
        if (!this.currentAnimation) return;
        
        // ç´¯åŠ å‹•ç•«è¨ˆæ™‚å™¨
        this.animationTimer += deltaTime;
        
        // è™•ç†ç¨‹å¼åŒ–å‹•ç•«ï¼ˆä½†ä¸åŒ…æ‹¬movementPhase3å’Œdeathï¼‰
        if (this.currentAnimation === 'hit' || 
            (this.currentAnimation === 'movement' && this.phase !== 3)) {
            // é€™äº›å‹•ç•«çš„çµæŸæ¢ä»¶åœ¨ render å‡½æ•¸ä¸­è™•ç†
            return;
        }
        
        // è™•ç†è¦ºé†’å—å‚·å‹•ç•«
        if (this.currentAnimation === 'awakenedHurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // å—å‚·å‹•ç•«åªæ’­æ”¾ä¸€æ¬¡
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // è™•ç†ç¬¬äºŒéšæ®µå—å‚·å‹•ç•«
        if (this.currentAnimation === 'phase2Hurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // å—å‚·å‹•ç•«åªæ’­æ”¾ä¸€æ¬¡
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // è™•ç†ç¬¬ä¸‰éšæ®µå—å‚·å‹•ç•«
        if (this.currentAnimation === 'phase3Hurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // å—å‚·å‹•ç•«åªæ’­æ”¾ä¸€æ¬¡
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // è™•ç†è¦ºé†’ç§»å‹•å‹•ç•«
        if (this.currentAnimation === 'awakenedMovement') {
            // æª¢æŸ¥æ˜¯å¦é‚„åœ¨ç§»å‹•ï¼Œå¦‚æœåœæ­¢äº†å°±åˆ‡æ›åˆ°å¾…æ©Ÿå‹•ç•«
            if (Math.abs(this.vx) < 10) {
                // åˆ‡æ›åˆ°è¦ºé†’å¾…æ©Ÿå‹•ç•«
                if (this.animations.awakenedIdle && this.animations.awakenedIdle.length > 0) {
                    this.playAnimation('awakenedIdle');
                } else {
                    this.currentAnimation = null;
                    this.animationFrame = 0;
                    this.animationTimer = 0;
                }
            }
            // ä¸è¦ç«‹å³è¿”å›ï¼Œè®“å‹•ç•«å¹€å¯ä»¥æ›´æ–°
        }
        
        // è™•ç†ç¬¬ä¸‰éšæ®µç§»å‹•å‹•ç•«
        if (this.currentAnimation === 'movementPhase3') {
            // æª¢æŸ¥æ˜¯å¦é‚„åœ¨ç§»å‹•ï¼Œå¦‚æœåœæ­¢äº†å°±åˆ‡æ›åˆ°å¾…æ©Ÿå‹•ç•«
            if (Math.abs(this.vx) < 10) {
                // åˆ‡æ›åˆ°ç¬¬ä¸‰éšæ®µå¾…æ©Ÿå‹•ç•«
                if (this.phase === 3 && this.animations.idlePhase3 && this.animations.idlePhase3.length > 0) {
                    this.playAnimation('idlePhase3');
                } else {
                    this.currentAnimation = null;
                    this.animationFrame = 0;
                    this.animationTimer = 0;
                }
            }
            // ä¸è¦ç«‹å³è¿”å›ï¼Œè®“å‹•ç•«å¹€å¯ä»¥æ›´æ–°
        }
        
        // è™•ç†å¹€å‹•ç•«
        if (this.animations[this.currentAnimation]) {
            if (this.animationTimer >= this.animationSpeed) {
                this.animationTimer = 0;
                
                // ç‰¹æ®Šè™•ç†è®Šèº«å‹•ç•«çš„å¹€åºåˆ—
                if (this.currentAnimation === 'transform' && this.transformFrameSequence) {
                    this.transformFrameIndex++;
                    if (this.transformFrameIndex >= this.transformFrameSequence.length) {
                        // è®Šèº«å‹•ç•«æ’­æ”¾å®Œç•¢
                        this.currentAnimation = null;
                        this.animationFrame = 0;
                        this.transformFrameIndex = 0;
                        this.transformFrameSequence = null;
                        console.log('Transform animation completed!');
                    } else {
                        // ä½¿ç”¨è‡ªå®šç¾©å¹€åºåˆ—
                        this.animationFrame = this.transformFrameSequence[this.transformFrameIndex];
                        console.log(`Transform frame: ${this.animationFrame + 1} (sequence index: ${this.transformFrameIndex})`);
                    }
                } else {
                    // ä¸€èˆ¬å‹•ç•«çš„è™•ç†
                    this.animationFrame++;
                    
                    // å‹•ç•«å¾ªç’°æˆ–çµæŸ
                    if (this.animationFrame >= this.animations[this.currentAnimation].length) {
                        if (this.currentAnimation === 'attack' || this.currentAnimation === 'attackPhase3') {
                            // æ”»æ“Šå‹•ç•«æ’­æ”¾å®Œç•¢ï¼Œé–‹å§‹é–‰åˆå‹•ç•«
                            this.playAnimation('closing');
                            this.isClosing = true;
                        } else if (this.currentAnimation === 'closing') {
                            // é–‰åˆå‹•ç•«æ’­æ”¾å®Œç•¢
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                            this.isClosing = false;
                        } else if (this.currentAnimation === 'awakenedMovement' || this.currentAnimation === 'movementPhase3') {
                            // ç§»å‹•å‹•ç•«å¾ªç’°æ’­æ”¾
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'idlePhase3' || this.currentAnimation === 'awakenedIdle') {
                            // å¾…æ©Ÿå‹•ç•«å¾ªç’°æ’­æ”¾
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'death') {
                            // æ­»äº¡å‹•ç•«æ’­æ”¾å®Œç•¢å¾Œåœåœ¨æœ€å¾Œä¸€å¹€
                            this.animationFrame = this.animations.death.length - 1;
                            // å¯ä»¥è§¸ç™¼éŠæˆ²çµæŸ
                            if (this.onDeathComplete) {
                                this.onDeathComplete();
                            }
                        } else if (this.currentAnimation === 'fireballBarrage') {
                            // ç«çƒé€£å°„å‹•ç•«æ’­æ”¾å®Œç•¢ï¼Œå›åˆ°nullè®“AIæ±ºå®šä¸‹ä¸€æ­¥
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'bite') {
                            // å’¬æ“Šå‹•ç•«æ’­æ”¾å®Œç•¢ï¼Œå›åˆ°null
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                        }
                    }
                }
            }
        }
    }
    
    update(deltaTime, game) {
        // å®‰å…¨æª¢æŸ¥ deltaTime
        if (!deltaTime || isNaN(deltaTime)) {
            deltaTime = 0.016; // é è¨­ 60fps
        }
        
        // æ›´æ–°å‹•ç•«
        this.updateAnimation(deltaTime);
        
        // å¦‚æœæ­£åœ¨æ­»äº¡ï¼Œåœæ­¢æ‰€æœ‰å…¶ä»–è¡Œç‚º
        if (this.state === 'dying' || this.currentAnimation === 'death') {
            this.vx = 0;
            // ä¿æŒé‡åŠ›ä½†ä¸å…è¨±å…¶ä»–ç§»å‹•
            this.vy += 1200 * deltaTime;
            this.vy = Math.min(this.vy, 800);
            this.y += this.vy * deltaTime;
            
            // åœ°é¢
            if (this.y + this.height >= game.height - 60) {
                this.y = game.height - 60 - this.height;
                this.vy = 0;
                this.grounded = true;
            }
            return; // ä¸åŸ·è¡Œå…¶ä»–æ›´æ–°
        }
        
        // å…¥å ´å‹•ç•«
        if (this.targetX !== undefined) {
            const dx = this.targetX - this.x;
            if (Math.abs(dx) > 5) {
                this.x += dx * 0.1;
            } else {
                this.x = this.targetX;
                delete this.targetX;
            }
        }
        
        // ç‰©ç†
        this.vy += 1200 * deltaTime;
        this.vy = Math.min(this.vy, 800);
        
        if (!this.targetX) {
            this.x += this.vx * deltaTime;
        }
        this.y += this.vy * deltaTime;
        
        // åœ°é¢
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
        
        // é‚Šç•Œ
        this.x = Math.max(0, Math.min(this.x, game.width - this.width));
        
        // æ™ºèƒ½AIç³»çµ± (è®Šèº«æœŸé–“åœæ­¢æ‰€æœ‰AIè¡Œç‚º)
        if (this.state === 'monster' && player && !this.isTransforming) {
            const dx = player.x + player.width/2 - (this.x + this.width/2);
            const dy = player.y - this.y;
            const distance = Math.abs(dx);
            const realDistance = Math.sqrt(dx * dx + dy * dy);
            
            // åˆ†æéŠæˆ²ç‹€æ…‹ä¸¦æ›´æ–°æˆ°è¡“
            this.analyzeGameState(player, realDistance, game);
            
            // æ›´æ–°æ±ºç­–å†·å»
            if (this.decisionCooldown > 0) {
                this.decisionCooldown -= deltaTime;
            }
            
            // æª¢æ¸¬æ˜¯å¦å¡ä½
            if (Math.abs(this.x - this.lastX) < 5) {
                this.stuckTimer += deltaTime;
                // å¦‚æœåœæ­¢ç§»å‹•ä¸”æ²’æœ‰åœ¨åŸ·è¡Œå…¶ä»–å‹•ç•«ï¼Œæ’­æ”¾å¾…æ©Ÿå‹•ç•«
                if (Math.abs(this.vx) < 10 && !this.currentAnimation) {
                    if (this.phase === 3 && this.animations.idlePhase3 && this.animations.idlePhase3.length > 0) {
                        this.playAnimation('idlePhase3');
                    } else if (this.state === 'monster' && this.health > this.maxHealth * 0.5 && 
                               this.animations.awakenedIdle && this.animations.awakenedIdle.length > 0) {
                        this.playAnimation('awakenedIdle');
                    }
                }
            } else {
                this.stuckTimer = 0;
                // å¦‚æœæ­£åœ¨ç§»å‹•ï¼Œæ’­æ”¾ç§»å‹•å‹•ç•«
                if (Math.abs(this.vx) > 10) {
                    // æª¢æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ›åˆ°ç§»å‹•å‹•ç•«
                    if (this.phase === 3) {
                        // ç¬¬ä¸‰éšæ®µç”¨movementPhase3å‹•ç•«
                        if (this.currentAnimation !== 'movementPhase3' && 
                            this.currentAnimation !== 'attack' && 
                            this.currentAnimation !== 'attackPhase3' &&
                            this.currentAnimation !== 'fireballBarrage' &&
                            this.currentAnimation !== 'transform') {
                            this.playAnimation('movementPhase3');
                        }
                    } else if (this.phase === 1 && this.state === 'monster') {
                        // ç¬¬ä¸€éšæ®µè¦ºé†’ç‹€æ…‹ç”¨awakenedMovementå‹•ç•«
                        if (this.currentAnimation !== 'awakenedMovement' && 
                            this.currentAnimation !== 'attack' && 
                            this.currentAnimation !== 'closing' && 
                            this.currentAnimation !== 'transform') {
                            this.playAnimation('awakenedMovement');
                        }
                    } else if (!this.currentAnimation || 
                               (this.currentAnimation !== 'attack' && 
                                this.currentAnimation !== 'closing' && 
                                this.currentAnimation !== 'transform')) {
                        // å…¶ä»–æƒ…æ³ï¼ˆå¦‚æœªè¦ºé†’ï¼‰æš«æ™‚ç”¨movement
                        this.playAnimation('movement');
                    }
                }
            }
            this.lastX = this.x;
            
            // æª¢æ¸¬æ˜¯å¦åœ¨è§’è½
            const isInCorner = this.isInCorner(game);
            const isStuck = this.stuckTimer > 1.5; // 1.5ç§’æ²’ç§»å‹•å°±ç®—å¡ä½
            
            // å„ªå…ˆè™•ç†å¡ä½æˆ–è§’è½ç‹€æ³
            if ((isInCorner || isStuck) && this.aiState !== 'escape_corner') {
                this.aiState = 'escape_corner';
                this.cornerEscapeTimer = 2; // 2ç§’é€ƒè„«æ™‚é–“
                this.stuckTimer = 0;
            }
            
            // æ›´æ–°é¢å‘ï¼ˆä½†åœ¨é€ƒè„«è§’è½æ™‚å¯èƒ½éœ€è¦åå‘ï¼‰
            if (this.aiState !== 'escape_corner') {
                this.facing = dx > 0 ? 1 : -1;  // ç©å®¶åœ¨å³é‚Šæ™‚é¢å‘å³
            }
            
            // AIç‹€æ…‹æ©Ÿ
            this.aiTimer -= deltaTime;
            this.cornerEscapeTimer -= deltaTime;
            
            switch(this.aiState) {
                case 'escape_corner':
                    // é€ƒè„«è§’è½é‚è¼¯
                    this.escapeCorner(game, deltaTime);
                    break;
                
                case 'rush':
                    // å¿«é€Ÿè¿½æ“Šï¼ˆç”¨æ–¼çµ‚çµä½è¡€é‡ç©å®¶ï¼‰
                    const rushSpeed = 280 * this.aggressiveness;
                    this.vx = dx > 0 ? rushSpeed : -rushSpeed;
                    
                    // ç©æ¥µè·³èºè¿½æ“Š
                    if (Math.abs(dy) > 30 && this.grounded && Math.random() < 0.1) {
                        this.vy = -550;
                        this.grounded = false;
                    }
                    
                    if (distance < 150) {
                        this.aiState = 'attack';
                        this.aiTimer = 0.3;
                    }
                    break;
                
                case 'stalk':
                    // è¬¹æ…è·Ÿéš¨ï¼ˆä¿æŒä¸­è·é›¢ï¼‰
                    const idealDistance = 250;
                    if (distance > idealDistance + 50) {
                        this.vx = dx > 0 ? 120 : -120;
                    } else if (distance < idealDistance - 50) {
                        this.vx = dx > 0 ? -80 : 80;
                    } else {
                        this.vx *= 0.7;
                    }
                    
                    // ç­‰å¾…æ™‚æ©Ÿ
                    if (player.buffType === 'cursed' || player.health < player.maxHealth * 0.3) {
                        this.aiState = 'rush';
                    }
                    break;
                
                case 'defensive':
                    // é˜²ç¦¦æ¨¡å¼ï¼ˆèº²é¿ç©å®¶ï¼‰
                    if (distance < 200) {
                        this.vx = dx > 0 ? -150 : 150;
                        
                        // è·³èºèº²é¿
                        if (this.grounded && Math.random() < 0.05) {
                            this.vy = -400;
                            this.grounded = false;
                        }
                    } else {
                        this.vx *= 0.8;
                    }
                    
                    // ç­‰å¾…buffçµæŸ
                    if (!player.buffType || player.buffType === 'cursed') {
                        this.aiState = 'approach';
                    }
                    break;
                    
                case 'approach':
                    // æ¥è¿‘ç©å®¶ï¼ˆæ ¹æ“šéšæ®µèª¿æ•´é€Ÿåº¦ï¼‰
                    if (distance > 200) {
                        // åŸºç¤é€Ÿåº¦æ ¹æ“šéšæ®µèª¿æ•´
                        let baseSpeed = 150;
                        if (this.phase === 3) {
                            baseSpeed = 220; // ç¬¬ä¸‰éšæ®µæ›´å¿«
                        } else if (this.state === 'monster') {
                            baseSpeed = 180; // è¦ºé†’å¾Œç¨å¿«
                        }
                        this.vx = dx > 0 ? baseSpeed : -baseSpeed;
                        
                        // æ™ºèƒ½è·³èºè¿½æ“Š - å¢åŠ æ¢ä»¶é¿å…å¡ç‰†
                        const shouldJump = Math.abs(dy) > 50 && this.grounded && Math.random() < 0.03;
                        const notNearWall = this.x > 50 && this.x < game.width - 50 - this.width;
                        
                        if (shouldJump && notNearWall) {
                            this.vy = -400;
                            this.grounded = false;
                        }
                        
                        // å¦‚æœé•·æ™‚é–“ç„¡æ³•æ¥è¿‘ï¼Œæ”¹è®Šç­–ç•¥
                        if (this.aiTimer < -5) {
                            this.aiState = 'jump';
                            this.aiTimer = 1;
                        }
                    } else {
                        this.aiState = 'attack';
                        this.aiTimer = 0.5;
                    }
                    break;
                    
                case 'attack':
                    this.vx *= 0.8;
                    
                    if (this.attackCooldown <= 0) {
                        // æ ¹æ“šéšæ®µé¸æ“‡æ”»æ“Šæ¨¡å¼
                        if (this.phase === 3) {
                            // ç¬¬ä¸‰éšæ®µ - æœ€æ¿€é€²
                            if (Math.random() < this.jumpAttackChance) {
                                // è·³èºæ”»æ“Š
                                if (this.grounded) {
                                    this.vy = -500;
                                    this.grounded = false;
                                }
                            }
                            this.attack(game);
                            this.attackCooldown = 1.2;
                        } else {
                            // ç¬¬ä¸€éšæ®µ - æ­£å¸¸æ”»æ“Š
                            this.attack(game);
                            this.attackCooldown = 2;
                        }
                        
                        // æ”»æ“Šå¾Œæ±ºå®šä¸‹ä¸€æ­¥
                        if (distance < 100) {
                            this.aiState = 'retreat';
                            this.aiTimer = 1;
                        } else {
                            this.aiState = 'approach';
                        }
                    }
                    break;
                    
                case 'retreat':
                    // å¾Œé€€ä¿æŒè·é›¢ - æ™ºèƒ½å¾Œé€€é¿å…å¡è§’è½
                    const retreatDirection = this.getRetreatDirection(dx, game);
                    this.vx = retreatDirection * 120;
                    
                    if (this.aiTimer <= 0 || distance > 300) {
                        this.aiState = 'approach';
                        this.aiTimer = 2;
                    }
                    
                    // å¾Œé€€æ™‚å¯èƒ½é–ƒé¿ - ä½†é¿å…è·³åˆ°è§’è½
                    const canJumpSafely = this.x > 100 && this.x < game.width - 100 - this.width;
                    if (Math.random() < this.dodgeChance * 0.01 && this.grounded && canJumpSafely) {
                        this.vy = -350;
                        this.grounded = false;
                    }
                    break;
                    
                case 'jump':
                    // è·³èºç‹€æ…‹ - ä¸»å‹•è·³èºåˆ°æ›´å¥½ä½ç½®
                    if (this.grounded) {
                        // è·³èºåˆ°ç©å®¶é™„è¿‘
                        const targetX = player.x + (Math.random() - 0.5) * 200;
                        const clampedTargetX = Math.max(100, Math.min(targetX, game.width - 100));
                        
                        this.vx = (clampedTargetX - this.x) > 0 ? 200 : -200;
                        this.vy = -500;
                        this.grounded = false;
                        this.aiState = 'approach';
                        this.aiTimer = 1;
                    }
                    break;
            }
            
            // ç¬¬ä¸‰éšæ®µå¢å¼·ï¼ˆè®Šèº«å¾Œï¼‰
            if (this.phase === 3) {
                this.vx *= 1.5; // ç§»å‹•é€Ÿåº¦æå‡50%
                this.dodgeChance = 0.5; // é–ƒé¿æ©Ÿç‡æå‡
            } else if (this.phase === 1 && this.state === 'monster' && this.health > this.maxHealth * 0.5) {
                // è¦ºé†’éšæ®µï¼ˆHP > 50%ï¼‰ä¹Ÿæœ‰ä¸€å®šå¢å¼·
                this.vx *= 1.2; // ç§»å‹•é€Ÿåº¦æå‡20%
                this.dodgeChance = 0.35; // é–ƒé¿æ©Ÿç‡ç•¥å¾®æå‡
            }
        }
        
        if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
        }
        
        // æ›´æ–°å—å‚·åƒµç›´
        if (this.hurtStunTime > 0) {
            this.hurtStunTime -= deltaTime;
            // åƒµç›´æœŸé–“ç„¡æ³•å‹•ä½œ
            return;
        }
        
        // å¾å—å‚·ç‹€æ…‹æ¢å¾©
        if (this.aiState === 'hurt' && this.hurtStunTime <= 0) {
            this.aiState = 'approach';  // æ¢å¾©å¾Œç«‹å³åæ“Š
            this.aiTimer = 0.2;
            // å¦‚æœæ²’æœ‰è¢«é€£æ“Šï¼Œé‡ç½®è¨ˆæ•¸å™¨
            if (this.comboTaken < 3) {
                this.comboTaken = 0;
            }
        }
    }
    
    // æª¢æ¸¬æ˜¯å¦åœ¨è§’è½
    isInCorner(game) {
        const margin = 80;
        const nearLeftWall = this.x < margin;
        const nearRightWall = this.x > game.width - this.width - margin;
        const nearGround = this.y > game.height - 120;
        
        return (nearLeftWall || nearRightWall) && nearGround;
    }
    
    // ç²å–æ™ºèƒ½å¾Œé€€æ–¹å‘
    getRetreatDirection(dx, game) {
        const margin = 80;
        const nearLeftWall = this.x < margin;
        const nearRightWall = this.x > game.width - this.width - margin;
        
        if (nearLeftWall) {
            return 1; // å‘å³ç§»å‹•é›¢é–‹å·¦ç‰†
        } else if (nearRightWall) {
            return -1; // å‘å·¦ç§»å‹•é›¢é–‹å³ç‰†
        } else {
            // æ­£å¸¸å¾Œé€€é‚è¼¯
            return dx > 0 ? -1 : 1;
        }
    }
    
    // é€ƒè„«è§’è½çš„é‚è¼¯
    escapeCorner(game, deltaTime) {
        if (this.cornerEscapeTimer <= 0) {
            this.aiState = 'approach';
            this.aiTimer = 1;
            return;
        }
        
        const centerX = game.width / 2;
        const margin = 100;
        
        // è¨ˆç®—åˆ°ä¸­å¿ƒçš„æ–¹å‘
        let targetX = centerX;
        
        // å¦‚æœç©å®¶ä¸åœ¨ä¸­å¿ƒé™„è¿‘ï¼Œé¸æ“‡ä¸€å€‹å®‰å…¨ä½ç½®
        if (player) {
            if (Math.abs(player.x - centerX) < 150) {
                // ç©å®¶åœ¨ä¸­å¿ƒï¼Œé¸æ“‡é›¢ç©å®¶è¼ƒé çš„å®‰å…¨ä½ç½®
                targetX = player.x > centerX ? margin : game.width - margin - this.width;
            }
        }
        
        const directionToTarget = targetX - this.x;
        
        // ç§»å‹•åˆ°ç›®æ¨™ä½ç½®
        if (Math.abs(directionToTarget) > 20) {
            this.vx = directionToTarget > 0 ? 200 : -200;
            this.facing = directionToTarget > 0 ? 1 : -1;
        } else {
            this.vx = 0;
        }
        
        // è·³èºè„«é›¢è§’è½
        if (this.grounded && Math.random() < 0.05) {
            this.vy = -450;
            this.grounded = false;
        }
        
        // å¦‚æœæˆåŠŸé€ƒè„«è§’è½
        if (!this.isInCorner(game)) {
            this.aiState = 'approach';
            this.aiTimer = 1;
            this.cornerEscapeTimer = 0;
        }
    }
    
    // æ™ºèƒ½AIåˆ†æç³»çµ±
    analyzeGameState(player, distance, game) {
        const playerHealthPercent = player.health / player.maxHealth;
        const bossHealthPercent = this.health / this.maxHealth;
        
        // æª¢æ¸¬ç©å®¶buffç‹€æ…‹
        const hasInvincible = player.buffType === 'invincible';
        const hasSpeed = player.buffType === 'speed';
        const hasVampire = player.buffType === 'vampire';
        const isCursed = player.buffType === 'cursed';
        
        // ä½ç½®åˆ†æ
        const playerInCorner = player.x < 100 || player.x > game.width - 100 - player.width;
        const bossInCorner = this.isInCorner(game);
        
        // æ›´æ–°AIæ€§æ ¼
        this.updatePersonality(playerHealthPercent, bossHealthPercent, hasInvincible, isCursed);
        
        // é¸æ“‡æˆ°è¡“
        if (this.decisionCooldown <= 0) {
            this.chooseTactic(player, distance, playerHealthPercent, bossHealthPercent, 
                           hasInvincible, hasSpeed, hasVampire, isCursed, playerInCorner);
            this.decisionCooldown = 0.5;
        }
    }
    
    // æ›´æ–°AIæ€§æ ¼
    updatePersonality(playerHealthPercent, bossHealthPercent, hasInvincible, isCursed) {
        let baseAggression = 0.5;
        if (this.phase === 3) baseAggression = 0.8;
        else if (this.state === 'monster') baseAggression = 0.6;
        
        if (playerHealthPercent < 0.3 && !hasInvincible) {
            this.aggressiveness = Math.min(1.0, baseAggression + 0.4);
            this.caution = 0.2;
        } else if (bossHealthPercent < 0.3) {
            this.aggressiveness = 0.9;
            this.caution = 0.1;
        } else if (hasInvincible) {
            this.aggressiveness = 0.2;
            this.caution = 0.9;
        } else if (isCursed) {
            this.aggressiveness = Math.min(1.0, baseAggression + 0.3);
            this.caution = 0.3;
        } else {
            this.aggressiveness = baseAggression;
            this.caution = 0.5;
        }
    }
    
    // æ™ºèƒ½æˆ°è¡“é¸æ“‡
    chooseTactic(player, distance, playerHealthPercent, bossHealthPercent, 
                hasInvincible, hasSpeed, hasVampire, isCursed, playerInCorner) {
        
        if (hasInvincible && player.buffTimer > 2) {
            this.currentTactic = 'defensive';
            this.aiState = 'retreat';
        } else if (playerHealthPercent < 0.2 && !hasInvincible) {
            this.currentTactic = 'finisher';
            this.aiState = 'rush';
        } else if (playerInCorner && distance < 200) {
            this.currentTactic = 'corner_pressure';
            this.aiState = 'attack';
        } else if (hasVampire && distance < 150) {
            this.currentTactic = 'kite';
            this.aiState = 'retreat';
        } else if (hasSpeed) {
            this.currentTactic = 'predict';
            this.aiState = 'defensive';
        } else if (this.aggressiveness > 0.7) {
            this.currentTactic = 'aggressive';
            this.aiState = distance > 200 ? 'rush' : 'attack';
        } else if (this.aggressiveness < 0.3) {
            this.currentTactic = 'cautious';
            this.aiState = distance < 150 ? 'retreat' : 'stalk';
        } else {
            this.currentTactic = 'balanced';
            this.aiState = distance > 200 ? 'approach' : 'attack';
        }
    }
    
    attack(game) {
        // æ ¹æ“šéšæ®µé¸æ“‡ä¸åŒæ”»æ“Š
        if (this.phase === 1) {
            // ç¬¬ä¸€éšæ®µæ”»æ“Š
            const attackType = Math.random();
            if (attackType < 0.5) {
                this.fireballAttack(game);  // ä½¿ç”¨ç¾æœ‰çš„5å¹€ç«çƒå‹•ç•«
            } else if (attackType < 0.8) {
                this.goldCoinAttack(game);
            } else {
                this.biteAttack(game);
            }
        } else if (this.phase === 3) {
            // ç¬¬ä¸‰éšæ®µæ”»æ“Š - ç‹‚æš´æ¨¡å¼
            const attackType = Math.random();
            if (attackType < 0.4) {
                this.fireballBarrage(game);  // ç¬¬ä¸‰éšæ®µå°ˆå±¬ï¼šç«çƒé€£å°„
            } else if (attackType < 0.6) {
                this.jumpSlam(game);
            } else if (attackType < 0.8) {
                this.fireballAttack(game);  // æ™®é€šç«çƒ
            } else {
                this.goldCoinAttack(game);
            }
        } else {
            // è¦ºé†’éšæ®µæ”»æ“Šï¼ˆHP > 50%ä½†å·²è®Šèº«ï¼‰
            const attackType = Math.random();
            if (attackType < 0.5) {
                this.fireballAttack(game);  // æ™®é€šç«çƒ
            } else if (attackType < 0.8) {
                this.goldCoinAttack(game);
            } else {
                this.biteAttack(game);
            }
        }
    }
    
    // å–®ç™¼ç«çƒæ”»æ“Šï¼ˆæ‰€æœ‰éšæ®µéƒ½å¯ä½¿ç”¨ï¼Œåªç™¼å°„1é¡†ç«çƒï¼‰
    fireballAttack(game) {
        // æ’­æ”¾ç¾æœ‰çš„5å¹€ç«çƒå‹•ç•« (ä½†ä¸åœ¨è®Šèº«æœŸé–“)
        if (!this.isTransforming) {
            this.playAnimation('attack');
        }
        
        const fireball = {
            x: this.x + this.width/2,
            y: this.y + this.height/2,
            width: 20,
            height: 20,
            vx: (player.x - this.x) > 0 ? 250 : -250,
            vy: -100,
            damage: 18,
            owner: this,
            active: true,
            type: 'fireball',
            time: 0,
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += 500 * deltaTime;
                this.time += deltaTime;
                
                if (this.y > 400 || this.x < -50 || this.x > 850) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // ç«çƒæ•ˆæœ
                const gradient = ctx.createRadialGradient(
                    this.x + this.width/2, 
                    this.y + this.height/2, 
                    0,
                    this.x + this.width/2, 
                    this.y + this.height/2, 
                    this.width/2
                );
                gradient.addColorStop(0, '#FFFF00');
                gradient.addColorStop(0.5, '#FF6600');
                gradient.addColorStop(1, '#FF0000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        
        game.projectiles.push(fireball);
    }
    
    // ç¬¬ä¸€éšæ®µ - é‡‘å¹£æŠ•å°„
    goldCoinAttack(game) {
        if (!this.isTransforming) {
            this.playAnimation('attack');
        }
        
        const projectile = {
            x: this.x + this.width/2,
            y: this.y + this.height/2,
            width: 16,
            height: 16,
            vx: (player.x - this.x) > 0 ? 250 : -250,
            vy: -150,
            damage: 15,
            owner: this,
            active: true,
            rotation: 0,
            type: 'coin',
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += 600 * deltaTime;
                this.rotation += deltaTime * 10;
                
                if (this.y > 400 || this.x < -50 || this.x > 850) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                // ç¹ªè£½æ—‹è½‰é‡‘å¹£
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);
                
                ctx.restore();
            }
        };
        
        game.projectiles.push(projectile);
    }
    
    // ç¬¬ä¸€éšæ®µ - å’¬æ“Šæ”»æ“Š
    biteAttack(game) {
        if (!this.isTransforming) {
            // ä½¿ç”¨å’¬æ“Šå‹•ç•«
            this.playAnimation('bite');
        }
        
        // è¿‘è·é›¢æ”»æ“Šåˆ¤å®š
        const attackBox = {
            x: this.x + (this.facing === 1 ? this.width : -40),
            y: this.y + 40,
            width: 40,
            height: 60,
            damage: 25,
            owner: this,
            active: true,
            life: 0.2,
            type: 'bite',
            
            update(deltaTime) {
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // ä¸ç¹ªè£½ä»»ä½•è¦–è¦ºæ•ˆæœï¼Œå› ç‚ºå’¬æ“Šå‹•ç•«å·²ç¶“æœ‰å‹•ç•«åœ–æª”
                // æ”»æ“Šåˆ¤å®šä»ç„¶å­˜åœ¨ï¼Œåªæ˜¯ä¸é¡¯ç¤ºç´…è‰²æ–¹å¡Š
            }
        };
        
        game.projectiles.push(attackBox);
    }
    
    // ç¬¬ä¸‰éšæ®µå°ˆå±¬ - ç«çƒé€£å°„ï¼ˆç™¼å°„3é¡†ç«çƒï¼Œæœ‰6å¹€å°ˆå±¬å‹•ç•«ï¼‰
    fireballBarrage(game) {
        // æ’­æ”¾ç«çƒé€£å°„å‹•ç•«
        if (this.animations.fireballBarrage && this.animations.fireballBarrage.length > 0) {
            this.playAnimation('fireballBarrage');
        }
        
        let fireballCount = 0;
        const shootFireball = () => {
            if (fireballCount >= 3) return; // ç¸½å…±ç™¼å°„3é¡†
            
            const fireball = {
                x: this.x + this.width/2,
                y: this.y + this.height/2,
                width: 24,
                height: 24,
                vx: (player.x - this.x) > 0 ? 300 : -300,
                vy: -50 - (fireballCount * 50),
                damage: 20,
                owner: this,
                active: true,
                type: 'fireball',
                time: 0,
                
                update(deltaTime) {
                    this.x += this.vx * deltaTime;
                    this.y += this.vy * deltaTime;
                    this.vy += 400 * deltaTime;
                    this.time += deltaTime;
                    
                    if (this.y > 400 || this.x < -50 || this.x > 850) {
                        this.active = false;
                    }
                },
                
                render(ctx) {
                    // ç«çƒæ¼¸å±¤æ•ˆæœ
                    const gradient = ctx.createRadialGradient(
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        0,
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        this.width/2
                    );
                    gradient.addColorStop(0, '#FFFF00');
                    gradient.addColorStop(0.5, '#FF6600');
                    gradient.addColorStop(1, '#FF0000');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç«ç„°å°¾è·¡
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2 - this.vx * 0.05, this.y + this.height/2, this.width/3, 0, Math.PI * 2);
                    ctx.fill();
                }
            };
            
            game.projectiles.push(fireball);
            fireballCount++;
            
            if (fireballCount < 3) {
                setTimeout(shootFireball, 200);
            }
        };
        
        shootFireball();
    }
    
    // ç¬¬äºŒéšæ®µ - è·³èºéœ‡åœ°
    jumpSlam(game) {
        if (!this.grounded) return;
        
        // å¤§è·³èº
        this.vy = -600;
        this.grounded = false;
        
        // å»¶é²å‰µå»ºéœ‡æ³¢
        setTimeout(() => {
            if (!this.grounded) return;
            
            // å·¦å³å…©å€‹éœ‡æ³¢
            [-1, 1].forEach(direction => {
                const shockwave = {
                    x: this.x + this.width/2,
                    y: game.height - 60,
                    width: 20,
                    height: 40,
                    vx: direction * 200,
                    vy: 0,
                    damage: 15,
                    owner: this,
                    active: true,
                    life: 1,
                    type: 'shockwave',
                    
                    update(deltaTime) {
                        this.x += this.vx * deltaTime;
                        this.width += 100 * deltaTime;
                        this.life -= deltaTime;
                        
                        if (this.life <= 0 || this.x < -100 || this.x > 900) {
                            this.active = false;
                        }
                    },
                    
                    render(ctx) {
                        ctx.fillStyle = `rgba(139, 69, 19, ${this.life})`;
                        ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                    }
                };
                
                game.projectiles.push(shockwave);
            });
        }, 800);
    }
    
    // 3Dè®Šèº«ç‰¹æ•ˆ
    triggerTransformationEffect() {
        // æ’­æ”¾è®Šèº«å‹•ç•«
        this.playAnimation('transform');
        console.log('é–‹å§‹æ’­æ”¾è®Šèº«å‹•ç•«, ç¸½å¹€æ•¸:', this.animations.transform ? this.animations.transform.length : 0);
        
        // åœæ­¢Bossç§»å‹•
        this.savedVx = this.vx;
        this.savedVy = this.vy;
        this.vx = 0;
        this.vy = 0;
        
        // é‡æ–°å•Ÿç”¨3Dç‰¹æ•ˆè¦†è“‹å±¤
        create3DTransformationEffect(this.x + this.width/2, this.y + this.height/2);
        
        // ä¸æš«åœéŠæˆ²ï¼Œè®“å‹•ç•«å¯ä»¥ç¹¼çºŒæ›´æ–°
        setTimeout(() => {
            showGameMessage('PHASE 3 - FINAL FORM!', 1500);
            // æ¢å¾©ç§»å‹•
            this.vx = this.savedVx || 0;
            this.vy = this.savedVy || 0;
        }, 3240); // 27å¹€ * 0.12ç§’
    }
    
    // 3Dæ­»äº¡ç‰¹æ•ˆ
    // è§¸ç™¼é€ƒè„«æ©Ÿåˆ¶
    triggerEscape() {
        this.escaping = true;
        this.comboTaken = 0;  // é‡ç½®é€£æ“Šè¨ˆæ•¸
        
        // å¿«é€Ÿå¾Œè·³é€ƒè„«
        this.vy = -400;  // å‘ä¸Šè·³
        this.vx = this.facing * -300;  // å‘å¾Œé€€
        this.aiState = 'retreat';
        
        // 0.5ç§’å¾ŒçµæŸé€ƒè„«ç‹€æ…‹
        setTimeout(() => {
            this.escaping = false;
            this.aiState = 'defensive';
        }, 500);
        
        // ç‰¹æ•ˆ
        this.game.addParticle(this.x + this.width/2, this.y + this.height/2, 'escape');
        console.log('Boss triggered escape mechanism!');
    }
    
    triggerDeathEffect() {
        console.log('Triggering Boss death 3D effect');
        // å‰µå»ºæ­»äº¡3Dç‰¹æ•ˆ
        create3DDeathEffect(this.x + this.width/2, this.y + this.height/2);
    }
    
    takeDamage(damage) {
        // è®Šèº«æœŸé–“ç„¡æ•µ
        if (this.isTransforming) {
            console.log('Boss is invincible during transformation!');
            this.game.addParticle(this.x + this.width/2, this.y, 'blocked');
            return;
        }
        
        // æ­£åœ¨é€ƒè„«ä¸­ï¼ŒçŸ­æš«ç„¡æ•µ
        if (this.escaping) {
            this.game.addParticle(this.x + this.width/2, this.y, 'blocked');
            return;
        }
        
        this.health -= damage;
        this.health = Math.max(0, this.health);
        
        // è¨­å®šå—å‚·åƒµç›´
        this.hurtStunTime = this.maxHurtStun;
        this.comboTaken++;  // å¢åŠ è¢«é€£æ“Šè¨ˆæ•¸
        
        // è¢«é€£æ“Š7æ¬¡å¾Œè§¸ç™¼é€ƒè„«æ©Ÿåˆ¶
        if (this.comboTaken >= this.maxComboBeforeEscape) {
            this.triggerEscape();
        }
        
        // æ‰“æ–·ç•¶å‰å‹•ä½œ
        this.vx *= 0.5;  // æ¸›é€Ÿ
        this.aiState = 'hurt';  // é€²å…¥å—å‚·ç‹€æ…‹
        
        // ç¬¬ä¸€æ¬¡å—å‚·è®Šèº«
        if (this.state === 'chest') {
            this.state = 'monster';
        }
        
        // éšæ®µè®ŠåŒ– - è¡€é‡é™åˆ°50%æ™‚è®Šèº«åˆ°ç¬¬ä¸‰éšæ®µ
        if (this.health <= this.maxHealth * 0.5 && this.phase === 1) {
            this.phase = 2; // æš«æ™‚è¨­ç‚º2ï¼Œè®Šèº«å®Œæˆå¾Œæœƒè®Šæˆ3
            // è§¸ç™¼3Dè®Šèº«ç‰¹æ•ˆ
            this.triggerTransformationEffect();
            // è®Šèº«æœŸé–“è¨­å®šæ¨™è¨˜ï¼Œé¿å…è¢«å…¶ä»–å‹•ç•«è¦†è“‹ä¸”ç„¡æ•µ
            this.isTransforming = true;
            setTimeout(() => {
                this.isTransforming = false;
                this.phase = 3; // è®Šèº«å®Œæˆï¼Œé€²å…¥ç¬¬ä¸‰éšæ®µ
                console.log('Transformation complete! Entering Phase 3!');
            }, 3240); // è®Šèº«å‹•ç•«æ™‚é•· (27å¹€ * 0.12ç§’)
        }
        
        this.updateHealth();
        this.game.addParticle(this.x + this.width/2, this.y, 'damage');
        
        // æ’­æ”¾å—æ“Šå‹•ç•« (ä½†ä¸åœ¨è®Šèº«æœŸé–“)
        if (this.health > 0 && this.state === 'monster' && !this.isTransforming) {
            this.playAnimation('hit');
        }
        
        if (this.health <= 0) {
            this.state = 'dying';
            this.playAnimation('death');
            console.log('Boss death animation started');
            
            // è§¸ç™¼3Dæ­»äº¡ç‰¹æ•ˆ
            this.triggerDeathEffect();
            
            // è¨­å®šæ­»äº¡å®Œæˆå›èª¿
            this.onDeathComplete = () => {
                console.log('Boss death animation complete, showing victory');
                this.game.gameOver = true;
                this.game.score += 1000;
                this.game.victory = true;
                showGameOverScreen(true);
            };
            
            // å‚™ç”¨è¨ˆæ™‚å™¨ï¼Œå¦‚æœå‹•ç•«æ²’æœ‰æ­£å¸¸çµæŸ
            setTimeout(() => {
                if (this.state === 'dying' && !this.game.gameOver) {
                    console.log('Death animation timeout, forcing victory');
                    this.onDeathComplete();
                }
            }, 3000); // 3ç§’å¾Œå¼·åˆ¶çµæŸ
        }
    }
    
    updateHealth() {
        const percent = (this.health / this.maxHealth) * 100;
        document.getElementById('bossHP').textContent = `${this.health}/${this.maxHealth}`;
        document.getElementById('bossHealthBar').style.width = percent + '%';
    }
    
    render(ctx) {
        ctx.save();
        
        // é¡åƒè™•ç† - æ ¹æ“šé¢å‘ç¿»è½‰
        if (this.facing === 1) {  // facing = 1 æ™‚é¢å‘å³ï¼Œéœ€è¦ç¿»è½‰åœ–åƒ
            ctx.scale(-1, 1);
            ctx.translate(-this.x * 2 - this.width, 0);
        }
        
        // è™•ç†ç¨‹å¼åŒ–å‹•ç•«æ•ˆæœ
        if (this.currentAnimation === 'hit') {
            // å—æ“Šé–ƒç´…æ•ˆæœ
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
            
            // 0.3ç§’å¾ŒçµæŸå—æ“Šå‹•ç•«
            if (this.animationTimer > 0.3) {
                this.currentAnimation = null;
                this.animationTimer = 0;
            }
        } else if (this.currentAnimation === 'movement') {
            // ç§»å‹•å‹•ç•«æ•ˆæœ - æ·»åŠ æ®˜å½±
            ctx.fillStyle = 'rgba(100, 0, 0, 0.2)';
            const offsetX = this.vx > 0 ? -10 : 10;
            ctx.fillRect(this.x + offsetX, this.y, this.width, this.height);
            
            // 0.5ç§’å¾ŒçµæŸç§»å‹•å‹•ç•«
            if (this.animationTimer > 0.5) {
                this.currentAnimation = null;
                this.animationTimer = 0;
            }
        }
        
        // å¦‚æœæœ‰å‹•ç•«æ­£åœ¨æ’­æ”¾ï¼Œé¡¯ç¤ºå‹•ç•«å¹€ï¼ˆæ’é™¤ç¨‹å¼åŒ–å‹•ç•«ï¼‰
        if (this.currentAnimation && 
            this.currentAnimation !== 'hit' && 
            this.currentAnimation !== 'movement' &&
            this.animations[this.currentAnimation]) {
            const frames = this.animations[this.currentAnimation];
            // ç¢ºä¿å‹•ç•«å¹€ç´¢å¼•ä¸è¶…å‡ºç¯„åœ
            const frameIndex = Math.min(this.animationFrame, frames.length - 1);
            const currentFrame = frames[frameIndex];
            
            // æª¢æŸ¥åœ–ç‰‡æ˜¯å¦å­˜åœ¨ï¼Œä¸ç®¡æ˜¯å¦å®Œå…¨è¼‰å…¥
            if (currentFrame) {
                try {
                    // å¦‚æœåœ–ç‰‡å·²è¼‰å…¥ï¼ˆå¯¬é«˜å¤§æ–¼0ï¼‰å°±ç¹ªè£½
                    if (currentFrame.width > 0 && currentFrame.height > 0) {
                        ctx.drawImage(currentFrame, this.x, this.y, this.width, this.height);
                        // è®Šèº«å‹•ç•«é¡¯ç¤ºç‰¹æ®Šåºåˆ—è³‡è¨Š
                        if (this.currentAnimation === 'transform' && this.transformFrameSequence) {
                            console.log(`Drawing transform animation: sequence index ${this.transformFrameIndex}/${this.transformFrameSequence.length-1}, frame ${frameIndex+1}`);
                        } else {
                            console.log(`Drawing ${this.currentAnimation} frame ${frameIndex}/${frames.length-1}`);
                        }
                        ctx.restore();
                        return; // é¡¯ç¤ºå‹•ç•«æ™‚ä¸é¡¯ç¤ºå…¶ä»–åœ–å½¢
                    } else {
                        console.log(`Frame not ready: ${this.currentAnimation} frame ${frameIndex}, size: ${currentFrame.width}x${currentFrame.height}`);
                    }
                } catch (e) {
                    console.log('å‹•ç•«å¹€ç¹ªè£½å¤±æ•—:', e);
                }
            } else {
                console.log(`No frame at index ${frameIndex} for ${this.currentAnimation}`);
            }
        }
        
        // æ€ªç‰©å½¢æ…‹ä¸”æ²’æœ‰å…¶ä»–å‹•ç•«æ™‚ï¼Œé¡¯ç¤ºå¾…æ©Ÿå‹•ç•«
        if (this.state === 'monster' && !this.currentAnimation) {
            // æ ¹æ“šéšæ®µé¸æ“‡å¾…æ©Ÿå‹•ç•«
            let idleAnim;
            if (this.phase === 3) {
                // ç¬¬ä¸‰éšæ®µä½¿ç”¨5å¹€å¾…æ©Ÿå‹•ç•«
                idleAnim = this.animations.idlePhase3;
                // æ’­æ”¾å¤šå¹€å‹•ç•«
                if (idleAnim && idleAnim.length > 1) {
                    if (!this.phase3IdleTimer) this.phase3IdleTimer = 0;
                    if (!this.phase3IdleFrame) this.phase3IdleFrame = 0;
                    
                    this.phase3IdleTimer += 0.016; // å‡è¨­60 FPS
                    if (this.phase3IdleTimer >= 0.15) { // æ¯0.15ç§’åˆ‡æ›ä¸€å¹€ï¼ˆç‹‚æš´éšæ®µæ›´å¿«ï¼‰
                        this.phase3IdleTimer = 0;
                        this.phase3IdleFrame = (this.phase3IdleFrame + 1) % idleAnim.length;
                    }
                    
                    const idleFrame = idleAnim[this.phase3IdleFrame];
                    if (idleFrame && idleFrame.width > 0 && idleFrame.height > 0) {
                        ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                        ctx.restore();
                        return;
                    }
                }
            } else if (this.phase === 1 && this.state === 'monster') {
                // è¦ºé†’ç‹€æ…‹ï¼ˆHP > 50%ï¼‰ä½¿ç”¨è¦ºé†’å¾…æ©Ÿå‹•ç•«
                idleAnim = this.animations.awakenedIdle;
                // å¦‚æœæœ‰å¤šå¹€ï¼Œæ’­æ”¾å‹•ç•«
                if (idleAnim && idleAnim.length > 1) {
                    if (!this.idleAnimTimer) this.idleAnimTimer = 0;
                    if (!this.idleAnimFrame) this.idleAnimFrame = 0;
                    
                    this.idleAnimTimer += 0.016; // å‡è¨­60 FPS
                    if (this.idleAnimTimer >= 0.3) { // æ¯0.3ç§’åˆ‡æ›ä¸€å¹€
                        this.idleAnimTimer = 0;
                        this.idleAnimFrame = (this.idleAnimFrame + 1) % idleAnim.length;
                    }
                    
                    const idleFrame = idleAnim[this.idleAnimFrame];
                    if (idleFrame && idleFrame.width > 0 && idleFrame.height > 0) {
                        ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                        ctx.restore();
                        return;
                    }
                }
            } else {
                idleAnim = this.animations.idle;
            }
            
            if (idleAnim && idleAnim[0]) {
                const idleFrame = idleAnim[0];
                if (idleFrame.width > 0 && idleFrame.height > 0) {
                    ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                    ctx.restore();
                    return;
                }
            }
        }
        
        // æ²’æœ‰å‹•ç•«æ™‚é¡¯ç¤ºé è¨­åœ–å½¢
        if (this.state === 'chest') {
            // å˜—è©¦é¡¯ç¤ºå½è£å¾…æ©Ÿåœ–ç‰‡
            if (this.animations.idle && this.animations.idle.length > 0 && this.animations.idle[0].complete) {
                ctx.drawImage(this.animations.idle[0], this.x, this.y, this.width, this.height);
            } else {
                // å¦‚æœåœ–ç‰‡æœªè¼‰å…¥ï¼Œé¡¯ç¤ºç¨‹å¼åŒ–çš„å¯¶ç®±
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(this.x + 24, this.y + 48, 80, 60);
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x + 24, this.y + 36, 80, 20);
                
                // å¯¶ç®±é–
                ctx.fillStyle = '#ffcc66';
                ctx.fillRect(this.x + 56, this.y + 30, 16, 24);
                
                // å¯¶ç®±ç´°ç¯€
                ctx.fillStyle = '#6b3410';
                ctx.fillRect(this.x + 24, this.y + 64, 80, 4);
                ctx.fillRect(this.x + 24, this.y + 88, 80, 4);
            }
        } else {
            // æ”¾å¤§çš„æ€ªç‰©å½¢æ…‹
            // ä¸»é«” (ç¬¬ä¸‰éšæ®µæœ‰ç‰¹æ®Šé¡è‰²)
            if (this.phase === 3) {
                // ç¬¬ä¸‰éšæ®µ - æš—ç´«è‰²å¸¶ç´…å…‰
                const gradient = ctx.createLinearGradient(this.x + 32, this.y + 40, this.x + 96, this.y + 96);
                gradient.addColorStop(0, '#440044');
                gradient.addColorStop(0.5, '#660033');
                gradient.addColorStop(1, '#330011');
                ctx.fillStyle = gradient;
            } else {
                ctx.fillStyle = this.phase === 2 ? '#660000' : '#8b4513';
            }
            ctx.fillRect(this.x + 32, this.y + 40, 64, 56);
            
            // å¤§å˜´å·´
            ctx.fillStyle = this.phase === 3 ? '#110011' : '#330000';
            ctx.fillRect(this.x + 40, this.y + 60, 48, 24);
            
            // ç‰™é½’ (æ›´å¤§æ›´å…‡)
            ctx.fillStyle = this.phase === 3 ? '#ffccff' : '#ffffff';
            for (let i = 0; i < 6; i++) {
                // ä¸Šæ’ç‰™é½’
                ctx.fillRect(this.x + 42 + i * 7, this.y + 60, 5, 10);
                // ä¸‹æ’ç‰™é½’
                ctx.fillRect(this.x + 42 + i * 7, this.y + 74, 5, 10);
            }
            
            // çœ¼ç› (ç¬¬ä¸‰éšæ®µç™¼å…‰çš„ç´«è‰²çœ¼ç›)
            if (this.phase === 3) {
                // ç™¼å…‰æ•ˆæœ
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ff00ff';
            } else {
                ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#ffff00';
            }
            ctx.fillRect(this.x + 40, this.y + 44, 12, 12);
            ctx.fillRect(this.x + 76, this.y + 44, 12, 12);
            ctx.shadowBlur = 0;
            
            // ç³å­”
            ctx.fillStyle = '#000000';
            ctx.fillRect(this.x + 44, this.y + 48, 4, 4);
            ctx.fillRect(this.x + 80, this.y + 48, 4, 4);
            
            // è…¿ (æ›´ç²—å£¯)
            if (this.state === 'monster') {
                ctx.fillStyle = this.phase === 3 ? '#220022' : (this.phase === 2 ? '#330000' : '#660000');
                ctx.fillRect(this.x + 36, this.y + 96, 20, 32);
                ctx.fillRect(this.x + 72, this.y + 96, 20, 32);
                
                // è…³çˆª
                ctx.fillStyle = this.phase === 3 ? '#ffccff' : '#ffffff';
                ctx.fillRect(this.x + 36, this.y + 124, 20, 4);
                ctx.fillRect(this.x + 72, this.y + 124, 20, 4);
            }
            
            // éšæ®µç‰¹æ•ˆ
            if (this.phase === 2) {
                // æ†¤æ€’çš„æ°£å ´
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x + 20, this.y + 30, 88, 98);
            } else if (this.phase === 3) {
                // ç¬¬ä¸‰éšæ®µ - ç´«è‰²èƒ½é‡å ´
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x + 20, this.y + 30, 88, 98);
                
                // æ¼‚æµ®çš„èƒ½é‡ç²’å­
                const time = Date.now() / 1000;
                ctx.fillStyle = 'rgba(255, 0, 255, 0.8)';
                for (let i = 0; i < 3; i++) {
                    const offsetX = Math.sin(time * 2 + i * 2) * 15;
                    const offsetY = Math.cos(time * 3 + i * 2) * 10;
                    ctx.fillRect(this.x + 50 + offsetX, this.y + 20 + offsetY, 4, 4);
                }
            }
        }
        
        ctx.restore();
    }
}

// ç¦®ç›’é¡
class GiftBox {
    constructor(x, y, game) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;
        this.game = game;
        this.vy = 0;
        this.grounded = false;
        this.collected = false;
        this.isGiftBox = true;
        
        // ç¦®ç›’æ•ˆæœåˆ—è¡¨
        this.effects = [
            { type: 'invincible', name: 'é€™æ˜¯ä¸€å€‹å¾ˆæ£’çš„æƒ³æ³•', description: 'ç„¡è¦–æ”»æ“Š10ç§’ï¼ŒçµæŸå¾Œè¡€é‡å…¨æ»¿', color: '#00ff00', image: 'Assets/GiftStates/invincible.png' },
            { type: 'speed', name: 'Run Don\'t walk', description: 'é€Ÿåº¦èˆ‡æ”»é€Ÿæå‡2.5å€ï¼ŒæŒçºŒ10ç§’', color: '#00ffff', image: 'Assets/GiftStates/run_dont_walk.png' },
            { type: 'vampire', name: 'è¤‡è£½è²¼ä¸Š', description: 'æ”»æ“ŠåŠ›1.5å€ä¸¦å¸è¡€ï¼ŒæŒçºŒ10ç§’', color: '#ff00ff', image: 'Assets/GiftStates/copy_paste.png' },
            { type: 'cursed', name: 'è¢«ç¥–äº†', description: 'ä½ è¢«ç¥–äº†', color: '#ff0000', image: 'Assets/GiftStates/cursed.png' }
        ];
    }
    
    update(deltaTime, game) {
        if (this.collected) return;
        
        // é‡åŠ›
        this.vy += 800 * deltaTime;
        this.y += this.vy * deltaTime;
        
        // è½åœ°
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
    }
    
    collect(player) {
        if (this.collected) return;
        this.collected = true;
        
        // éš¨æ©Ÿé¸æ“‡æ•ˆæœ
        const effect = this.effects[Math.floor(Math.random() * this.effects.length)];
        
        // é¡¯ç¤ºæ•ˆæœ UIï¼ˆå…ˆé¡¯ç¤ºUIï¼‰
        this.showEffectUI(effect);
        
        // å»¶é²ä¸€é»æ’­æ”¾èªéŸ³ï¼Œç¢ºä¿UIå·²ç¶“é¡¯ç¤º
        setTimeout(() => {
            this.playGiftSound(effect.type);
        }, 100);
        
        // æ‡‰ç”¨æ•ˆæœåˆ°ç©å®¶
        setTimeout(() => {
            player.applyBuff(effect.type);
            // å¾å¯¦é«”åˆ—è¡¨ç§»é™¤ç¦®ç›’
            const index = this.game.entities.indexOf(this);
            if (index > -1) {
                this.game.entities.splice(index, 1);
            }
        }, 1500);  // 1.5ç§’å¾Œæ‡‰ç”¨æ•ˆæœ
    }
    
    playGiftSound(effectType) {
        // ä½¿ç”¨é è¼‰å…¥çš„éŸ³æ•ˆ
        if (giftSounds[effectType]) {
            // é‡ç½®éŸ³é »åˆ°é–‹å§‹ä½ç½®
            giftSounds[effectType].currentTime = 0;
            giftSounds[effectType].volume = 1.0;  // ç¢ºä¿éŸ³é‡æœ€å¤§
            
            // æ’­æ”¾éŸ³æ•ˆ
            giftSounds[effectType].play().then(() => {
                console.log('Playing gift sound:', effectType);
            }).catch(error => {
                console.error('Failed to play gift sound:', effectType, error);
                // å¦‚æœé è¼‰å…¥çš„éŸ³æ•ˆå¤±æ•—ï¼Œå˜—è©¦å‰µå»ºæ–°çš„
                const fallbackAudio = new Audio(`Assets/Audio/GiftBox/gift_${effectType}.mp3`);
                fallbackAudio.volume = 1.0;  // æœ€å¤§éŸ³é‡
                fallbackAudio.play().catch(e => console.error('Fallback audio also failed:', e));
            });
        } else {
            console.log('Gift sound not found for effect:', effectType);
        }
    }
    
    showEffectUI(effect) {
        // å‡çµéŠæˆ²
        this.game.paused = true;
        
        // å‰µå»ºæ•ˆæœé¡¯ç¤ºå±¤
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.top = '50%';
        effectDiv.style.left = '50%';
        effectDiv.style.transform = 'translate(-50%, -50%)';
        effectDiv.style.zIndex = '5000';
        effectDiv.style.background = 'rgba(0, 0, 0, 0.9)';
        effectDiv.style.border = `3px solid ${effect.color}`;
        effectDiv.style.padding = '40px';
        effectDiv.style.borderRadius = '10px';
        effectDiv.style.textAlign = 'center';
        effectDiv.style.fontFamily = '"Press Start 2P", cursive';
        effectDiv.style.animation = 'fadeIn 0.5s';
        
        // æ•ˆæœåœ–æ¨™å®¹å™¨ï¼ˆé¡¯ç¤ºå°æ‡‰åœ–ç‰‡ï¼‰
        const iconContainer = document.createElement('div');
        iconContainer.style.width = '250px';
        iconContainer.style.height = '250px';
        iconContainer.style.margin = '0 auto 30px';
        iconContainer.style.position = 'relative';
        iconContainer.style.display = 'flex';
        iconContainer.style.alignItems = 'center';
        iconContainer.style.justifyContent = 'center';
        
        // èƒŒæ™¯å…‰ç’°æ•ˆæœï¼ˆæ”¹ç‚ºè„ˆå‹•è€Œéæ—‹è½‰ï¼‰
        const bgGlow = document.createElement('div');
        bgGlow.style.position = 'absolute';
        bgGlow.style.width = '280px';
        bgGlow.style.height = '280px';
        bgGlow.style.background = `radial-gradient(circle, ${effect.color}60 0%, ${effect.color}30 40%, transparent 70%)`;
        bgGlow.style.animation = 'glowPulse 2s ease-in-out infinite';
        bgGlow.style.pointerEvents = 'none';
        iconContainer.appendChild(bgGlow);
        
        // åœ–ç‰‡å®¹å™¨
        const icon = document.createElement('div');
        icon.style.width = '200px';
        icon.style.height = '200px';
        icon.style.position = 'relative';
        icon.style.borderRadius = '15px';
        icon.style.overflow = 'hidden';
        icon.style.zIndex = '2';
        
        // å¦‚æœæœ‰åœ–ç‰‡ï¼Œè¼‰å…¥åœ–ç‰‡
        if (effect.image) {
            const img = document.createElement('img');
            img.src = effect.image;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.borderRadius = '15px';
            // å¢å¼·çš„å…‰æšˆæ•ˆæœï¼ˆé…åˆå‹•ç•«çš„é–ƒçˆï¼‰
            img.style.filter = `
                drop-shadow(0 0 30px ${effect.color}) 
                drop-shadow(0 0 60px ${effect.color}) 
                drop-shadow(0 0 90px ${effect.color}80)
            `;
            icon.appendChild(img);
            
            // åœ–ç‰‡ä¸éœ€è¦é¡å¤–å‹•ç•«ï¼Œç”±å®¹å™¨å‹•ç•«æ§åˆ¶
            
            // å¦‚æœåœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œé¡¯ç¤ºé¡è‰²æ–¹å¡Š
            img.onerror = () => {
                img.remove();
                icon.style.background = `linear-gradient(135deg, ${effect.color}, ${effect.color}80)`;
                icon.style.boxShadow = `
                    0 0 40px ${effect.color}, 
                    0 0 80px ${effect.color}80,
                    inset 0 0 20px rgba(255,255,255,0.3)
                `;
            };
        } else {
            // æ²’æœ‰åœ–ç‰‡æ™‚é¡¯ç¤ºæ¼¸å±¤æ–¹å¡Š
            icon.style.background = `linear-gradient(135deg, ${effect.color}, ${effect.color}80)`;
            icon.style.boxShadow = `
                0 0 40px ${effect.color}, 
                0 0 80px ${effect.color}80,
                inset 0 0 20px rgba(255,255,255,0.3)
            `;
        }
        
        // æ·»åŠ ä¸»è¦å‹•ç•«ï¼ˆæ”¾å¤§é–ƒçˆç¸®å°æ•ˆæœï¼‰
        icon.style.animation = 'scaleFlash 1.5s ease-out forwards';
        
        // æ·»åŠ ç²’å­æ•ˆæœ
        for (let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.background = effect.color;
            particle.style.borderRadius = '50%';
            particle.style.left = '50%';
            particle.style.top = '50%';
            particle.style.transform = `translate(-50%, -50%)`;
            particle.style.boxShadow = `0 0 10px ${effect.color}`;
            particle.style.animation = `particleFloat${i} 3s infinite`;
            particle.style.animationDelay = `${i * 0.2}s`;
            iconContainer.appendChild(particle);
        }
        
        iconContainer.appendChild(icon);
        
        effectDiv.appendChild(iconContainer);
        
        // æ•ˆæœåç¨±
        const title = document.createElement('h2');
        title.style.color = effect.color;
        title.style.fontSize = '24px';
        title.style.marginBottom = '20px';
        title.style.textShadow = `0 0 10px ${effect.color}`;
        title.textContent = effect.name;
        effectDiv.appendChild(title);
        
        // æ•ˆæœæè¿°
        const desc = document.createElement('p');
        desc.style.color = '#ffffff';
        desc.style.fontSize = '14px';
        desc.style.lineHeight = '1.5';
        desc.textContent = effect.description;
        effectDiv.appendChild(desc);
        
        document.body.appendChild(effectDiv);
        
        // æ’­æ”¾éŸ³æ•ˆï¼ˆå¦‚æœæœ‰éŸ³æ•ˆç³»çµ±çš„è©±ï¼‰
        this.playEffectSound(effect.type);
        
        // 1.5ç§’å¾Œç§»é™¤UIä¸¦è§£é™¤æš«åœ
        setTimeout(() => {
            effectDiv.remove();
            this.game.paused = false;
        }, 1500);
    }
    
    playEffectSound(type) {
        // å‰µå»ºç°¡å–®çš„éŸ³æ•ˆ
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // æ ¹æ“šæ•ˆæœé¡å‹è¨­ç½®ä¸åŒéŸ³èª¿
        switch(type) {
            case 'invincible':
                oscillator.frequency.value = 800;  // é«˜éŸ³
                break;
            case 'speed':
                oscillator.frequency.value = 600;  // ä¸­é«˜éŸ³
                break;
            case 'vampire':
                oscillator.frequency.value = 400;  // ä¸­éŸ³
                break;
            case 'cursed':
                oscillator.frequency.value = 200;  // ä½éŸ³
                break;
        }
        
        gainNode.gain.value = 0.1;
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    }
    
    render(ctx) {
        if (this.collected) return;
        
        ctx.save();
        
        // ç¹ªè£½ç¦®ç›’
        // ç›’å­ä¸»é«”
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(this.x, this.y + 15, this.width, this.height - 15);
        
        // ç›’å­è“‹å­
        ctx.fillStyle = '#ff8800';
        ctx.fillRect(this.x - 2, this.y + 10, this.width + 4, 8);
        
        // çµ²å¸¶ï¼ˆå‚ç›´ï¼‰
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(this.x + this.width/2 - 4, this.y, 8, this.height);
        
        // çµ²å¸¶ï¼ˆæ°´å¹³ï¼‰
        ctx.fillRect(this.x, this.y + 12, this.width, 4);
        
        // è´è¶çµ
        ctx.fillStyle = '#ffcc00';
        // å·¦é‚Š
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2, this.y + 5);
        ctx.lineTo(this.x + this.width/2 - 10, this.y);
        ctx.lineTo(this.x + this.width/2 - 10, this.y + 10);
        ctx.closePath();
        ctx.fill();
        
        // å³é‚Š
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2, this.y + 5);
        ctx.lineTo(this.x + this.width/2 + 10, this.y);
        ctx.lineTo(this.x + this.width/2 + 10, this.y + 10);
        ctx.closePath();
        ctx.fill();
        
        // ç™¼å…‰æ•ˆæœ
        ctx.shadowColor = '#ffcc00';
        ctx.shadowBlur = 20;
        ctx.fillStyle = 'rgba(255, 204, 0, 0.3)';
        ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
        
        ctx.restore();
    }
}

// éŠæˆ²å¾ªç’°
let lastTime = 0;

function gameLoop(currentTime) {
    if (!lastTime) lastTime = currentTime;
    const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
    lastTime = currentTime;
    
    if (game) {
        // ç¸½æ˜¯æ¸²æŸ“ï¼Œå³ä½¿æš«åœ
        game.render();
        // åªåœ¨éæš«åœå’ŒéçµæŸæ™‚æ›´æ–°
        if (!game.paused && !game.gameOver) {
            game.update(deltaTime);
        }
    }
    
    animationId = requestAnimationFrame(gameLoop);
}

// å·¥å…·å‡½æ•¸
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// æ¸¬è©¦æ¨¡å¼ï¼šåœ¨URLåŠ ä¸Š ?debug=true å¯ä»¥åœ¨é›»è…¦ä¸Šçœ‹åˆ°è§¸æ§æŒ‰éˆ•
function isDebugMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('debug') === 'true';
}

function initMobileControls() {
    // é¡¯ç¤ºæ‰‹æ©Ÿæ§åˆ¶
    const mobileControls = document.getElementById('mobileControls');
    if (mobileControls) {
        mobileControls.style.display = 'block';
    }
    
    const controls = document.querySelectorAll('.control-btn');
    
    // ç‚ºæ¯å€‹æŒ‰éˆ•æ·»åŠ äº‹ä»¶
    controls.forEach(btn => {
        const key = btn.dataset.key;
        
        // è§¸æ§äº‹ä»¶
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = true;
                console.log('Touch start:', key);
                // ç‰¹åˆ¥è™•ç†æ”»æ“ŠæŒ‰éˆ•
                if (key === ' ' && player) {
                    player.attack(game);
                }
            }
            btn.style.background = 'rgba(255, 204, 102, 0.9)';
        });
        
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
                console.log('Touch end:', key);
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        btn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        // æ»‘é¼ äº‹ä»¶ï¼ˆç”¨æ–¼é›»è…¦æ¸¬è©¦ï¼‰
        btn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = true;
                console.log('Mouse down:', key);
                // ç‰¹åˆ¥è™•ç†æ”»æ“ŠæŒ‰éˆ•
                if (key === ' ' && player) {
                    player.attack(game);
                }
            }
            btn.style.background = 'rgba(255, 204, 102, 0.9)';
        });
        
        btn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
                console.log('Mouse up:', key);
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        btn.addEventListener('mouseleave', (e) => {
            if (game && game.keys) {
                game.keys[key] = false;
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
    });
    
    console.log('Mobile controls initialized');
}

// Three.js 3D transformation effect (positioned at Boss location)
function create3DTransformationEffect(bossX, bossY) {
    // Convert boss canvas coordinates to screen coordinates
    const canvas = document.getElementById('gameCanvas');
    const rect = canvas.getBoundingClientRect();
    const screenX = rect.left + (bossX / 800) * rect.width;
    const screenY = rect.top + (bossY / 400) * rect.height;
    
    // Create a temporary div for the 3D effect centered on boss
    const effectDiv = document.createElement('div');
    effectDiv.style.position = 'fixed';
    effectDiv.style.left = (screenX - 200) + 'px';
    effectDiv.style.top = (screenY - 200) + 'px';
    effectDiv.style.width = '400px';
    effectDiv.style.height = '400px';
    effectDiv.style.pointerEvents = 'none';
    effectDiv.style.zIndex = '1000';
    document.body.appendChild(effectDiv);

    // Initialize Three.js with smaller viewport
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(400, 400);
    effectDiv.appendChild(renderer.domElement);

    // Create particle system and cubes for transformation effect
    const particles = [];
    const cubes = [];
    
    // Create rotating cubes
    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cubeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        wireframe: true,
        opacity: 0.8,
        transparent: true
    });
    
    for (let i = 0; i < 8; i++) {
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial.clone());
        const angle = (i / 8) * Math.PI * 2;
        cube.position.x = Math.cos(angle) * 3;
        cube.position.z = Math.sin(angle) * 3;
        cube.rotation.x = Math.random() * Math.PI;
        cube.rotation.y = Math.random() * Math.PI;
        scene.add(cube);
        cubes.push(cube);
    }

    // Create particle effect
    const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xFF00FF,
        transparent: true,
        opacity: 1
    });
    
    for (let i = 0; i < 50; i++) {
        const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
        particle.position.x = (Math.random() - 0.5) * 2;
        particle.position.y = (Math.random() - 0.5) * 2;
        particle.position.z = (Math.random() - 0.5) * 2;
        particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2
        );
        scene.add(particle);
        particles.push(particle);
    }

    camera.position.z = 10;

    // Animation variables
    let animationTime = 0;
    const maxAnimationTime = 3240; // Match transformation duration (27 frames * 0.12s)

    // Animate the effect
    function animate() {
        animationTime += 16; // Approximate 60fps
        
        if (animationTime >= maxAnimationTime) {
            // Clean up
            effectDiv.remove();
            return;
        }

        requestAnimationFrame(animate);

        const progress = animationTime / maxAnimationTime;
        
        // Rotate and expand cubes
        cubes.forEach((cube, i) => {
            cube.rotation.x += 0.05;
            cube.rotation.y += 0.05;
            const angle = (i / 8) * Math.PI * 2 + animationTime * 0.001;
            const radius = 3 + progress * 5;
            cube.position.x = Math.cos(angle) * radius;
            cube.position.z = Math.sin(angle) * radius;
            cube.material.opacity = Math.max(0, 1 - progress);
        });

        // Move and fade particles
        particles.forEach(particle => {
            particle.position.add(particle.velocity);
            particle.material.opacity = Math.max(0, 1 - progress);
            particle.scale.setScalar(1 + progress * 2);
        });

        // Rotate camera slightly for dynamic effect
        camera.position.x = Math.sin(animationTime * 0.001) * 2;
        camera.position.y = Math.cos(animationTime * 0.001) * 1;

        renderer.render(scene, camera);
    }

    animate();
}

// 3Dæ­»äº¡ç‰¹æ•ˆå‡½æ•¸
function create3DDeathEffect(bossX, bossY) {
    // Convert boss canvas coordinates to screen coordinates
    const canvas = document.getElementById('gameCanvas');
    const rect = canvas.getBoundingClientRect();
    const screenX = rect.left + (bossX / 800) * rect.width;
    const screenY = rect.top + (bossY / 400) * rect.height;
    
    // Create a temporary div for the 3D effect centered on boss
    const effectDiv = document.createElement('div');
    effectDiv.style.position = 'fixed';
    effectDiv.style.left = (screenX - 250) + 'px';
    effectDiv.style.top = (screenY - 250) + 'px';
    effectDiv.style.width = '500px';
    effectDiv.style.height = '500px';
    effectDiv.style.pointerEvents = 'none';
    effectDiv.style.zIndex = '1000';
    document.body.appendChild(effectDiv);
    
    // Initialize Three.js with larger viewport for death effect
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(500, 500);
    effectDiv.appendChild(renderer.domElement);
    
    // Create explosion particles
    const particles = [];
    const fragments = [];
    
    // Create fragmenting cubes (Boss breaking apart)
    const fragmentGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    
    for (let i = 0; i < 20; i++) {
        const fragmentMaterial = new THREE.MeshBasicMaterial({ 
            color: Math.random() > 0.5 ? 0xff0000 : 0x8b0000,
            transparent: true,
            opacity: 1
        });
        const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
        fragment.position.x = (Math.random() - 0.5) * 2;
        fragment.position.y = (Math.random() - 0.5) * 2;
        fragment.position.z = (Math.random() - 0.5) * 2;
        fragment.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.3 + 0.1,
            (Math.random() - 0.5) * 0.5
        );
        fragment.rotationSpeed = new THREE.Vector3(
            Math.random() * 0.2,
            Math.random() * 0.2,
            Math.random() * 0.2
        );
        scene.add(fragment);
        fragments.push(fragment);
    }
    
    // Create explosion particles
    const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
    
    for (let i = 0; i < 100; i++) {
        const particleMaterial = new THREE.MeshBasicMaterial({ 
            color: Math.random() > 0.7 ? 0xffff00 : (Math.random() > 0.5 ? 0xff6600 : 0xff0000),
            transparent: true,
            opacity: 1
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.5;
        particle.position.x = Math.cos(angle) * radius;
        particle.position.y = 0;
        particle.position.z = Math.sin(angle) * radius;
        particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            Math.random() * 0.5 + 0.2,
            (Math.random() - 0.5) * 0.8
        );
        scene.add(particle);
        particles.push(particle);
    }
    
    // Create energy ring effect
    const ringGeometry = new THREE.TorusGeometry(2, 0.2, 8, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        wireframe: true,
        transparent: true,
        opacity: 1
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.rotation.x = Math.PI / 2;
    scene.add(ring);
    
    camera.position.z = 12;
    camera.position.y = 3;
    camera.lookAt(0, 0, 0);
    
    // Animation variables
    let animationTime = 0;
    const maxAnimationTime = 3000; // 3 seconds for death effect
    
    // Animate the death effect
    function animateDeath() {
        animationTime += 16; // Approximate 60fps
        
        if (animationTime >= maxAnimationTime) {
            // Clean up
            effectDiv.remove();
            return;
        }
        
        requestAnimationFrame(animateDeath);
        const progress = animationTime / maxAnimationTime;
        
        // Expand and fade ring
        ring.scale.setScalar(1 + progress * 3);
        ring.material.opacity = Math.max(0, 1 - progress);
        ring.rotation.z += 0.05;
        
        // Move fragments outward with gravity
        fragments.forEach(fragment => {
            fragment.position.add(fragment.velocity);
            fragment.velocity.y -= 0.01; // Gravity
            fragment.rotation.x += fragment.rotationSpeed.x;
            fragment.rotation.y += fragment.rotationSpeed.y;
            fragment.rotation.z += fragment.rotationSpeed.z;
            fragment.material.opacity = Math.max(0, 1 - progress * 0.8);
        });
        
        // Explode particles outward
        particles.forEach(particle => {
            particle.position.add(particle.velocity);
            particle.velocity.y -= 0.005; // Slight gravity
            particle.material.opacity = Math.max(0, 1 - progress);
            particle.scale.setScalar(1 - progress * 0.5);
        });
        
        // Camera shake effect
        if (progress < 0.3) {
            camera.position.x = Math.sin(animationTime * 0.05) * (1 - progress * 3) * 0.5;
            camera.position.z = 12 + Math.cos(animationTime * 0.05) * (1 - progress * 3) * 0.5;
        }
        
        renderer.render(scene, camera);
    }
    
    animateDeath();
}
    </script>
</body>
</html>