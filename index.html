<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Vibe Coding Dungeon</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='50' font-size='50'>⚔️</text></svg>">
    
    <!-- 載入像素字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- Three.js CDN for 3D transformation effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            overflow: hidden;
            position: relative;
        }
        
        /* 手機橫向提示 */
        #rotatePrompt {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
        }
        
        #rotatePrompt.show {
            display: flex;
        }
        
        .rotate-icon {
            font-size: 60px;
            animation: rotate 2s ease-in-out infinite;
            margin-bottom: 30px;
        }
        
        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        .rotate-text {
            color: #ffcc66;
            font-size: 14px;
            text-align: center;
            line-height: 1.5;
        }
        
        /* 開始畫面 */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('Assets/Backgrounds/dungeon-start-bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        #startScreen.fadeOut {
            opacity: 0;
            pointer-events: none;
        }
        
        /* 暗色覆蓋層 */
        #startScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 1;
        }
        
        /* 火光動畫效果 */
        @keyframes fireGlow {
            0% { filter: brightness(1) drop-shadow(0 0 10px #ff6600); }
            25% { filter: brightness(1.1) drop-shadow(0 0 15px #ff8833); }
            50% { filter: brightness(0.95) drop-shadow(0 0 12px #ff6600); }
            75% { filter: brightness(1.05) drop-shadow(0 0 18px #ff9944); }
            100% { filter: brightness(1) drop-shadow(0 0 10px #ff6600); }
        }
        
        /* 標題容器 */
        .title-container {
            position: relative;
            z-index: 2;
            text-align: center;
            animation: fireGlow 3s infinite;
            margin-bottom: 50px;
        }
        
        /* 主標題 */
        .game-title {
            font-size: clamp(24px, 6vw, 48px);
            color: #ff9944;
            text-shadow: 
                3px 3px 0px #8b4513,
                6px 6px 0px #5d2f0d,
                9px 9px 20px rgba(255, 102, 0, 0.8),
                0 0 40px rgba(255, 102, 0, 0.5);
            letter-spacing: 2px;
            margin-bottom: 20px;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
        
        /* 按鈕容器 */
        .button-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        /* 地下城風格按鈕 */
        .dungeon-btn {
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 3px solid #8b6914;
            padding: 15px 40px;
            font-size: clamp(14px, 2.5vw, 18px);
            color: #ffcc66;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
            box-shadow: 
                inset 0 -4px 0 #1a1410,
                0 4px 8px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 1px;
        }
        
        .dungeon-btn::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ff6600, #ff9944, #ff6600);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            filter: blur(4px);
        }
        
        .dungeon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                inset 0 -4px 0 #1a1410,
                0 6px 12px rgba(0, 0, 0, 0.9);
            color: #ffdd88;
        }
        
        .dungeon-btn:hover::before {
            opacity: 0.6;
        }
        
        .dungeon-btn:active {
            transform: translateY(2px);
            box-shadow: 
                inset 0 -2px 0 #1a1410,
                0 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        /* 火焰粒子效果 */
        .fire-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff6600;
            border-radius: 50%;
            pointer-events: none;
            animation: floatUp 3s linear infinite;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(100vh) scale(1);
                opacity: 1;
            }
            25% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) scale(0);
                opacity: 0;
            }
        }
        
        /* 遊戲容器 */
        #gameContainer {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #1a1a2e;
        }
        
        #gameContainer.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 遊戲畫布 */
        #gameCanvas {
            border: 3px solid #8b6914;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
        }
        
        /* 引導視窗 */
        #guideWindow {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #2e2416 0%, #1a1410 100%);
            border: 3px solid #8b6914;
            padding: 30px;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
            max-width: 500px;
            font-family: 'Press Start 2P', cursive;
        }
        
        #guideWindow.show {
            display: block;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        
        .guide-title {
            color: #ff9944;
            font-size: 20px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px #000;
            text-align: center;
        }
        
        .guide-content {
            color: #cccccc;
            font-size: 14px;
            line-height: 1.8;
            margin-bottom: 20px;
        }
        
        .guide-controls {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .control-key {
            color: #ffcc66;
            background: #1a1410;
            padding: 5px 10px;
            border: 1px solid #8b6914;
        }
        
        .control-desc {
            color: #999;
            padding: 5px;
        }
        
        .guide-close {
            width: 100%;
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 2px solid #8b6914;
            padding: 10px;
            color: #ffcc66;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .guide-close:hover {
            background: linear-gradient(180deg, #5a4c38 0%, #3e3426 100%);
            transform: scale(1.05);
        }
        
        /* 遊戲結束畫面 */
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
        }
        
        #gameOverScreen.show {
            display: flex;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulseGlow {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes scaleFlash {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            20% {
                transform: scale(1.4);
                opacity: 1;
                filter: brightness(2.5);
            }
            30% {
                transform: scale(1.2);
                filter: brightness(1.2);
            }
            40% {
                transform: scale(1.3);
                filter: brightness(2.2);
            }
            50% {
                transform: scale(1.15);
                filter: brightness(1.3);
            }
            60% {
                transform: scale(1.25);
                filter: brightness(2);
            }
            70% {
                transform: scale(1.1);
                filter: brightness(1.4);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                filter: brightness(1);
            }
        }
        
        @keyframes floatImage {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        @keyframes glowPulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }
        
        @keyframes particleFloat0 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(100px) translateY(-100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat1 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(100px) translateY(100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat2 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-100px) translateY(100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat3 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-100px) translateY(-100px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat4 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(0) translateY(-120px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat5 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(120px) translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat6 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(0) translateY(120px);
                opacity: 1;
            }
        }
        
        @keyframes particleFloat7 {
            0%, 100% {
                transform: translate(-50%, -50%) translateX(0) translateY(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) translateX(-120px) translateY(0);
                opacity: 1;
            }
        }
        
        .game-over-title {
            font-size: clamp(30px, 8vw, 60px);
            margin-bottom: 30px;
            text-shadow: 
                3px 3px 0px #8b4513,
                6px 6px 0px #5d2f0d,
                0 0 30px rgba(255, 102, 0, 0.8);
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        .victory { color: #ffcc00; }
        .defeat { color: #ff3333; }
        
        .game-over-score {
            font-size: clamp(16px, 3vw, 24px);
            color: #cccccc;
            margin-bottom: 40px;
        }
        
        .discount-code {
            margin: 60px 0 20px 0;
            padding: 12px 30px;
            background: linear-gradient(135deg, #2a1a4e 0%, #1a0e2e 100%);
            border: 3px solid #9d4edd;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(157, 78, 221, 0.4);
            display: inline-block;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        /* 勝利時的折扣碼樣式 - 金色 */
        .discount-code.winner {
            background: linear-gradient(135deg, #4a3f1a 0%, #2e2410 100%);
            border: 3px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        /* 失敗時的折扣碼樣式 - 紅色 */
        .discount-code.fighter {
            background: linear-gradient(135deg, #4a1a1a 0%, #2e1010 100%);
            border: 3px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }
        
        .discount-code:hover {
            transform: scale(1.1);
        }
        
        .code-label {
            font-size: clamp(10px, 1.5vw, 12px);
            color: #c77dff;
            margin-bottom: 4px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .discount-code.winner .code-label {
            color: #ffeb3b;
        }
        
        .discount-code.fighter .code-label {
            color: #ff6b6b;
        }
        
        .code-value {
            font-size: clamp(12px, 2vw, 16px);
            color: #e0aaff;
            text-shadow: 2px 2px 0px #000;
            letter-spacing: 2px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .discount-code.winner .code-value {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        
        .discount-code.fighter .code-value {
            color: #ff6666;
            text-shadow: 0 0 10px rgba(255, 102, 102, 0.7);
        }
        
        .button-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        
        .restart-btn {
            background: linear-gradient(180deg, #4a3c28 0%, #2e2416 100%);
            border: 3px solid #8b6914;
            padding: 20px 50px;
            font-size: clamp(16px, 3vw, 22px);
            color: #ffcc66;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .template-btn {
            background: linear-gradient(180deg, #2e4a3c 0%, #1a2e24 100%);
            border: 3px solid #14898b;
            padding: 12px 30px;
            font-size: clamp(12px, 2vw, 16px);
            color: #66ffcc;
            text-shadow: 2px 2px 0px #000;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            transition: all 0.3s;
        }
        
        .restart-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.9);
        }
        
        .template-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(102, 255, 204, 0.8);
        }
        
        /* UI面板 */
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            z-index: 100;
        }
        
        .ui-panel {
            background: rgba(42, 36, 22, 0.9);
            border: 2px solid #8b6914;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: #1a1410;
            border: 2px solid #8b6914;
            margin: 5px 0;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3333, #ff6666);
            transition: width 0.3s;
        }
        
        .boss-health-fill {
            background: linear-gradient(90deg, #9933ff, #cc66ff);
        }
        
        /* 手機控制 */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 5px;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 0 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 100%);
            padding-bottom: 5px;
            padding-top: 10px;
        }
        
        .mobile-controls-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 500px;
            margin: 0 auto;
        }
        
        /* 左手方向控制區 */
        .left-controls {
            position: relative;
            width: 150px;
            height: 150px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(139, 105, 20, 0.7);
            border: 3px solid #ffcc66;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        /* 方向按鈕位置 */
        .control-btn.btn-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .control-btn.btn-left {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        .control-btn.btn-right {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }
        
        /* 右手攻擊按鈕 */
        .control-btn.btn-attack {
            width: 80px;
            height: 80px;
            font-size: 36px;
            position: relative;
        }
        
        .control-btn:active {
            background: rgba(255, 204, 102, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .control-btn.btn-up:active {
            transform: translateX(-50%) scale(0.95);
        }
        
        .control-btn.btn-left:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .control-btn.btn-right:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #mobileControls {
                display: block !important;
            }
            
            #gameContainer {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #000;
                width: 100vw;
                height: 100vh;
                padding: 0;
                margin: 0;
            }
            
            /* 橫向模式的遊戲結束畫面 */
            .extra-content {
                margin-top: 60px !important;
                gap: 20px !important;
            }
            
            #gameOverScreen {
                padding: 10px;
            }
            
            .game-over-title {
                margin-bottom: 15px;
            }
            
            .game-over-score {
                margin-bottom: 20px;
            }
            
            #gameCanvas {
                border: none;
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }
            
            #gameUI {
                font-size: 10px;
                display: none; /* 隱藏UI避免干擾 */
            }
            
            .ui-panel {
                padding: 3px 5px;
                background: rgba(0, 0, 0, 0.7);
            }
            
            .health-bar {
                width: 80px;
                height: 12px;
            }
            
            .control-btn {
                opacity: 0.8;
                width: 45px;
                height: 45px;
                font-size: 18px;
                background: rgba(139, 105, 20, 0.6);
            }
            
            .control-btn.btn-attack {
                width: 55px;
                height: 55px;
                font-size: 24px;
            }
            
            .control-btn:active {
                opacity: 0.9;
            }
        }
        
        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer {
                display: none !important;
            }
        }
        
        /* 手機版遊戲結束畫面 */
        @media (max-width: 768px) {
            #gameOverScreen {
                padding: 20px;
            }
            
            .game-over-title {
                font-size: clamp(24px, 6vw, 36px);
                margin-bottom: 20px;
            }
            
            .game-over-score {
                font-size: clamp(14px, 3vw, 18px);
                margin-bottom: 30px;
            }
            
            .restart-btn {
                width: 100%;
                max-width: 280px;
                padding: 15px 30px;
                font-size: clamp(14px, 3vw, 18px);
                margin: 0 auto;
                display: block;
            }
            
            /* 手機版改為垂直排列 */
            .extra-content {
                flex-direction: column !important;
                gap: 20px !important;
                margin-top: 60px !important;
            }
            
            .template-btn {
                width: 100%;
                max-width: 200px;
                padding: 12px 25px;
                font-size: clamp(12px, 3vw, 16px);
                margin: 0 auto;
            }
            
            .discount-code {
                width: 100%;
                max-width: 200px;
                padding: 12px 25px;
                margin: 0 auto;
            }
            
            .code-label {
                font-size: clamp(10px, 2.5vw, 12px);
                margin-bottom: 8px;
            }
            
            .code-value {
                font-size: clamp(12px, 3vw, 16px);
            }
        }
    </style>
    
    <!-- Microsoft Clarity 數據分析追蹤碼 -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "t38s0rk3ln");
    </script>
</head>
<body>
    <!-- 音效與音樂 -->
    <audio id="menuBGM" loop preload="auto">
        <source src="audio/menu-bgm.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameBGM" loop preload="auto">
        <source src="audio/level1-bgm.mp3" type="audio/mpeg">
    </audio>
    
    <!-- 手機橫向提示 -->
    <div id="rotatePrompt">
        <div class="rotate-icon">📱</div>
        <div class="rotate-text">
            請旋轉裝置<br>
            使用橫向模式遊玩
        </div>
    </div>
    
    <!-- 開始畫面 -->
    <div id="startScreen">
        <div class="title-container">
            <h1 class="game-title">VIBE CODING</h1>
            <h1 class="game-title" style="font-size: clamp(20px, 5vw, 40px); margin-top: -10px;">DUNGEON</h1>
        </div>
        <div class="button-container">
            <button class="dungeon-btn" onclick="startGame()">開始冒險</button>
            <button class="dungeon-btn music-btn" onclick="playMenuMusic()" style="margin-top: 10px; font-size: 12px;">🎵 播放音樂</button>
        </div>
        <div class="music-hint" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center;">
            <p style="color: #ffcc66; font-size: 10px; opacity: 0.8; animation: pulse 2s infinite;">
                點擊任意處開啟音樂
            </p>
        </div>
    </div>
    
    <!-- 遊戲容器 -->
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <!-- UI介面 -->
        <div id="gameUI">
            <div class="ui-panel">
                <div>HP: <span id="playerHP">100/100</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="playerHealthBar" style="width: 100%"></div>
                </div>
                <div>連擊: <span id="combo">0</span></div>
            </div>
            
            <div class="ui-panel">
                <div>時間: <span id="gameTime">00:00</span></div>
                <div>分數: <span id="score">0</span></div>
            </div>
            
            <div class="ui-panel">
                <div>BOSS HP: <span id="bossHP">500/500</span></div>
                <div class="health-bar">
                    <div class="health-fill boss-health-fill" id="bossHealthBar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <!-- 手機控制 -->
        <div id="mobileControls">
            <div class="mobile-controls-container">
                <div style="display: flex; gap: 10px;">
                    <button class="control-btn" data-key="ArrowLeft">←</button>
                    <button class="control-btn" data-key="ArrowUp">↑</button>
                    <button class="control-btn" data-key="ArrowRight">→</button>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="control-btn btn-attack" data-key=" ">⚔</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 引導視窗 -->
    <div id="guideWindow">
        <h2 class="guide-title">遊戲指南</h2>
        <div class="guide-content">
            勇敢的冒險者，歡迎來到 Vibe Coding 地下城！
            擊敗寶箱怪物，證明你的實力！
        </div>
        <div class="guide-controls">
            <div class="control-key">←→</div>
            <div class="control-desc">移動</div>
            <div class="control-key">↑</div>
            <div class="control-desc">跳躍</div>
            <div class="control-key">空白鍵</div>
            <div class="control-desc">攻擊</div>
            <div class="control-key">F</div>
            <div class="control-desc">切換全螢幕</div>
            <div class="control-key">ESC</div>
            <div class="control-desc">退出全螢幕</div>
        </div>
        <button class="guide-close" onclick="closeGuide()">開始戰鬥</button>
    </div>
    
    <!-- 遊戲結束畫面 -->
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">VICTORY!</h1>
        <div class="game-over-score">最終分數: <span id="finalScore">0</span></div>
        
        <!-- 再次挑戰按鈕 -->
        <div style="margin-top: 40px;">
            <button class="restart-btn" onclick="restartGame()">再次挑戰</button>
        </div>
        
        <!-- 折扣碼和簡報模板區塊 -->
        <div class="extra-content" style="margin-top: 100px; display: flex; align-items: center; justify-content: center; gap: 40px; flex-wrap: wrap;">
            <div class="discount-code" id="discountCode" style="margin: 0;">
                <div class="code-label">折扣碼:</div>
                <div class="code-value" id="codeValue">WINNER</div>
            </div>
            <button class="template-btn" onclick="openTemplate()">簡報模板</button>
        </div>
    </div>
    
    <script>
// 創建火焰粒子效果
function createFireParticles() {
    const startScreen = document.getElementById('startScreen');
    
    setInterval(() => {
        const particle = document.createElement('div');
        particle.className = 'fire-particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 3 + 's';
        particle.style.width = Math.random() * 4 + 2 + 'px';
        particle.style.height = particle.style.width;
        startScreen.appendChild(particle);
        
        setTimeout(() => particle.remove(), 3000);
    }, 200);
}

// 頁面載入時創建火焰效果
window.addEventListener('load', () => {
    createFireParticles();
    checkOrientation();
    
    // 設置一次性點擊監聽器來播放音樂
    let musicStarted = false;
    const startMusic = () => {
        if (!musicStarted) {
            const menuBGM = document.getElementById('menuBGM');
            menuBGM.volume = 0.5;  // 提高到50%音量
            menuBGM.play().then(() => {
                console.log('背景音樂開始播放');
                // 更新音樂按鈕狀態
                const musicBtn = document.querySelector('.music-btn');
                if (musicBtn) {
                    musicBtn.textContent = '🔇 靜音';
                }
                // 隱藏提示文字
                const hint = document.querySelector('.music-hint');
                if (hint) {
                    hint.style.display = 'none';
                }
            }).catch(err => {
                console.log('音樂播放失敗:', err);
            });
            musicStarted = true;
            // 移除監聽器
            document.removeEventListener('click', startMusic);
            document.removeEventListener('keydown', startMusic);
            document.removeEventListener('touchstart', startMusic);
        }
    };
    
    // 監聽任何用戶互動（mousemove 不會觸發音頻播放）
    document.addEventListener('click', startMusic);
    document.addEventListener('keydown', startMusic);
    document.addEventListener('touchstart', startMusic);
    
    // 額外嘗試：滑鼠移動時顯示更明顯的提示
    document.addEventListener('mousemove', () => {
        if (!musicStarted) {
            const hint = document.querySelector('.music-hint p');
            if (hint) {
                hint.style.fontSize = '12px';
                hint.style.opacity = '1';
                setTimeout(() => {
                    hint.style.fontSize = '10px';
                    hint.style.opacity = '0.8';
                }, 200);
            }
        }
    }, { once: true });
});

// 播放主選單音樂
function playMenuMusic() {
    const menuBGM = document.getElementById('menuBGM');
    const musicBtn = event.target;
    
    if (menuBGM.paused) {
        menuBGM.volume = 0.5;  // 提高到50%音量
        menuBGM.play().then(() => {
            musicBtn.textContent = '🔇 靜音';
        }).catch(err => {
            console.log('無法播放音樂:', err);
        });
    } else {
        menuBGM.pause();
        musicBtn.textContent = '🎵 播放音樂';
    }
}

// 檢測螢幕方向
function checkOrientation() {
    const rotatePrompt = document.getElementById('rotatePrompt');
    
    if (isMobile()) {
        // 檢查是否為直向
        if (window.innerHeight > window.innerWidth) {
            rotatePrompt.classList.add('show');
        } else {
            rotatePrompt.classList.remove('show');
        }
    } else {
        rotatePrompt.classList.remove('show');
    }
}

// 監聽方向改變
window.addEventListener('orientationchange', checkOrientation);
window.addEventListener('resize', checkOrientation);

// 開始遊戲
function startGame() {
    const startScreen = document.getElementById('startScreen');
    const gameContainer = document.getElementById('gameContainer');
    const guideWindow = document.getElementById('guideWindow');
    
    // 首次點擊時播放主選單音樂（如果還沒播放）
    const menuBGM = document.getElementById('menuBGM');
    const gameBGM = document.getElementById('gameBGM');
    
    if (menuBGM.paused) {
        menuBGM.volume = 0.5;  // 提高到50%音量
        menuBGM.play().catch(err => {
            console.log('無法播放主選單音樂:', err);
        });
    }
    
    // 短暫延遲後淡出主選單音樂
    setTimeout(() => {
        let fadeOutInterval = setInterval(() => {
            if (menuBGM.volume > 0.02) {
                menuBGM.volume -= 0.02;
            } else {
                menuBGM.pause();
                menuBGM.currentTime = 0;
                clearInterval(fadeOutInterval);
            }
        }, 20);
    }, 500);
    
    // 淡出開始畫面
    startScreen.classList.add('fadeOut');
    
    setTimeout(() => {
        startScreen.style.display = 'none';
        gameContainer.classList.add('active');
        
        // 初始化遊戲
        initializeGame();
        
        // 自動進入全螢幕
        if (!isMobile()) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('無法自動進入全螢幕:', err);
                });
            }
        }
        
        // 顯示引導視窗
        setTimeout(() => {
            // 不需要設置角色位置，直接使用初始位置
            
            guideWindow.classList.add('show');
            // 暫停遊戲直到引導關閉（首次遊戲）
            if (game) {
                game.paused = true;
                console.log('遊戲暫停，等待引導關閉');
            }
        }, 500);
    }, 1000);
}

// 顯示引導
function showGuide() {
    document.getElementById('guideWindow').classList.add('show');
    if (game) game.paused = true;
}

// 關閉引導
function closeGuide() {
    document.getElementById('guideWindow').classList.remove('show');
    if (game && player && boss) {
        // 不需要入場動畫，保持原位
        
        // 開始播放遊戲音樂
        const gameBGM = document.getElementById('gameBGM');
        gameBGM.volume = 0;
        gameBGM.play().then(() => {
            // 淡入遊戲音樂
            let fadeInInterval = setInterval(() => {
                if (gameBGM.volume < 0.5) {
                    gameBGM.volume += 0.02;
                } else {
                    gameBGM.volume = 0.5;  // 提高到50%音量
                    clearInterval(fadeInInterval);
                }
            }, 20);
        }).catch(err => {
            console.log('無法播放遊戲音樂:', err);
        });
        
        // 立即解除暫停，讓入場動畫開始
        game.paused = false;
        console.log('遊戲開始！角色入場中...');
        
        // 延遲顯示開始提示
        setTimeout(() => {
            showGameMessage('FIGHT!', 1000);
        }, 500);
    }
}

// 全螢幕切換
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
}

// 顯示遊戲結束畫面
function showGameOverScreen(victory) {
    const screen = document.getElementById('gameOverScreen');
    const title = document.getElementById('gameOverTitle');
    const finalScore = document.getElementById('finalScore');
    const codeValue = document.getElementById('codeValue');
    const discountCode = document.getElementById('discountCode');
    
    // 停止遊戲音樂
    const gameBGM = document.getElementById('gameBGM');
    let fadeOutInterval = setInterval(() => {
        if (gameBGM.volume > 0.02) {
            gameBGM.volume -= 0.02;
        } else {
            gameBGM.pause();
            gameBGM.currentTime = 0;
            clearInterval(fadeOutInterval);
        }
    }, 20);
    
    if (victory) {
        title.textContent = 'VICTORY!';
        title.className = 'game-over-title victory';
        codeValue.textContent = 'WINNER';
        discountCode.className = 'discount-code winner';
    } else {
        title.textContent = 'DEFEAT';
        title.className = 'game-over-title defeat';
        codeValue.textContent = 'FIGHTER';
        discountCode.className = 'discount-code fighter';
    }
    
    finalScore.textContent = game ? game.score : 0;
    screen.classList.add('show');
    
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
}

// 開啟簡報模板
function openTemplate() {
    // 根據折扣碼決定開啟哪個連結
    const codeValue = document.getElementById('codeValue').textContent;
    
    if (codeValue === 'WINNER') {
        // 勝利時開啟 winner 連結
        window.open('https://lihi.cc/op2ya', '_blank');
    } else if (codeValue === 'FIGHTER') {
        // 失敗時開啟 fighter 連結
        window.open('https://lihi.cc/YCw6a', '_blank');
    } else {
        // 預設連結（以防萬一）
        window.open('https://lihi.cc/QRztO', '_blank');
    }
}

// 預載入禮盒音效
const giftSounds = {};
function preloadGiftSounds() {
    const soundFiles = {
        'invincible': 'Assets/Audio/GiftBox/gift_invincible.mp3',
        'speed': 'Assets/Audio/GiftBox/gift_speed.mp3',
        'vampire': 'Assets/Audio/GiftBox/gift_vampire.mp3',
        'cursed': 'Assets/Audio/GiftBox/gift_cursed.mp3'
    };
    
    for (const [key, path] of Object.entries(soundFiles)) {
        giftSounds[key] = new Audio(path);
        giftSounds[key].volume = 1.0;  // 調整為最大音量
        giftSounds[key].load();
        console.log('Preloading gift sound:', key, path);
    }
}

// 重新開始遊戲
function restartGame() {
    // 停止當前遊戲循環
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
    
    // 隱藏遊戲結束畫面
    document.getElementById('gameOverScreen').classList.remove('show');
    
    // 重置時間
    lastTime = 0;
    
    // 重置飛機系統
    airplane = null;
    airplaneSpawned = false;
    
    // 重置禮盒系統
    giftBoxSystem.triggered = false;
    giftBoxSystem.dropTimer = 0;
    
    // 清理舊的 Three.js buff 特效容器
    if (game && game.buffEffectContainer) {
        game.buffEffectContainer.remove();
    }
    
    // 重新初始化遊戲
    initializeGame();
    
    // ⭐ 關鍵修復：直接開始遊戲，跳過引導
    setTimeout(() => {
        if (game && player && boss) {
            // 確保Boss狀態完全重置
            boss.health = boss.maxHealth;
            boss.phase = 1;
            boss.state = 'chest';
            boss.aiState = 'approach';
            boss.updateHealth();
            
            // 確保玩家血量重置
            player.health = player.maxHealth;
            player.combo = 0;
            player.updateHealth();
            
            // 設置角色入場動畫
            player.x = -50;
            player.targetX = 100;
            boss.x = 850;  // 修正：直接使用數值
            boss.targetX = 400;
            
            // 確保遊戲開始
            game.paused = false;
            game.gameOver = false;
            game.victory = false;
            game.score = 0;
            game.updateUI();
            
            // 重新播放遊戲音樂
            const gameBGM = document.getElementById('gameBGM');
            gameBGM.volume = 0;
            gameBGM.play().then(() => {
                // 淡入遊戲音樂
                let fadeInInterval = setInterval(() => {
                    if (gameBGM.volume < 0.5) {
                        gameBGM.volume += 0.02;
                    } else {
                        gameBGM.volume = 0.5;  // 提高到50%音量
                        clearInterval(fadeInInterval);
                    }
                }, 20);
            }).catch(err => {
                console.log('無法播放遊戲音樂:', err);
            });
            
            // 顯示開始訊息
            setTimeout(() => {
                showGameMessage('ROUND 2!', 1000);
            }, 500);
        }
    }, 200);
}

// 顯示遊戲訊息
function showGameMessage(message, duration) {
    if (!game || !game.ctx) return;
    
    const startTime = Date.now();
    const originalRender = game.render.bind(game);
    
    game.render = function() {
        originalRender();
        
        const elapsed = Date.now() - startTime;
        if (elapsed < duration) {
            const alpha = 1 - (elapsed / duration);
            const scale = 1 + (elapsed / duration) * 0.5;
            
            this.ctx.save();
            this.ctx.fillStyle = `rgba(255, 204, 102, ${alpha})`;
            this.ctx.font = `${30 * scale}px "Press Start 2P"`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(message, this.width/2, this.height/2);
            this.ctx.restore();
        } else {
            game.render = originalRender;
        }
    };
}

// ========== 遊戲引擎 ==========
let game = null;
let player = null;
let boss = null;
let animationId = null;
let gameStartTime = 0;

// 飛機系統
let airplane = null;
let airplaneSpawned = false;

// 禮盒掉落系統全局變數
let giftBoxSystem = {
    triggered: false,
    dropTimer: 0,
    dropInterval: 10  // 10秒間隔
};

function initializeGame() {
    const canvas = document.getElementById('gameCanvas');
    
    // 重置飛機系統
    airplane = null;
    airplaneSpawned = false;
    
    // 預載入禮盒音效
    preloadGiftSounds();
    
    // 清理舊的事件監聽器
    if (window.resizeListener) {
        window.removeEventListener('resize', window.resizeListener);
    }
    if (document.fullscreenListener) {
        document.removeEventListener('fullscreenchange', document.fullscreenListener);
    }
    
    // 設定畫布實際繪圖尺寸
    canvas.width = 800;
    canvas.height = 400;
    
    // 調整畫布大小
    function resizeCanvas() {
        if (isMobile()) {
            // 手機版使用視口尺寸
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            if (window.innerHeight > window.innerWidth) {
                // 直向模式 - 隱藏遊戲畫布
                canvas.style.display = 'none';
            } else {
                // 橫向模式 - 全螢幕顯示
                canvas.style.display = 'block';
                // 使用更大的畫面比例
                const controlHeight = 80; // 控制按鈕高度
                const maxHeight = vh - controlHeight;
                const maxWidth = vw;
                const ratio = Math.min(maxWidth / 800, maxHeight / 400);
                
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
                canvas.style.position = 'absolute';
                canvas.style.left = '50%';
                canvas.style.top = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';
            }
        } else {
            // 桌面版
            if (document.fullscreenElement) {
                // 全螢幕模式
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const ratio = Math.min(vw / 800, vh / 400);
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
            } else {
                // 視窗模式
                const maxWidth = Math.min(1000, window.innerWidth - 40);
                const maxHeight = Math.min(500, window.innerHeight - 150);
                const ratio = Math.min(maxWidth / 800, maxHeight / 400);
                canvas.style.width = (800 * ratio) + 'px';
                canvas.style.height = (400 * ratio) + 'px';
            }
        }
        
        // 更新 Three.js buff 特效容器大小
        if (game && game.buffEffectContainer && game.buffRenderer) {
            // 同步容器大小與 canvas
            game.buffEffectContainer.style.width = canvas.style.width;
            game.buffEffectContainer.style.height = canvas.style.height;
            
            // 獲取實際顯示尺寸
            const displayWidth = parseInt(canvas.style.width) || 800;
            const displayHeight = parseInt(canvas.style.height) || 400;
            
            // 更新 Three.js 渲染器
            game.buffRenderer.setSize(displayWidth, displayHeight);
            
            // 更新相機投影矩陣
            if (game.buffCamera) {
                game.buffCamera.left = 0;
                game.buffCamera.right = game.width;
                game.buffCamera.top = 0;
                game.buffCamera.bottom = game.height;
                game.buffCamera.updateProjectionMatrix();
            }
        }
    }
    
    resizeCanvas();
    
    // 保存事件監聽器引用以便清理
    window.resizeListener = resizeCanvas;
    document.fullscreenListener = resizeCanvas;
    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('fullscreenchange', resizeCanvas);
    
    // 重置遊戲時間
    gameStartTime = Date.now();
    
    // 創建新的遊戲引擎
    game = new GameEngine(canvas);
    
    // 重置遊戲狀態 - 首次遊戲會暫停等待引導
    game.gameOver = false;
    game.paused = false;  // 會在顯示引導時設為true
    game.victory = false;
    
    // 創建新的玩家和Boss
    player = new Player(100, 200);
    window.player = player; // Make player globally accessible for buff effects
    boss = new MimicBoss(400, 200, game);
    
    game.entities = [player, boss];
    
    console.log('Game initialized. Entities:', game.entities.length);
    console.log('Player position:', player.x, player.y);
    console.log('Boss position:', boss.x, boss.y);
    
    // 初始化手機控制
    if (isMobile() || isDebugMode()) {
        initMobileControls();
        console.log('Controls initialized for:', isMobile() ? 'Mobile' : 'Debug mode');
    }
    
    // 開始遊戲循環
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
    lastTime = 0;
    
    // 延遲啟動遊戲循環，確保一切初始化完成
    setTimeout(() => {
        gameLoop();
    }, 100);
}

// 遊戲引擎類
class GameEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        // 關閉圖像平滑，確保像素藝術風格
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.mozImageSmoothingEnabled = false;
        this.ctx.webkitImageSmoothingEnabled = false;
        this.ctx.msImageSmoothingEnabled = false;
        
        this.width = 800;
        this.height = 400;
        
        this.paused = false; // 預設不暫停
        this.gameOver = false;
        this.victory = false;
        
        this.entities = [];
        this.particles = [];
        this.projectiles = [];
        this.textEffects = []; // 文字特效陣列
        
        this.keys = {};
        this.setupInput();
        
        this.score = 0;
        this.level = 1;
        
        // 載入背景
        this.backgroundImage = new Image();
        this.backgroundImage.src = 'Assets/Backgrounds/castle-background.png';
        
        // 初始化 Three.js buff 特效系統
        this.initBuffEffects();
    }
    
    setupInput() {
        document.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            // ESC 鍵退出全螢幕
            if (e.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
            // F 鍵切換全螢幕
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('無法進入全螢幕:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            this.keys[e.key] = false;
        });
    }
    
    update(deltaTime) {
        if (this.paused || this.gameOver) return;
        
        // 更新遊戲時間
        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('gameTime').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // 檢查是否要生成飛機（首次10秒，之後文字消失20秒後）
        if (!airplaneSpawned && !airplane) {
            const currentTime = Date.now() / 1000;
            
            // 初始化首次生成時間
            if (!this.nextAirplaneTime) {
                this.nextAirplaneTime = currentTime + 10; // 首次固定10秒後
            }
            
            if (currentTime >= this.nextAirplaneTime) {
                airplaneSpawned = true;
                airplane = new Airplane(this);
                console.log(`飛機在遊戲進行 ${Math.floor(elapsed)} 秒時生成！`);
                // 下次生成時間會在飛機消失時設定（在Airplane.update中）
            }
        }
        
        // 更新飛機
        if (airplane && airplane.active) {
            airplane.update(deltaTime);
        }
        
        // 更新禮盒掉落系統
        if (giftBoxSystem.triggered) {
            giftBoxSystem.dropTimer += deltaTime;
            
            if (giftBoxSystem.dropTimer >= giftBoxSystem.dropInterval) {
                // 確保玩家還存在再掉落禮盒
                if (player && !this.gameOver) {
                    player.dropGiftBox(this);
                    console.log('Recurring gift box dropped!');
                }
                giftBoxSystem.dropTimer = 0;  // 重置計時器
            }
        }
        
        // 更新實體
        this.entities.forEach(entity => {
            entity.update(deltaTime, this);
        });
        
        // 更新粒子
        this.particles = this.particles.filter(p => {
            p.life -= deltaTime;
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.vy += 500 * deltaTime;
            return p.life > 0;
        });
        
        // 更新文字特效
        this.textEffects = this.textEffects.filter(t => {
            t.life -= deltaTime;
            t.x += t.vx * deltaTime;
            t.y += t.vy * deltaTime;
            t.vy += 50 * deltaTime; // 較慢的向上飄速度
            
            // 根據文字類型調整淡出速度
            const maxLife = t.text === 'ctrl+c' ? 1.3 : 1.5;
            t.opacity = Math.max(0, t.life / maxLife); // 漸漸淡出
            t.scale = 1 + (maxLife - t.life) * 0.3; // 逐漸變大
            
            // 如果有旋轉速度，更新旋轉
            if (t.rotationSpeed) {
                t.rotation += t.rotationSpeed;
            }
            
            return t.life > 0;
        });
        
        // 更新投射物
        this.projectiles = this.projectiles.filter(p => {
            if (p.update) p.update(deltaTime);
            return p.active;
        });
        
        // 碰撞檢測
        this.checkCollisions();
        
        // 更新UI
        this.updateUI();
    }
    
    render() {
        // 繪製背景（包含地板）
        if (this.backgroundImage.complete) {
            this.ctx.drawImage(this.backgroundImage, 0, 0, this.width, this.height);
        } else {
            // 背景圖片未載入時的備用畫面
            this.ctx.fillStyle = '#1a1410';
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = '#2e2416';
            this.ctx.fillRect(0, this.height - 60, this.width, 60);
        }
        
        // 如果暫停，顯示暫停提示
        if (this.paused && !document.getElementById('guideWindow').classList.contains('show')) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.fillStyle = '#ffcc66';
            this.ctx.font = '24px "Press Start 2P"';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('PAUSED', this.width/2, this.height/2);
            this.ctx.textAlign = 'left';
        }
        
        // 繪製實體
        console.log('Rendering entities:', this.entities.length);
        this.entities.forEach(entity => {
            if (entity.render) {
                console.log('Rendering entity at:', entity.x, entity.y);
                entity.render(this.ctx, this);
            }
        });
        
        // 繪製飛機
        if (airplane && airplane.active) {
            airplane.render(this.ctx);
        }
        
        // 繪製投射物
        this.projectiles.forEach(p => {
            if (p.render) p.render(this.ctx);
        });
        
        // 繪製粒子
        this.particles.forEach(p => {
            this.ctx.save();
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, p.size, p.size);
            this.ctx.restore();
        });
        
        // 繪製文字特效
        this.textEffects.forEach(t => {
            this.ctx.save();
            
            // 如果有旋轉，應用旋轉變換
            if (t.rotation) {
                this.ctx.translate(t.x, t.y);
                this.ctx.rotate(t.rotation);
                this.ctx.translate(-t.x, -t.y);
            }
            
            this.ctx.globalAlpha = t.opacity;
            this.ctx.fillStyle = t.color;
            this.ctx.font = `${14 * t.scale}px "Press Start 2P", monospace`; // 像素字體
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            
            // 添加像素風格的輪廓
            this.ctx.strokeStyle = '#000000';
            this.ctx.lineWidth = 2;
            this.ctx.strokeText(t.text, t.x, t.y);
            
            // 繪製文字
            this.ctx.fillText(t.text, t.x, t.y);
            
            this.ctx.restore();
        });
        
        // 更新 Three.js buff 特效
        if (player && this.updateBuffEffects) {
            this.updateBuffEffects(player);
        }
    }
    
    checkCollisions() {
        this.projectiles.forEach(proj => {
            this.entities.forEach(entity => {
                if (proj.owner !== entity && this.isColliding(proj, entity)) {
                    if (entity.takeDamage) {
                        entity.takeDamage(proj.damage);
                        if (proj.owner && proj.owner.onHitConfirmed) {
                            proj.owner.onHitConfirmed(proj.damage);  // 傳遞傷害值給吸血計算
                        }
                        proj.active = false;
                    }
                }
            });
        });
        
        // 檢查玩家與禮盒的碰撞
        this.entities.forEach(entity => {
            if (entity.isGiftBox && player && this.isColliding(player, entity)) {
                entity.collect(player);
            }
        });
    }
    
    isColliding(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }
    
    addParticle(x, y, type) {
        const configs = {
            damage: { color: '#ff3333', size: 4, vx: (Math.random() - 0.5) * 100, vy: -100 },
            dust: { color: '#8b6914', size: 3, vx: (Math.random() - 0.5) * 50, vy: -50 },
            gold: { color: '#ffcc66', size: 5, vx: (Math.random() - 0.5) * 150, vy: -150 },
            heal: { color: '#00ff00', size: 6, vx: (Math.random() - 0.5) * 80, vy: -120 },
            blocked: { color: '#ff00ff', size: 5, vx: (Math.random() - 0.5) * 120, vy: -80 }
        };
        
        const config = configs[type] || configs.damage;
        this.particles.push({
            x, y,
            ...config,
            life: 0.5
        });
    }
    
    // 添加文字特效
    addTextEffect(x, y, text, color = '#ffcc66') {
        // ctrl+c 和 ctrl+v 有稍微不同的動畫
        const isCtrlC = text === 'ctrl+c';
        
        this.textEffects.push({
            x: x + (Math.random() - 0.5) * 10, // 輕微隨機起始位置
            y: y,
            text: text,
            color: color,
            vx: (Math.random() - 0.5) * (isCtrlC ? 40 : 30), // ctrl+c 水平移動更大
            vy: isCtrlC ? -100 : -80, // ctrl+c 向上飄更快
            life: isCtrlC ? 1.3 : 1.5, // ctrl+c 消失更快
            scale: 1,
            opacity: 1,
            rotation: 0, // 新增旋轉屬性
            rotationSpeed: isCtrlC ? (Math.random() - 0.5) * 0.1 : 0 // ctrl+c 有輕微旋轉
        });
    }
    
    updateUI() {
        document.getElementById('score').textContent = this.score;
    }
    
    togglePause() {
        this.paused = !this.paused;
    }
    
    initBuffEffects() {
        // 儲存當前的特效物件
        this.activeBuffEffects = {
            invincible: null,
            speed: null,
            vampire: null
        };
        
        this.buffAnimationTime = 0;
    }
    
    createInvincibleEffect(playerX, playerY) {
        console.log('Creating invincible effect at:', playerX, playerY);
        
        // 移除舊的特效
        if (this.activeBuffEffects.invincible) {
            if (this.activeBuffEffects.invincible.element) {
                document.body.removeChild(this.activeBuffEffects.invincible.element);
            }
            this.activeBuffEffects.invincible = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        // 創建主要群組
        const group = new THREE.Group();
        
        // 調整相機和群組位置
        camera.position.z = 150;
        
        // === 無敵 BUFF 特效設計 ===
        // 主題：「這是一個很棒的想法」 - 完美防護罩
        
        // 1. 能量核心 - 像心臟般跳動的綠色核心
        const coreGeometry = new THREE.IcosahedronGeometry(10, 2);
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff88,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        group.add(core);
        
        // 添加光源來增強效果
        const light = new THREE.PointLight(0x00ff00, 2, 100);
        light.position.set(0, 0, 20);
        scene.add(light);
        
        // 2. 六角形能量護盾 - 科技感防護罩
        const hexagonPoints = [];
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i) / 6;
            hexagonPoints.push(new THREE.Vector2(Math.cos(angle) * 35, Math.sin(angle) * 35));
        }
        const hexShape = new THREE.Shape(hexagonPoints);
        const hexGeometry = new THREE.ShapeGeometry(hexShape);
        
        // 創建多個六角形層
        const hexShields = [];
        for (let i = 0; i < 3; i++) {
            const hexMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(0, 1, 0.5 - i * 0.2),
                transparent: true,
                opacity: 0.2 - i * 0.05,
                side: THREE.DoubleSide
            });
            const hexShield = new THREE.Mesh(hexGeometry, hexMaterial);
            hexShield.position.z = i * 5;
            hexShields.push(hexShield);
            group.add(hexShield);
        }
        
        // 3. 能量流動環 - 顯示能量流動
        const flowRings = [];
        for (let i = 0; i < 4; i++) {
            const ringGeometry = new THREE.TorusGeometry(20 + i * 8, 0.5, 16, 64);
            const ringMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3 - i * 0.05,
                transparent: true,
                opacity: 0.4 - i * 0.1
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = (Math.PI / 2) + (Math.PI / 6) * i;
            ring.rotation.y = (Math.PI / 8) * i;
            flowRings.push(ring);
            group.add(ring);
        }
        
        // 4. 防護粒子系統 - 螺旋上升的能量粒子
        const particleCount = 200;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            // 螺旋分佈
            const t = i / particleCount;
            const angle = t * Math.PI * 8;
            const radius = 15 + t * 25;
            const height = (t - 0.5) * 60;
            
            positions[i * 3] = Math.cos(angle) * radius;
            positions[i * 3 + 1] = height;
            positions[i * 3 + 2] = Math.sin(angle) * radius;
            
            // 漸變綠色
            colors[i * 3] = 0;
            colors[i * 3 + 1] = 0.5 + t * 0.5;
            colors[i * 3 + 2] = 0.2;
            
            // 粒子大小隨高度變化
            sizes[i] = Math.random() * 3 + 1;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.6,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        group.add(particleSystem);
        
        // 5. 外層能量場 - 波動的防護場
        const fieldGeometry = new THREE.SphereGeometry(45, 32, 32);
        const fieldMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ff00) }
            },
            vertexShader: `
                varying vec3 vNormal;
                uniform float time;
                void main() {
                    vNormal = normal;
                    vec3 pos = position;
                    float displacement = sin(pos.x * 10.0 + time) * sin(pos.y * 10.0 + time) * sin(pos.z * 10.0 + time) * 0.5;
                    pos += normal * displacement;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float time;
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                    gl_FragColor = vec4(color, intensity * 0.3);
                }
            `,
            transparent: true,
            side: THREE.BackSide
        });
        const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
        group.add(field);
        
        scene.add(group);
        
        // 儲存所有需要動畫的元素
        const animationData = {
            core,
            hexShields,
            flowRings,
            particleSystem,
            particleCount,
            field,
            light
        };
        
        // 開始動畫循環
        const animate = () => {
            try {
                if (!this.activeBuffEffects.invincible) return;
                
                requestAnimationFrame(animate);
            
            // 動畫效果
            const time = Date.now() * 0.001;
            
            // 核心跳動效果
            const heartbeat = 1 + Math.sin(time * 4) * 0.1;
            animationData.core.scale.set(heartbeat, heartbeat, heartbeat);
            animationData.core.rotation.x += 0.01;
            animationData.core.rotation.y += 0.02;
            
            // 六角形護盾旋轉
            animationData.hexShields.forEach((shield, i) => {
                shield.rotation.z += 0.01 * (i + 1);
                const pulse = 1 + Math.sin(time * 2 + i * 0.5) * 0.05;
                shield.scale.set(pulse, pulse, 1);
            });
            
            // 能量環流動
            animationData.flowRings.forEach((ring, i) => {
                ring.rotation.z += 0.02 * (i % 2 === 0 ? 1 : -1);
                ring.rotation.x += 0.005;
            });
            
            // 粒子螺旋上升
            animationData.particleSystem.rotation.y += 0.01;
            const particlePositions = animationData.particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < animationData.particleCount; i++) {
                particlePositions[i * 3 + 1] += 0.5;
                if (particlePositions[i * 3 + 1] > 30) {
                    particlePositions[i * 3 + 1] = -30;
                }
            }
            animationData.particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // 更新能量場 shader
            animationData.field.material.uniforms.time.value = time;
            
            // 光源脈動
            animationData.light.intensity = 2 + Math.sin(time * 3) * 0.5;
            
            // 更新位置跟隨玩家
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
            } catch (error) {
                console.error('Error in invincible effect animation:', error);
            }
        };
        
        animate();
        
        // 儲存特效資訊
        this.activeBuffEffects.invincible = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    createSpeedEffect(playerX, playerY) {
        // 移除舊的特效
        if (this.activeBuffEffects.speed) {
            if (this.activeBuffEffects.speed.element) {
                document.body.removeChild(this.activeBuffEffects.speed.element);
            }
            this.activeBuffEffects.speed = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        camera.position.z = 150;
        
        const group = new THREE.Group();
        
        // === 速度 BUFF 特效設計 ===
        // 主題：「Run Don't Walk」 - 極速加速
        
        // 1. 速度線特效 - 動態速度線
        const speedLines = new THREE.Group();
        const lineCount = 30;
        const speedLineData = [];
        
        for (let i = 0; i < lineCount; i++) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6); // 2個點形成一條線
            
            const angle = (Math.PI * 2 * i) / lineCount + Math.random() * 0.2;
            const startRadius = 10 + Math.random() * 5;
            const endRadius = 40 + Math.random() * 20;
            
            // 起點
            positions[0] = Math.cos(angle) * startRadius;
            positions[1] = Math.sin(angle) * startRadius;
            positions[2] = (Math.random() - 0.5) * 10;
            
            // 終點
            positions[3] = Math.cos(angle) * endRadius;
            positions[4] = Math.sin(angle) * endRadius;
            positions[5] = (Math.random() - 0.5) * 10;
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // 漸變顏色 - 從亮青到透明白
            const colors = new Float32Array(6);
            colors[0] = 0; colors[1] = 1; colors[2] = 1; // 青色
            colors[3] = 1; colors[4] = 1; colors[5] = 1; // 白色
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: Math.random() * 0.5 + 0.3,
                linewidth: 2,
                blending: THREE.AdditiveBlending
            });
            
            const line = new THREE.Line(geometry, material);
            speedLineData.push({
                line: line,
                speed: Math.random() * 0.5 + 0.5,
                offset: Math.random() * Math.PI * 2
            });
            speedLines.add(line);
        }
        group.add(speedLines);
        
        // 2. 電子軌道環 - 高速旋轉的能量環
        const orbitRings = [];
        for (let i = 0; i < 3; i++) {
            const ringRadius = 25 + i * 10;
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(ringRadius, 0.8, 8, 64),
                new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00aaff,
                    emissiveIntensity: 0.5 - i * 0.1,
                    transparent: true,
                    opacity: 0.6 - i * 0.15
                })
            );
            
            // 不同角度的軌道
            if (i === 0) ring.rotation.x = Math.PI / 2;
            if (i === 1) {
                ring.rotation.x = Math.PI / 3;
                ring.rotation.y = Math.PI / 4;
            }
            if (i === 2) {
                ring.rotation.x = Math.PI / 4;
                ring.rotation.z = Math.PI / 3;
            }
            
            orbitRings.push(ring);
            group.add(ring);
        }
        
        // 3. 速度粒子雲 - 殘影效果
        const trailParticles = [];
        const trailCount = 5;
        
        for (let t = 0; t < trailCount; t++) {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 30;
                particlePositions[i * 3] = Math.cos(angle) * radius;
                particlePositions[i * 3 + 1] = Math.sin(angle) * radius;
                particlePositions[i * 3 + 2] = -t * 5 + (Math.random() - 0.5) * 5;
                
                particleSizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: new THREE.Color(0, 1 - t * 0.1, 1),
                size: 3 - t * 0.5,
                transparent: true,
                opacity: 0.6 - t * 0.1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            trailParticles.push(particles);
            group.add(particles);
        }
        
        // 4. 速度核心 - 高速旋轉的能量核心
        const coreGroup = new THREE.Group();
        
        // 內核
        const innerCore = new THREE.Mesh(
            new THREE.TetrahedronGeometry(8, 2),
            new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            })
        );
        coreGroup.add(innerCore);
        
        // 外核線框
        const outerCore = new THREE.Mesh(
            new THREE.OctahedronGeometry(15, 0),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.4,
                wireframe: true
            })
        );
        coreGroup.add(outerCore);
        group.add(coreGroup);
        
        // 添加速度光源
        const speedLight = new THREE.PointLight(0x00ffff, 2, 100);
        speedLight.position.set(0, 0, 20);
        scene.add(speedLight);
        
        scene.add(group);
        
        // 儲存所有需要動畫的元素
        const animationData = {
            speedLineData,
            orbitRings,
            trailParticles,
            innerCore,
            outerCore,
            speedLight
        };
        
        // 開始動畫循環
        const animate = () => {
            if (!this.activeBuffEffects.speed) return;
            
            requestAnimationFrame(animate);
            
            // 動畫效果
            const time = Date.now() * 0.001;
            
            // 速度線動態流動
            animationData.speedLineData.forEach((data, i) => {
                const line = data.line;
                const positions = line.geometry.attributes.position.array;
                const newAngle = data.offset + time * data.speed;
                
                // 更新線條位置來創造流動效果
                const startRadius = 10 + Math.sin(time * 3 + i) * 5;
                const endRadius = 40 + Math.sin(time * 2 + i) * 10;
                
                positions[0] = Math.cos(newAngle) * startRadius;
                positions[1] = Math.sin(newAngle) * startRadius;
                positions[3] = Math.cos(newAngle) * endRadius;
                positions[4] = Math.sin(newAngle) * endRadius;
                
                line.geometry.attributes.position.needsUpdate = true;
                line.material.opacity = 0.3 + Math.sin(time * 4 + i) * 0.3;
            });
            
            // 軌道環高速旋轉
            animationData.orbitRings.forEach((ring, i) => {
                ring.rotation.z += 0.1 * (i + 1);
                ring.rotation.y += 0.05 * (2 - i);
                const pulse = 1 + Math.sin(time * 5 + i) * 0.1;
                ring.scale.set(pulse, pulse, pulse);
            });
            
            // 殘影粒子流動
            animationData.trailParticles.forEach((particles, t) => {
                particles.rotation.y += 0.02 * (t + 1);
                particles.position.z = -t * 3 + Math.sin(time * 3) * 2;
                particles.material.opacity = 0.6 - t * 0.1 - Math.sin(time * 2) * 0.1;
            });
            
            // 核心高速旋轉
            animationData.innerCore.rotation.x += 0.1;
            animationData.innerCore.rotation.y += 0.15;
            animationData.innerCore.rotation.z += 0.05;
            
            animationData.outerCore.rotation.x -= 0.08;
            animationData.outerCore.rotation.y += 0.12;
            
            // 核心脈動
            const corePulse = 1 + Math.sin(time * 8) * 0.2;
            animationData.innerCore.scale.set(corePulse, corePulse, corePulse);
            
            // 光源閃爍
            animationData.speedLight.intensity = 2 + Math.sin(time * 10) * 1;
            
            // 更新位置跟隨玩家
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
        };
        
        animate();
        
        // 儲存特效資訊
        this.activeBuffEffects.speed = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    createVampireEffect(playerX, playerY) {
        // 移除舊的特效
        if (this.activeBuffEffects.vampire) {
            if (this.activeBuffEffects.vampire.element) {
                document.body.removeChild(this.activeBuffEffects.vampire.element);
            }
            this.activeBuffEffects.vampire = null;
        }
        
        // Convert player canvas coordinates to screen coordinates
        const canvas = document.getElementById('gameCanvas');
        const rect = canvas.getBoundingClientRect();
        const screenX = rect.left + (playerX / 800) * rect.width;
        const screenY = rect.top + (playerY / 400) * rect.height;
        
        // Create a div for the effect centered on player
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.left = (screenX - 100) + 'px';
        effectDiv.style.top = (screenY - 100) + 'px';
        effectDiv.style.width = '200px';
        effectDiv.style.height = '200px';
        effectDiv.style.pointerEvents = 'none';
        effectDiv.style.zIndex = '999';
        document.body.appendChild(effectDiv);
        
        // Initialize Three.js for this effect
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(200, 200);
        effectDiv.appendChild(renderer.domElement);
        
        camera.position.z = 100;
        
        const group = new THREE.Group();
        
        // 紫色吸血光環（縮小尺寸）
        const rings = [];
        for (let i = 0; i < 3; i++) {
            const ringGeometry = new THREE.RingGeometry(25 + i * 8, 28 + i * 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.3 - i * 0.1,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            rings.push(ring);
            group.add(ring);
        }
        
        // 螺旋粒子（縮小尺寸）
        const particleCount = 50;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            const t = i / particleCount * Math.PI * 4;
            const radius = 20 + t * 2;
            positions[i * 3] = Math.cos(t) * radius;
            positions[i * 3 + 1] = t * 3 - 50;
            positions[i * 3 + 2] = Math.sin(t) * radius;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xff00ff,
            size: 3,
            transparent: true,
            opacity: 0.7
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        group.add(particleSystem);
        
        // 添加光源
        const vampireLight = new THREE.PointLight(0xff00ff, 2, 100);
        vampireLight.position.set(0, 0, 50);
        scene.add(vampireLight);
        
        scene.add(group);
        
        // 儲存所有需要動畫的元素（使用實際存在的變數）
        const animationData = {
            rings,           // 使用實際定義的 rings
            particleSystem,  // 使用實際定義的 particleSystem
            particleCount,   // 粒子數量
            vampireLight     // 使用實際定義的 vampireLight
        };
        
        // 開始動畫循環
        const animate = () => {
            if (!this.activeBuffEffects.vampire) return;
            
            requestAnimationFrame(animate);
            
            // 動畫效果
            const time = Date.now() * 0.001;
            
            // 光環旋轉
            animationData.rings.forEach((ring, i) => {
                ring.rotation.z += 0.03 * (i + 1);
                const scale = 1 + Math.sin(time * 2 + i * 0.5) * 0.15;
                ring.scale.set(scale, scale, 1);
            });
            
            // 螺旋粒子動畫
            const positions = animationData.particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < animationData.particleCount; i++) {
                const t = i / animationData.particleCount * Math.PI * 4 + time;
                const radius = 20 + Math.sin(t) * 5;
                positions[i * 3] = Math.cos(t) * radius;
                positions[i * 3 + 1] = Math.sin(time * 2 + i * 0.1) * 10;
                positions[i * 3 + 2] = Math.sin(t) * radius;
            }
            animationData.particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // 整體群組旋轉
            group.rotation.y += 0.02;
            
            // 光源脈動
            animationData.vampireLight.intensity = 2 + Math.sin(time * 4) * 0.8;
            
            // 更新位置跟隨玩家
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const player = window.player;
            if (player) {
                const screenX = rect.left + ((player.x + player.width/2) / 800) * rect.width;
                const screenY = rect.top + ((player.y + player.height/2) / 400) * rect.height;
                effectDiv.style.left = (screenX - 100) + 'px';
                effectDiv.style.top = (screenY - 100) + 'px';
            }
            
            renderer.render(scene, camera);
        };
        
        animate();
        
        // 儲存特效資訊
        this.activeBuffEffects.vampire = {
            element: effectDiv,
            renderer: renderer,
            scene: scene,
            camera: camera
        };
    }
    
    updateBuffEffects(player) {
        // 計算玩家中心位置
        const x = player.x + player.width / 2;
        const y = player.y + player.height / 2;
        
        // 更新或創建對應的特效
        if (player.buffType === 'invincible' && player.invincible) {
            if (!this.activeBuffEffects.invincible) {
                console.log('Player has invincible buff, creating effect...');
                this.createInvincibleEffect(x, y);
            }
        } else if (this.activeBuffEffects.invincible) {
            if (this.activeBuffEffects.invincible.element) {
                document.body.removeChild(this.activeBuffEffects.invincible.element);
            }
            this.activeBuffEffects.invincible = null;
        }
        
        if (player.buffType === 'speed' && player.speedBoost) {
            if (!this.activeBuffEffects.speed) {
                this.createSpeedEffect(x, y);
            }
        } else if (this.activeBuffEffects.speed) {
            if (this.activeBuffEffects.speed.element) {
                document.body.removeChild(this.activeBuffEffects.speed.element);
            }
            this.activeBuffEffects.speed = null;
        }
        
        if (player.buffType === 'vampire' && player.lifeSteal) {
            if (!this.activeBuffEffects.vampire) {
                this.createVampireEffect(x, y);
            }
        } else if (this.activeBuffEffects.vampire) {
            if (this.activeBuffEffects.vampire.element) {
                document.body.removeChild(this.activeBuffEffects.vampire.element);
            }
            this.activeBuffEffects.vampire = null;
        }
    }
    
}

// 玩家類
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 96;  // 改為 96x96
        this.height = 96; // 改為 96x96
        
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.vx = 0;
        this.vy = 0;
        this.speed = 250;
        this.baseSpeed = 250;  // 基礎速度
        this.jumpPower = 450;
        this.grounded = false;
        this.facing = 1;  // 1=右, -1=左
        
        this.combo = 0;
        this.attackCooldown = 0;
        this.baseAttackCooldown = 0.5;  // 基礎攻擊冷卻
        
        // Buff 系統
        this.invincible = false;
        this.speedBoost = false;
        this.doubleAttack = false;
        this.lifeSteal = false;
        this.buffTimer = 0;
        this.buffType = null;
        this.attackMultiplier = 1;
        
        // 動畫系統
        this.animations = {
            attack: [],
            idle: [],
            walk: [],
            jump: [],
            hurt: []
        };
        this.currentAnimation = 'idle';  // 預設顯示待機動畫
        this.animationFrame = 0;
        this.animationTimer = 0;
        this.animationSpeed = 0.08; // 每幀0.08秒
        
        // 載入動畫
        this.loadAnimations();
    }
    
    loadAnimations() {
        // 載入攻擊動畫 (4幀)
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `Assets/Player/Sprites/Attack/player_attack_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded player attack frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load player attack frame ${i}`);
            };
            this.animations.attack.push(img);
        }
        
        // 載入待機動畫 (只使用單一幀 idle-1.png)
        const idleImg = new Image();
        idleImg.src = 'Assets/Player/Sprites/Idle/idle-1.png';
        idleImg.onload = () => {
            console.log('Loaded player idle frame');
        };
        idleImg.onerror = () => {
            console.error('Failed to load player idle frame');
        };
        this.animations.idle.push(idleImg);
        
        // 載入行走動畫 (6幀)
        for (let i = 1; i <= 6; i++) {
            const walkImg = new Image();
            walkImg.src = `Assets/Player/Sprites/Walk/player_walk_frame${i}.png`;
            walkImg.onload = () => {
                console.log(`Loaded player walk frame ${i}`);
            };
            walkImg.onerror = () => {
                console.error(`Failed to load player walk frame ${i}`);
            };
            this.animations.walk.push(walkImg);
        }
    }
    
    update(deltaTime, game) {
        // 安全檢查 deltaTime
        if (!deltaTime || isNaN(deltaTime)) {
            deltaTime = 0.016; // 預設 60fps
        }
        
        // 更新 Buff 計時器
        if (this.buffTimer > 0) {
            this.buffTimer -= deltaTime;
            
            // Buff 結束處理
            if (this.buffTimer <= 0) {
                this.endBuff();
            }
        }
        
        
        // 入場動畫
        if (this.targetX !== undefined) {
            const dx = this.targetX - this.x;
            if (Math.abs(dx) > 5) {
                this.x += dx * 0.1;
            } else {
                this.x = this.targetX;
                delete this.targetX;
            }
        }
        
        // 輸入處理
        if (!this.targetX && game.keys['ArrowLeft']) {
            this.vx = -this.speed;
            this.facing = -1;
        } else if (!this.targetX && game.keys['ArrowRight']) {
            this.vx = this.speed;
            this.facing = 1;
        } else {
            this.vx *= 0.8;
        }
        
        if (game.keys['ArrowUp'] && this.grounded) {
            this.vy = -this.jumpPower;
            this.grounded = false;
        }
        
        if (game.keys[' '] && this.attackCooldown <= 0) {
            this.attack(game);
        }
        
        // 物理
        this.vy += 800 * deltaTime;
        
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        
        // 邊界
        this.x = Math.max(0, Math.min(this.x, game.width - this.width));
        
        // 地面
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
        
        // 更新冷卻
        if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
        }
        
        // 更新UI
        this.updateHealth();
        document.getElementById('combo').textContent = this.combo;
        
        // 更新動畫
        this.updateAnimation(deltaTime);
    }
    
    playAnimation(animationName) {
        if (this.currentAnimation !== animationName) {
            this.currentAnimation = animationName;
            this.animationFrame = 0;
            this.animationTimer = 0;
        }
    }
    
    updateAnimation(deltaTime) {
        // 決定要播放的動畫
        if (this.attackCooldown <= 0) {  // 沒有在攻擊時
            if (Math.abs(this.vx) > 10 && this.grounded) {
                // 在地面上移動時播放行走動畫
                if (this.currentAnimation !== 'walk') {
                    this.playAnimation('walk');
                }
            } else if (Math.abs(this.vx) < 10 && this.grounded) {
                // 在地面上靜止時播放待機動畫
                if (this.currentAnimation !== 'idle') {
                    this.playAnimation('idle');
                }
            }
        }
        
        if (!this.currentAnimation || !this.animations[this.currentAnimation]) return;
        
        const frames = this.animations[this.currentAnimation];
        if (frames.length === 0) return;
        
        this.animationTimer += deltaTime;
        
        if (this.animationTimer >= this.animationSpeed) {
            this.animationTimer = 0;
            this.animationFrame++;
            
            // 攻擊動畫播放完畢，切換到待機或行走
            if (this.currentAnimation === 'attack' && this.animationFrame >= frames.length) {
                if (Math.abs(this.vx) > 10 && this.grounded) {
                    this.playAnimation('walk');
                } else {
                    this.playAnimation('idle');
                }
            }
            
            // 行走動畫循環
            if (this.currentAnimation === 'walk' && this.animationFrame >= frames.length) {
                this.animationFrame = 0;
            }
            
            // Idle 動畫 (單一幀，不需要循環)
            if (this.currentAnimation === 'idle') {
                this.animationFrame = 0;  // 始終保持在第一幀
            }
        }
    }
    
    attack(game) {
        // 速度加成時攻擊速度也加快
        this.attackCooldown = this.speedBoost ? this.baseAttackCooldown / 2.5 : this.baseAttackCooldown;
        
        // 播放攻擊動畫
        if (this.animations.attack.length > 0) {
            this.playAnimation('attack');
        }
        
        const baseDamage = 10;
        const attackBox = {
            x: this.x + (this.facing === 1 ? this.width : -20),
            y: this.y + 20,
            width: 20,
            height: this.height - 40,
            damage: baseDamage * this.attackMultiplier,  // 應用攻擊倍率
            owner: this,
            active: true,
            life: 0.3,  // 增加攻擊判定時間從0.1秒到0.3秒
            lifeSteal: this.lifeSteal,  // 傳遞吸血屬性
            
            update(deltaTime) {
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // 攻擊判定框不顯示視覺效果
            }
        };
        
        game.projectiles.push(attackBox);
    }
    
    onHitConfirmed(damage) {
        this.combo++;
        game.score += 10 * this.combo;
        
        // 顯示 "ctrl+c" 或 "ctrl+v" 文字特效（隨機）
        if (game && game.addTextEffect) {
            // 隨機選擇文字（70% ctrl+v, 30% ctrl+c）
            const textOptions = ['ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+v', 'ctrl+c', 'ctrl+c', 'ctrl+c'];
            const randomText = textOptions[Math.floor(Math.random() * textOptions.length)];
            
            // 根據狀態選擇顏色
            let textColor = '#ffcc66'; // 預設黃色
            if (this.buffType === 'vampire') {
                textColor = '#ff00ff'; // 吸血時紫色
            } else if (this.buffType === 'invincible') {
                textColor = '#00ff00'; // 無敵時綠色
            } else if (this.buffType === 'speed') {
                textColor = '#00ffff'; // 加速時青色
            } else if (this.combo > 5) {
                textColor = '#ff6600'; // 高連擊時橙色
            }
            
            // ctrl+c 時可以用稍微不同的顏色變化
            if (randomText === 'ctrl+c' && textColor === '#ffcc66') {
                textColor = '#66ccff'; // ctrl+c 預設時用淺藍色
            }
            
            // 在玩家上方顯示文字
            game.addTextEffect(
                this.x + this.width/2, 
                this.y - 20, 
                randomText, 
                textColor
            );
        }
        
        // 吸血效果
        if (this.lifeSteal && damage) {
            this.health = Math.min(this.health + damage, this.maxHealth);
            this.updateHealth();
            // 顯示吸血效果
            game.addParticle(this.x + this.width/2, this.y, 'heal');
        }
    }
    
    // 應用 Buff 效果
    applyBuff(buffType) {
        this.buffType = buffType;
        this.buffTimer = 10; // 10秒持續時間（除了被祖）
        
        switch(buffType) {
            case 'invincible':
                // "這是一個很棒的想法" - 無敵10秒
                this.invincible = true;
                break;
                
            case 'speed':
                // "Run Don't walk" - 速度2.5倍
                this.speedBoost = true;
                this.speed = this.baseSpeed * 2.5;
                break;
                
            case 'vampire':
                // "複製貼上" - 攻擊力1.5倍+吸血
                this.doubleAttack = true;
                this.lifeSteal = true;
                this.attackMultiplier = 1.5;
                break;
                
            case 'cursed':
                // "被祖了" - 直接死亡
                this.buffTimer = 0;
                setTimeout(() => {
                    this.health = 0;
                    this.updateHealth();
                    game.gameOver = true;
                    showGameOverScreen(false);
                }, 100);
                break;
        }
    }
    
    // 結束 Buff 效果
    endBuff() {
        if (this.buffType === 'invincible') {
            // 無敵結束後補滿血
            this.health = this.maxHealth;
            this.updateHealth();
        }
        
        // 重置所有 buff 狀態
        this.invincible = false;
        this.speedBoost = false;
        this.speed = this.baseSpeed;
        this.doubleAttack = false;
        this.lifeSteal = false;
        this.attackMultiplier = 1;
        this.buffType = null;
    }
    
    // 掉落禮盒的通用方法
    dropGiftBox(game) {
        // 隨機位置掉落（避免太靠近邊緣）
        const x = Math.random() * (game.width - 100) + 50;
        const y = -50;  // 從天空掉落
        
        const giftBox = new GiftBox(x, y, game);
        game.entities.push(giftBox);
        
        // 顯示掉落提示
        game.addParticle(x + 25, y + 60, 'gold');
        console.log('Gift box dropped at:', x, y);
    }
    
    takeDamage(damage) {
        // 無敵狀態不受傷害
        if (this.invincible) {
            return;
        }
        
        const oldHealth = this.health;
        this.health -= damage;
        this.health = Math.max(0, this.health);
        this.combo = 0;
        
        // 檢查是否觸發禮盒掉落（血量首次降到50%或以下）
        if (!giftBoxSystem.triggered && oldHealth > this.maxHealth * 0.5 && this.health <= this.maxHealth * 0.5) {
            giftBoxSystem.triggered = true;
            giftBoxSystem.dropTimer = 0;  // 重置計時器
            this.dropGiftBox(game);
            console.log('First gift box triggered! Recurring drops every 10 seconds.');
        }
        
        this.updateHealth();
        
        if (this.health <= 0) {
            game.gameOver = true;
            showGameOverScreen(false);
        }
    }
    
    updateHealth() {
        const percent = (this.health / this.maxHealth) * 100;
        document.getElementById('playerHP').textContent = `${this.health}/${this.maxHealth}`;
        document.getElementById('playerHealthBar').style.width = percent + '%';
    }
    
    render(ctx) {
        ctx.save();
        
        // Buff 剩餘時間顯示（Three.js 特效在 GameEngine 中處理）
        if (this.buffType && this.buffTimer > 0) {
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(Math.ceil(this.buffTimer) + 's', this.x + this.width/2, this.y - 10);
            ctx.restore();
        }
        
        // 優先顯示動畫（攻擊或待機）
        if (this.currentAnimation && this.animations[this.currentAnimation].length > 0) {
            const frames = this.animations[this.currentAnimation];
            const frameIndex = Math.min(this.animationFrame, frames.length - 1);
            const currentFrame = frames[frameIndex];
            
            if (currentFrame && currentFrame.complete && currentFrame.width > 0) {
                ctx.save();
                if (this.facing === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(currentFrame, -this.x - this.width, this.y, this.width, this.height);
                } else {
                    ctx.drawImage(currentFrame, this.x, this.y, this.width, this.height);
                }
                ctx.restore();
                ctx.restore();
                return; // 顯示動畫後直接返回
            }
        }
        
        // 如果沒有當前動畫，嘗試顯示待機圖片
        if (!this.currentAnimation && this.animations.idle.length > 0) {
            const idleFrame = this.animations.idle[0];
            if (idleFrame && idleFrame.complete && idleFrame.width > 0) {
                ctx.save();
                if (this.facing === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(idleFrame, -this.x - this.width, this.y, this.width, this.height);
                } else {
                    ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                }
                ctx.restore();
                ctx.restore();
                return; // 顯示待機圖片後直接返回
            }
        }
        
        // 鏡像處理 - 面向左時翻轉（只在沒有動畫時使用）
        if (this.facing === -1) {
            ctx.scale(-1, 1);
            ctx.translate(-this.x * 2 - this.width, 0);
        }
        
        // 放大2倍的騎士造型（沒有動畫時顯示）
        // 頭盔
        ctx.fillStyle = '#999999';
        ctx.fillRect(this.x + 16, this.y + 8, 32, 32);
        
        // 眼睛縫隙
        ctx.fillStyle = '#333333';
        ctx.fillRect(this.x + 22, this.y + 18, 8, 3);
        ctx.fillRect(this.x + 34, this.y + 18, 8, 3);
        
        // 身體(盔甲)
        ctx.fillStyle = '#cccccc';
        ctx.fillRect(this.x + 16, this.y + 40, 32, 32);
        
        // 盔甲細節
        ctx.fillStyle = '#999999';
        ctx.fillRect(this.x + 28, this.y + 45, 8, 20);
        
        // 腿
        ctx.fillStyle = '#777777';
        ctx.fillRect(this.x + 20, this.y + 72, 10, 24);
        ctx.fillRect(this.x + 34, this.y + 72, 10, 24);
        
        // 劍 (攻擊時顯示) - 調整顯示時間以配合新的攻擊窗口
        if (this.attackCooldown > 0.2) {  // 從0.3改為0.2，讓劍顯示更久
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(this.x + 48, this.y + 36, 24, 6);
            ctx.fillRect(this.x + 72, this.y + 32, 6, 16);
            // 劍柄
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(this.x + 44, this.y + 36, 8, 6);
        }
        
        ctx.restore();
    }
}

// Boss類
// 飛機類
class Airplane {
    constructor(game) {
        this.game = game;
        this.x = -100; // 從畫面左側外開始
        // 高度固定在畫面最上方（留一點邊距）
        this.y = 30; // 固定在上方30像素處
        
        this.width = 80;
        this.height = 60;
        this.speed = 100; // 飛行速度（像素/秒）
        this.image = new Image();
        this.image.src = 'Assets/Items/airplane.png';
        this.active = true;
        
        // 文字設置
        this.text = "《像素地下城簡報模板 9/5 上架》";
        this.textOffset = 5; // 文字緊貼飛機後面
        this.textTrail = []; // 文字軌跡效果
    }

    update(deltaTime) {
        if (!this.active) return;
        
        // 從左向右飛行
        this.x += this.speed * deltaTime;
        
        // 計算文字的實際寬度（估計文字寬度約為350像素）
        const textWidth = 350;
        
        // 當文字完全離開右側畫面時，標記為非活動
        // 飛機位置 - 文字偏移 - 文字寬度 > 畫面寬度
        if (this.x - this.textOffset - textWidth > this.game.canvas.width) {
            this.active = false;
            airplane = null; // 清除全局引用
            airplaneSpawned = false; // 允許再次生成
            
            // 記錄文字消失的時間，並設定下次出現時間（至少20秒後）
            const currentTime = Date.now() / 1000;
            const nextDelay = Math.random() * 5 + 20; // 20-25秒隨機
            this.game.nextAirplaneTime = currentTime + nextDelay;
            console.log(`飛機文字已完全消失，將在 ${Math.floor(nextDelay)} 秒後再次出現`);
        }
    }

    render(ctx) {
        if (!this.active) return;
        
        ctx.save();
        
        // 繪製跟隨文字（在飛機後面）
        const textX = this.x - this.textOffset;
        const textY = this.y + this.height / 2;
        
        // 文字軌跡效果
        ctx.font = 'bold 14px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        
        // 文字發光陰影
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // 文字漸變效果
        const textGradient = ctx.createLinearGradient(textX - 300, textY - 10, textX - 300, textY + 10);
        textGradient.addColorStop(0, '#FFD700');
        textGradient.addColorStop(0.5, '#FFA500');
        textGradient.addColorStop(1, '#FF6347');
        
        // 繪製文字外框
        ctx.strokeStyle = '#2C3E50';
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, textX, textY);
        
        // 繪製文字主體
        ctx.fillStyle = textGradient;
        ctx.fillText(this.text, textX, textY);
        
        // 重置陰影
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // 如果圖片已載入，繪製飛機
        if (this.image.complete && this.image.naturalHeight !== 0) {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        } else {
            // 備用：繪製簡單的飛機形狀
            ctx.fillStyle = '#888';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#666';
            ctx.fillRect(this.x + this.width * 0.7, this.y + this.height * 0.3, this.width * 0.3, this.height * 0.4);
            // 機翼
            ctx.fillStyle = '#777';
            ctx.fillRect(this.x + this.width * 0.2, this.y + this.height * 0.4, this.width * 0.5, this.height * 0.2);
        }
        
        ctx.restore();
    }
}

class MimicBoss {
    constructor(x, y, game) {
        this.x = x;
        this.y = y;
        this.width = 128;  // 放大
        this.height = 128; // 放大
        this.game = game;
        
        this.maxHealth = 500;
        this.health = this.maxHealth;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.facing = -1; // 預設面向左
        
        this.phase = 1;
        this.state = 'chest';
        this.attackCooldown = 0;
        
        // 受傷僵直系統
        this.hurtStunTime = 0;  // 受傷僵直時間
        this.maxHurtStun = 0.3;  // 最大僵直時間
        this.comboTaken = 0;  // 被連擊次數
        this.maxComboBeforeEscape = 7;  // 被連擊7次後觸發逃脫
        this.escaping = false;  // 是否正在逃脫
        
        // 智能AI系統
        this.aiState = 'analyze'; // analyze, approach, attack, retreat, jump, escape_corner, stalk, rush, defensive, wait
        this.aiTimer = 0;
        this.dodgeChance = 0.3;
        this.jumpAttackChance = 0.2;
        this.stuckTimer = 0;  // 檢測是否卡住
        this.lastX = x;  // 記錄上一次位置
        this.cornerEscapeTimer = 0;  // 角落逃脫計時器
        
        // 智能決策參數
        this.aggressiveness = 0.5; // 攻擊性 0-1
        this.caution = 0.5; // 謹慎度 0-1
        this.lastPlayerHealth = 100; // 追蹤玩家血量變化
        this.decisionCooldown = 0; // 決策冷卻
        this.currentTactic = null; // 當前戰術
        this.tacticTimer = 0; // 戰術計時器
        
        // 動畫系統
        this.animations = {
            attack: [],
            closing: []  // 閉合動畫
        };
        this.currentAnimation = null;
        this.animationFrame = 0;
        this.animationTimer = 0;
        this.animationSpeed = 0.1; // 每幀0.1秒
        this.isClosing = false; // 是否正在播放閉合動畫
        this.isTransforming = false; // 是否正在變身
        
        // 載入攻擊動畫
        this.loadAnimations();
    }
    
    loadAnimations() {
        // 載入待機動畫（偽裝狀態）
        this.animations.idle = [];
        const idleImg = new Image();
        idleImg.src = 'Assets/Boss/MimicBoss/Sprites/Idle/Idle_Disguise.png';
        idleImg.onload = () => {
            console.log('Loaded Boss idle disguise animation:', idleImg.width, 'x', idleImg.height);
        };
        idleImg.onerror = () => {
            console.error('Failed to load Boss idle disguise animation');
        };
        this.animations.idle.push(idleImg);
        
        // 載入覺醒狀態待機動畫（HP > 50%）
        this.animations.awakenedIdle = [];
        for (let i = 1; i <= 2; i++) {
            const awakenedIdleImg = new Image();
            awakenedIdleImg.src = `Assets/Boss/MimicBoss/Sprites/Awakened/Idle/awakened_idle_frame${i}.png`;
            awakenedIdleImg.onload = () => {
                console.log(`Loaded awakened idle frame ${i}`);
            };
            awakenedIdleImg.onerror = () => {
                console.error(`Failed to load awakened idle frame ${i}`);
            };
            this.animations.awakenedIdle.push(awakenedIdleImg);
        }
        
        // 載入覺醒狀態受傷動畫
        this.animations.awakenedHurt = [];
        const awakenedHurtImg = new Image();
        awakenedHurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Awakened/Hurt/awakened_hurt_frame1.png';
        awakenedHurtImg.onload = () => {
            console.log('Loaded awakened hurt animation');
        };
        awakenedHurtImg.onerror = () => {
            console.error('Failed to load awakened hurt animation');
        };
        this.animations.awakenedHurt.push(awakenedHurtImg);
        
        // 載入覺醒狀態移動動畫（5幀）
        this.animations.awakenedMovement = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Awakened/Movement/awakened_move_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded awakened movement frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load awakened movement frame ${i}`);
            };
            this.animations.awakenedMovement.push(img);
        }
        
        // 載入第三階段待機動畫（變身後使用）- 6幀動畫
        this.animations.idlePhase3 = [];
        for (let i = 1; i <= 6; i++) {
            const idlePhase3Img = new Image();
            idlePhase3Img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/Idle/phase3_idle_frame${i}.png`;
            idlePhase3Img.onload = () => {
                console.log(`Loaded Phase3 idle frame ${i}`);
            };
            idlePhase3Img.onerror = () => {
                console.error(`Failed to load Phase3 idle frame ${i}`);
                // 如果載入失敗，嘗試使用備用圖片
                if (i === 1) {
                    idlePhase3Img.src = 'Assets/Boss/MimicBoss/Sprites/Idle/Idle_Disguise.png';
                }
            };
            this.animations.idlePhase3.push(idlePhase3Img);
        }
        
        // 載入7幀攻擊動畫 (從新的組織路徑)
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            this.animations.attack.push(img);
        }
        
        // 載入第三階段攻擊動畫
        this.animations.attackPhase3 = [];
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_phase3_frame${i}.png`;
            img.onerror = () => {
                // 如果沒有Phase3專用圖片，使用原本的
                img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            };
            this.animations.attackPhase3.push(img);
        }
        
        // 最後3幀作為閉合動畫 (5, 6, 7是箱子閉合的動作)
        for (let i = 5; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Attack/boss_attack_frame${i}.png`;
            this.animations.closing.push(img);
        }
        
        // 載入第三階段移動動畫 (5幀)
        this.animations.movementPhase3 = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/Movement/phase3_move_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded phase 3 movement frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load phase 3 movement frame ${i}`);
            };
            this.animations.movementPhase3.push(img);
        }
        
        // 載入第三階段火球連射動畫 (7幀)
        this.animations.fireballBarrage = [];
        for (let i = 1; i <= 7; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Phase3/FireballBarrage/fireball_barrage_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded fireball barrage frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load fireball barrage frame ${i}`);
            };
            this.animations.fireballBarrage.push(img);
        }
        
        // 載入咬擊動畫 (4幀)
        this.animations.bite = [];
        for (let i = 1; i <= 4; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Bite/boss_bite_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded boss bite frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load boss bite frame ${i}`);
            };
            this.animations.bite.push(img);
        }
        
        // 載入變身動畫 (Phase2 -> Phase3 變身)
        this.animations.transform = [];
        for (let i = 1; i <= 9; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Transform/micmic_transform_frame_${i}.png`;
            img.onload = () => {
                console.log(`Loaded Boss transform frame ${i}: ${img.src}, size: ${img.width}x${img.height}`);
            };
            img.onerror = () => {
                console.error(`Failed to load Boss transform frame ${i}: ${img.src}`);
                // 嘗試備用路徑
                img.src = `Assets/Boss/MimicBoss/Sprites/Transform/mimic_transform_frame_${i}.png`;
                img.onerror = () => {
                    console.error(`Also failed backup path for frame ${i}`);
                };
            };
            this.animations.transform.push(img);
        }
        
        // 載入死亡動畫 (5幀)
        this.animations.death = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `Assets/Boss/MimicBoss/Sprites/Death/death_frame${i}.png`;
            img.onload = () => {
                console.log(`Loaded death animation frame ${i}`);
            };
            img.onerror = () => {
                console.error(`Failed to load death animation frame ${i}`);
            };
            this.animations.death.push(img);
        }
        
        // 載入第二階段受傷動畫
        this.animations.phase2Hurt = [];
        const phase2HurtImg = new Image();
        phase2HurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Phase2/Hurt/phase2_hurt_frame1.png';
        phase2HurtImg.onload = () => {
            console.log('Loaded Phase 2 hurt animation');
        };
        phase2HurtImg.onerror = () => {
            console.error('Failed to load Phase 2 hurt animation');
        };
        this.animations.phase2Hurt.push(phase2HurtImg);
        
        // 載入第三階段受傷動畫
        this.animations.phase3Hurt = [];
        const phase3HurtImg = new Image();
        phase3HurtImg.src = 'Assets/Boss/MimicBoss/Sprites/Phase3/Hurt/phase3_hurt_frame1.png';
        phase3HurtImg.onload = () => {
            console.log('Loaded Phase 3 hurt animation');
        };
        phase3HurtImg.onerror = () => {
            console.error('Failed to load Phase 3 hurt animation');
        };
        this.animations.phase3Hurt.push(phase3HurtImg);
        
        // 初始化特殊動畫標記（這些動畫使用程式繪製）
        this.animations.hit = 'programmatic';
        // death 現在有實際動畫了，不再是programmatic
        // movement 第一階段現在也有實際動畫了
        // movementPhase3 有實際的圖片動畫，不需要標記為programmatic
        
        console.log('Boss animations loaded - Idle:', this.animations.idle.length, 'frames, Attack:', this.animations.attack.length, 'frames, Closing:', this.animations.closing.length, 'frames, Transform:', this.animations.transform.length, 'frames');
    }
    
    playAnimation(animationName) {
        // 對於程式化動畫，只設定狀態（movement現在大部分都有實際動畫）
        if (animationName === 'movement' && this.state !== 'monster') {
            // 只有未覺醒時才使用程式化效果
            this.currentAnimation = animationName;
            this.animationTimer = 0;
            return;
        }
        
        // 處理受傷動畫
        if (animationName === 'hit') {
            // 第三階段使用第三階段受傷動畫
            if (this.phase === 3 && this.animations.phase3Hurt && this.animations.phase3Hurt.length > 0) {
                this.currentAnimation = 'phase3Hurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // 受傷動畫速度
                return;
            }
            // 第二階段（變身中）使用第二階段受傷動畫
            else if (this.phase === 2 && this.animations.phase2Hurt && this.animations.phase2Hurt.length > 0) {
                this.currentAnimation = 'phase2Hurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // 受傷動畫速度
                return;
            }
            // 覺醒狀態（HP > 50%）使用覺醒受傷動畫
            else if (this.phase === 1 && this.state === 'monster' && this.animations.awakenedHurt && this.animations.awakenedHurt.length > 0) {
                this.currentAnimation = 'awakenedHurt';
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.animationSpeed = 0.15; // 受傷動畫速度
                return;
            } else {
                // 備用：使用程式化受傷動畫
                this.currentAnimation = animationName;
                this.animationTimer = 0;
                return;
            }
        }
        
        // 第三階段使用不同的動畫
        if (this.phase === 3) {
            if (animationName === 'attack' && this.animations.attackPhase3) {
                animationName = 'attackPhase3';
            }
            // 火球連射動畫直接使用
            if (animationName === 'fireballBarrage' && this.animations.fireballBarrage) {
                // 火球連射有專屬動畫
            }
        }
        
        if (this.animations[animationName] && this.animations[animationName].length > 0) {
            this.currentAnimation = animationName;
            this.animationFrame = 0;
            this.animationTimer = 0;
            
            // 針對不同動畫設定不同速度
            if (animationName === 'transform') {
                this.animationSpeed = 0.12; // 變身動畫速度
                // 設定自定義幀序列：每幀重複3次 1-1-1-2-2-2-3-3-3...
                this.transformFrameSequence = [];
                for (let i = 0; i < 9; i++) {
                    // 每幀重複3次
                    this.transformFrameSequence.push(i, i, i);
                }
                this.transformFrameIndex = 0;
                // 設定初始幀
                this.animationFrame = this.transformFrameSequence[0];
                console.log('Transform animation started with sequence:', this.transformFrameSequence, 'First frame:', this.animationFrame);
            } else if (animationName === 'attack' || animationName === 'attackPhase3') {
                this.animationSpeed = 0.08; // 攻擊動畫較快
            } else if (animationName === 'awakenedMovement') {
                this.animationSpeed = 0.1; // 覺醒移動動畫
            } else if (animationName === 'movementPhase3') {
                this.animationSpeed = 0.08; // 第三階段移動動畫較快
            } else if (animationName === 'fireballBarrage') {
                this.animationSpeed = 0.1; // 火球連射動畫
            } else if (animationName === 'bite') {
                this.animationSpeed = 0.12; // 咬擊動畫
            } else if (animationName === 'death') {
                this.animationSpeed = 0.15; // 死亡動畫稍慢
            } else {
                this.animationSpeed = 0.1; // 預設速度
            }
        }
    }
    
    updateAnimation(deltaTime) {
        if (!this.currentAnimation) return;
        
        // 累加動畫計時器
        this.animationTimer += deltaTime;
        
        // 處理程式化動畫（但不包括movementPhase3和death）
        if (this.currentAnimation === 'hit' || 
            (this.currentAnimation === 'movement' && this.phase !== 3)) {
            // 這些動畫的結束條件在 render 函數中處理
            return;
        }
        
        // 處理覺醒受傷動畫
        if (this.currentAnimation === 'awakenedHurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // 受傷動畫只播放一次
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // 處理第二階段受傷動畫
        if (this.currentAnimation === 'phase2Hurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // 受傷動畫只播放一次
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // 處理第三階段受傷動畫
        if (this.currentAnimation === 'phase3Hurt') {
            if (this.animationTimer >= this.animationSpeed) {
                // 受傷動畫只播放一次
                this.currentAnimation = null;
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            return;
        }
        
        // 處理覺醒移動動畫
        if (this.currentAnimation === 'awakenedMovement') {
            // 檢查是否還在移動，如果停止了就切換到待機動畫
            if (Math.abs(this.vx) < 10) {
                // 切換到覺醒待機動畫
                if (this.animations.awakenedIdle && this.animations.awakenedIdle.length > 0) {
                    this.playAnimation('awakenedIdle');
                } else {
                    this.currentAnimation = null;
                    this.animationFrame = 0;
                    this.animationTimer = 0;
                }
            }
            // 不要立即返回，讓動畫幀可以更新
        }
        
        // 處理第三階段移動動畫
        if (this.currentAnimation === 'movementPhase3') {
            // 檢查是否還在移動，如果停止了就切換到待機動畫
            if (Math.abs(this.vx) < 10) {
                // 切換到第三階段待機動畫
                if (this.phase === 3 && this.animations.idlePhase3 && this.animations.idlePhase3.length > 0) {
                    this.playAnimation('idlePhase3');
                } else {
                    this.currentAnimation = null;
                    this.animationFrame = 0;
                    this.animationTimer = 0;
                }
            }
            // 不要立即返回，讓動畫幀可以更新
        }
        
        // 處理幀動畫
        if (this.animations[this.currentAnimation]) {
            if (this.animationTimer >= this.animationSpeed) {
                this.animationTimer = 0;
                
                // 特殊處理變身動畫的幀序列
                if (this.currentAnimation === 'transform' && this.transformFrameSequence) {
                    this.transformFrameIndex++;
                    if (this.transformFrameIndex >= this.transformFrameSequence.length) {
                        // 變身動畫播放完畢
                        this.currentAnimation = null;
                        this.animationFrame = 0;
                        this.transformFrameIndex = 0;
                        this.transformFrameSequence = null;
                        console.log('Transform animation completed!');
                    } else {
                        // 使用自定義幀序列
                        this.animationFrame = this.transformFrameSequence[this.transformFrameIndex];
                        console.log(`Transform frame: ${this.animationFrame + 1} (sequence index: ${this.transformFrameIndex})`);
                    }
                } else {
                    // 一般動畫的處理
                    this.animationFrame++;
                    
                    // 動畫循環或結束
                    if (this.animationFrame >= this.animations[this.currentAnimation].length) {
                        if (this.currentAnimation === 'attack' || this.currentAnimation === 'attackPhase3') {
                            // 攻擊動畫播放完畢，開始閉合動畫
                            this.playAnimation('closing');
                            this.isClosing = true;
                        } else if (this.currentAnimation === 'closing') {
                            // 閉合動畫播放完畢
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                            this.isClosing = false;
                        } else if (this.currentAnimation === 'awakenedMovement' || this.currentAnimation === 'movementPhase3') {
                            // 移動動畫循環播放
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'idlePhase3' || this.currentAnimation === 'awakenedIdle') {
                            // 待機動畫循環播放
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'death') {
                            // 死亡動畫播放完畢後停在最後一幀
                            this.animationFrame = this.animations.death.length - 1;
                            // 可以觸發遊戲結束
                            if (this.onDeathComplete) {
                                this.onDeathComplete();
                            }
                        } else if (this.currentAnimation === 'fireballBarrage') {
                            // 火球連射動畫播放完畢，回到null讓AI決定下一步
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                        } else if (this.currentAnimation === 'bite') {
                            // 咬擊動畫播放完畢，回到null
                            this.currentAnimation = null;
                            this.animationFrame = 0;
                        }
                    }
                }
            }
        }
    }
    
    update(deltaTime, game) {
        // 安全檢查 deltaTime
        if (!deltaTime || isNaN(deltaTime)) {
            deltaTime = 0.016; // 預設 60fps
        }
        
        // 更新動畫
        this.updateAnimation(deltaTime);
        
        // 如果正在死亡，停止所有其他行為
        if (this.state === 'dying' || this.currentAnimation === 'death') {
            this.vx = 0;
            // 保持重力但不允許其他移動
            this.vy += 1200 * deltaTime;
            this.vy = Math.min(this.vy, 800);
            this.y += this.vy * deltaTime;
            
            // 地面
            if (this.y + this.height >= game.height - 60) {
                this.y = game.height - 60 - this.height;
                this.vy = 0;
                this.grounded = true;
            }
            return; // 不執行其他更新
        }
        
        // 入場動畫
        if (this.targetX !== undefined) {
            const dx = this.targetX - this.x;
            if (Math.abs(dx) > 5) {
                this.x += dx * 0.1;
            } else {
                this.x = this.targetX;
                delete this.targetX;
            }
        }
        
        // 物理
        this.vy += 1200 * deltaTime;
        this.vy = Math.min(this.vy, 800);
        
        if (!this.targetX) {
            this.x += this.vx * deltaTime;
        }
        this.y += this.vy * deltaTime;
        
        // 地面
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
        
        // 邊界
        this.x = Math.max(0, Math.min(this.x, game.width - this.width));
        
        // 智能AI系統 (變身期間停止所有AI行為)
        if (this.state === 'monster' && player && !this.isTransforming) {
            const dx = player.x + player.width/2 - (this.x + this.width/2);
            const dy = player.y - this.y;
            const distance = Math.abs(dx);
            const realDistance = Math.sqrt(dx * dx + dy * dy);
            
            // 分析遊戲狀態並更新戰術
            this.analyzeGameState(player, realDistance, game);
            
            // 更新決策冷卻
            if (this.decisionCooldown > 0) {
                this.decisionCooldown -= deltaTime;
            }
            
            // 檢測是否卡住
            if (Math.abs(this.x - this.lastX) < 5) {
                this.stuckTimer += deltaTime;
                // 如果停止移動且沒有在執行其他動畫，播放待機動畫
                if (Math.abs(this.vx) < 10 && !this.currentAnimation) {
                    if (this.phase === 3 && this.animations.idlePhase3 && this.animations.idlePhase3.length > 0) {
                        this.playAnimation('idlePhase3');
                    } else if (this.state === 'monster' && this.health > this.maxHealth * 0.5 && 
                               this.animations.awakenedIdle && this.animations.awakenedIdle.length > 0) {
                        this.playAnimation('awakenedIdle');
                    }
                }
            } else {
                this.stuckTimer = 0;
                // 如果正在移動，播放移動動畫
                if (Math.abs(this.vx) > 10) {
                    // 檢查是否需要切換到移動動畫
                    if (this.phase === 3) {
                        // 第三階段用movementPhase3動畫
                        if (this.currentAnimation !== 'movementPhase3' && 
                            this.currentAnimation !== 'attack' && 
                            this.currentAnimation !== 'attackPhase3' &&
                            this.currentAnimation !== 'fireballBarrage' &&
                            this.currentAnimation !== 'transform') {
                            this.playAnimation('movementPhase3');
                        }
                    } else if (this.phase === 1 && this.state === 'monster') {
                        // 第一階段覺醒狀態用awakenedMovement動畫
                        if (this.currentAnimation !== 'awakenedMovement' && 
                            this.currentAnimation !== 'attack' && 
                            this.currentAnimation !== 'closing' && 
                            this.currentAnimation !== 'transform') {
                            this.playAnimation('awakenedMovement');
                        }
                    } else if (!this.currentAnimation || 
                               (this.currentAnimation !== 'attack' && 
                                this.currentAnimation !== 'closing' && 
                                this.currentAnimation !== 'transform')) {
                        // 其他情況（如未覺醒）暫時用movement
                        this.playAnimation('movement');
                    }
                }
            }
            this.lastX = this.x;
            
            // 檢測是否在角落
            const isInCorner = this.isInCorner(game);
            const isStuck = this.stuckTimer > 1.5; // 1.5秒沒移動就算卡住
            
            // 優先處理卡住或角落狀況
            if ((isInCorner || isStuck) && this.aiState !== 'escape_corner') {
                this.aiState = 'escape_corner';
                this.cornerEscapeTimer = 2; // 2秒逃脫時間
                this.stuckTimer = 0;
            }
            
            // 更新面向（但在逃脫角落時可能需要反向）
            if (this.aiState !== 'escape_corner') {
                this.facing = dx > 0 ? 1 : -1;  // 玩家在右邊時面向右
            }
            
            // AI狀態機
            this.aiTimer -= deltaTime;
            this.cornerEscapeTimer -= deltaTime;
            
            switch(this.aiState) {
                case 'escape_corner':
                    // 逃脫角落邏輯
                    this.escapeCorner(game, deltaTime);
                    break;
                
                case 'rush':
                    // 快速追擊（用於終結低血量玩家）
                    const rushSpeed = 280 * this.aggressiveness;
                    this.vx = dx > 0 ? rushSpeed : -rushSpeed;
                    
                    // 積極跳躍追擊
                    if (Math.abs(dy) > 30 && this.grounded && Math.random() < 0.1) {
                        this.vy = -550;
                        this.grounded = false;
                    }
                    
                    if (distance < 150) {
                        this.aiState = 'attack';
                        this.aiTimer = 0.3;
                    }
                    break;
                
                case 'stalk':
                    // 謹慎跟隨（保持中距離）
                    const idealDistance = 250;
                    if (distance > idealDistance + 50) {
                        this.vx = dx > 0 ? 120 : -120;
                    } else if (distance < idealDistance - 50) {
                        this.vx = dx > 0 ? -80 : 80;
                    } else {
                        this.vx *= 0.7;
                    }
                    
                    // 等待時機
                    if (player.buffType === 'cursed' || player.health < player.maxHealth * 0.3) {
                        this.aiState = 'rush';
                    }
                    break;
                
                case 'defensive':
                    // 防禦模式（躲避玩家）
                    if (distance < 200) {
                        this.vx = dx > 0 ? -150 : 150;
                        
                        // 跳躍躲避
                        if (this.grounded && Math.random() < 0.05) {
                            this.vy = -400;
                            this.grounded = false;
                        }
                    } else {
                        this.vx *= 0.8;
                    }
                    
                    // 等待buff結束
                    if (!player.buffType || player.buffType === 'cursed') {
                        this.aiState = 'approach';
                    }
                    break;
                    
                case 'approach':
                    // 接近玩家（根據階段調整速度）
                    if (distance > 200) {
                        // 基礎速度根據階段調整
                        let baseSpeed = 150;
                        if (this.phase === 3) {
                            baseSpeed = 220; // 第三階段更快
                        } else if (this.state === 'monster') {
                            baseSpeed = 180; // 覺醒後稍快
                        }
                        this.vx = dx > 0 ? baseSpeed : -baseSpeed;
                        
                        // 智能跳躍追擊 - 增加條件避免卡牆
                        const shouldJump = Math.abs(dy) > 50 && this.grounded && Math.random() < 0.03;
                        const notNearWall = this.x > 50 && this.x < game.width - 50 - this.width;
                        
                        if (shouldJump && notNearWall) {
                            this.vy = -400;
                            this.grounded = false;
                        }
                        
                        // 如果長時間無法接近，改變策略
                        if (this.aiTimer < -5) {
                            this.aiState = 'jump';
                            this.aiTimer = 1;
                        }
                    } else {
                        this.aiState = 'attack';
                        this.aiTimer = 0.5;
                    }
                    break;
                    
                case 'attack':
                    this.vx *= 0.8;
                    
                    if (this.attackCooldown <= 0) {
                        // 根據階段選擇攻擊模式
                        if (this.phase === 3) {
                            // 第三階段 - 最激進
                            if (Math.random() < this.jumpAttackChance) {
                                // 跳躍攻擊
                                if (this.grounded) {
                                    this.vy = -500;
                                    this.grounded = false;
                                }
                            }
                            this.attack(game);
                            this.attackCooldown = 1.2;
                        } else {
                            // 第一階段 - 正常攻擊
                            this.attack(game);
                            this.attackCooldown = 2;
                        }
                        
                        // 攻擊後決定下一步
                        if (distance < 100) {
                            this.aiState = 'retreat';
                            this.aiTimer = 1;
                        } else {
                            this.aiState = 'approach';
                        }
                    }
                    break;
                    
                case 'retreat':
                    // 後退保持距離 - 智能後退避免卡角落
                    const retreatDirection = this.getRetreatDirection(dx, game);
                    this.vx = retreatDirection * 120;
                    
                    if (this.aiTimer <= 0 || distance > 300) {
                        this.aiState = 'approach';
                        this.aiTimer = 2;
                    }
                    
                    // 後退時可能閃避 - 但避免跳到角落
                    const canJumpSafely = this.x > 100 && this.x < game.width - 100 - this.width;
                    if (Math.random() < this.dodgeChance * 0.01 && this.grounded && canJumpSafely) {
                        this.vy = -350;
                        this.grounded = false;
                    }
                    break;
                    
                case 'jump':
                    // 跳躍狀態 - 主動跳躍到更好位置
                    if (this.grounded) {
                        // 跳躍到玩家附近
                        const targetX = player.x + (Math.random() - 0.5) * 200;
                        const clampedTargetX = Math.max(100, Math.min(targetX, game.width - 100));
                        
                        this.vx = (clampedTargetX - this.x) > 0 ? 200 : -200;
                        this.vy = -500;
                        this.grounded = false;
                        this.aiState = 'approach';
                        this.aiTimer = 1;
                    }
                    break;
            }
            
            // 第三階段增強（變身後）
            if (this.phase === 3) {
                this.vx *= 1.5; // 移動速度提升50%
                this.dodgeChance = 0.5; // 閃避機率提升
            } else if (this.phase === 1 && this.state === 'monster' && this.health > this.maxHealth * 0.5) {
                // 覺醒階段（HP > 50%）也有一定增強
                this.vx *= 1.2; // 移動速度提升20%
                this.dodgeChance = 0.35; // 閃避機率略微提升
            }
        }
        
        if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
        }
        
        // 更新受傷僵直
        if (this.hurtStunTime > 0) {
            this.hurtStunTime -= deltaTime;
            // 僵直期間無法動作
            return;
        }
        
        // 從受傷狀態恢復
        if (this.aiState === 'hurt' && this.hurtStunTime <= 0) {
            this.aiState = 'approach';  // 恢復後立即反擊
            this.aiTimer = 0.2;
            // 如果沒有被連擊，重置計數器
            if (this.comboTaken < 3) {
                this.comboTaken = 0;
            }
        }
    }
    
    // 檢測是否在角落
    isInCorner(game) {
        const margin = 80;
        const nearLeftWall = this.x < margin;
        const nearRightWall = this.x > game.width - this.width - margin;
        const nearGround = this.y > game.height - 120;
        
        return (nearLeftWall || nearRightWall) && nearGround;
    }
    
    // 獲取智能後退方向
    getRetreatDirection(dx, game) {
        const margin = 80;
        const nearLeftWall = this.x < margin;
        const nearRightWall = this.x > game.width - this.width - margin;
        
        if (nearLeftWall) {
            return 1; // 向右移動離開左牆
        } else if (nearRightWall) {
            return -1; // 向左移動離開右牆
        } else {
            // 正常後退邏輯
            return dx > 0 ? -1 : 1;
        }
    }
    
    // 逃脫角落的邏輯
    escapeCorner(game, deltaTime) {
        if (this.cornerEscapeTimer <= 0) {
            this.aiState = 'approach';
            this.aiTimer = 1;
            return;
        }
        
        const centerX = game.width / 2;
        const margin = 100;
        
        // 計算到中心的方向
        let targetX = centerX;
        
        // 如果玩家不在中心附近，選擇一個安全位置
        if (player) {
            if (Math.abs(player.x - centerX) < 150) {
                // 玩家在中心，選擇離玩家較遠的安全位置
                targetX = player.x > centerX ? margin : game.width - margin - this.width;
            }
        }
        
        const directionToTarget = targetX - this.x;
        
        // 移動到目標位置
        if (Math.abs(directionToTarget) > 20) {
            this.vx = directionToTarget > 0 ? 200 : -200;
            this.facing = directionToTarget > 0 ? 1 : -1;
        } else {
            this.vx = 0;
        }
        
        // 跳躍脫離角落
        if (this.grounded && Math.random() < 0.05) {
            this.vy = -450;
            this.grounded = false;
        }
        
        // 如果成功逃脫角落
        if (!this.isInCorner(game)) {
            this.aiState = 'approach';
            this.aiTimer = 1;
            this.cornerEscapeTimer = 0;
        }
    }
    
    // 智能AI分析系統
    analyzeGameState(player, distance, game) {
        const playerHealthPercent = player.health / player.maxHealth;
        const bossHealthPercent = this.health / this.maxHealth;
        
        // 檢測玩家buff狀態
        const hasInvincible = player.buffType === 'invincible';
        const hasSpeed = player.buffType === 'speed';
        const hasVampire = player.buffType === 'vampire';
        const isCursed = player.buffType === 'cursed';
        
        // 位置分析
        const playerInCorner = player.x < 100 || player.x > game.width - 100 - player.width;
        const bossInCorner = this.isInCorner(game);
        
        // 更新AI性格
        this.updatePersonality(playerHealthPercent, bossHealthPercent, hasInvincible, isCursed);
        
        // 選擇戰術
        if (this.decisionCooldown <= 0) {
            this.chooseTactic(player, distance, playerHealthPercent, bossHealthPercent, 
                           hasInvincible, hasSpeed, hasVampire, isCursed, playerInCorner);
            this.decisionCooldown = 0.5;
        }
    }
    
    // 更新AI性格
    updatePersonality(playerHealthPercent, bossHealthPercent, hasInvincible, isCursed) {
        let baseAggression = 0.5;
        if (this.phase === 3) baseAggression = 0.8;
        else if (this.state === 'monster') baseAggression = 0.6;
        
        if (playerHealthPercent < 0.3 && !hasInvincible) {
            this.aggressiveness = Math.min(1.0, baseAggression + 0.4);
            this.caution = 0.2;
        } else if (bossHealthPercent < 0.3) {
            this.aggressiveness = 0.9;
            this.caution = 0.1;
        } else if (hasInvincible) {
            this.aggressiveness = 0.2;
            this.caution = 0.9;
        } else if (isCursed) {
            this.aggressiveness = Math.min(1.0, baseAggression + 0.3);
            this.caution = 0.3;
        } else {
            this.aggressiveness = baseAggression;
            this.caution = 0.5;
        }
    }
    
    // 智能戰術選擇
    chooseTactic(player, distance, playerHealthPercent, bossHealthPercent, 
                hasInvincible, hasSpeed, hasVampire, isCursed, playerInCorner) {
        
        if (hasInvincible && player.buffTimer > 2) {
            this.currentTactic = 'defensive';
            this.aiState = 'retreat';
        } else if (playerHealthPercent < 0.2 && !hasInvincible) {
            this.currentTactic = 'finisher';
            this.aiState = 'rush';
        } else if (playerInCorner && distance < 200) {
            this.currentTactic = 'corner_pressure';
            this.aiState = 'attack';
        } else if (hasVampire && distance < 150) {
            this.currentTactic = 'kite';
            this.aiState = 'retreat';
        } else if (hasSpeed) {
            this.currentTactic = 'predict';
            this.aiState = 'defensive';
        } else if (this.aggressiveness > 0.7) {
            this.currentTactic = 'aggressive';
            this.aiState = distance > 200 ? 'rush' : 'attack';
        } else if (this.aggressiveness < 0.3) {
            this.currentTactic = 'cautious';
            this.aiState = distance < 150 ? 'retreat' : 'stalk';
        } else {
            this.currentTactic = 'balanced';
            this.aiState = distance > 200 ? 'approach' : 'attack';
        }
    }
    
    attack(game) {
        // 根據階段選擇不同攻擊
        if (this.phase === 1) {
            // 第一階段攻擊
            const attackType = Math.random();
            if (attackType < 0.5) {
                this.fireballAttack(game);  // 使用現有的5幀火球動畫
            } else if (attackType < 0.8) {
                this.goldCoinAttack(game);
            } else {
                this.biteAttack(game);
            }
        } else if (this.phase === 3) {
            // 第三階段攻擊 - 狂暴模式
            const attackType = Math.random();
            if (attackType < 0.4) {
                this.fireballBarrage(game);  // 第三階段專屬：火球連射
            } else if (attackType < 0.6) {
                this.jumpSlam(game);
            } else if (attackType < 0.8) {
                this.fireballAttack(game);  // 普通火球
            } else {
                this.goldCoinAttack(game);
            }
        } else {
            // 覺醒階段攻擊（HP > 50%但已變身）
            const attackType = Math.random();
            if (attackType < 0.5) {
                this.fireballAttack(game);  // 普通火球
            } else if (attackType < 0.8) {
                this.goldCoinAttack(game);
            } else {
                this.biteAttack(game);
            }
        }
    }
    
    // 單發火球攻擊（所有階段都可使用，只發射1顆火球）
    fireballAttack(game) {
        // 播放現有的5幀火球動畫 (但不在變身期間)
        if (!this.isTransforming) {
            this.playAnimation('attack');
        }
        
        const fireball = {
            x: this.x + this.width/2,
            y: this.y + this.height/2,
            width: 20,
            height: 20,
            vx: (player.x - this.x) > 0 ? 250 : -250,
            vy: -100,
            damage: 18,
            owner: this,
            active: true,
            type: 'fireball',
            time: 0,
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += 500 * deltaTime;
                this.time += deltaTime;
                
                if (this.y > 400 || this.x < -50 || this.x > 850) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // 火球效果
                const gradient = ctx.createRadialGradient(
                    this.x + this.width/2, 
                    this.y + this.height/2, 
                    0,
                    this.x + this.width/2, 
                    this.y + this.height/2, 
                    this.width/2
                );
                gradient.addColorStop(0, '#FFFF00');
                gradient.addColorStop(0.5, '#FF6600');
                gradient.addColorStop(1, '#FF0000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        
        game.projectiles.push(fireball);
    }
    
    // 第一階段 - 金幣投射
    goldCoinAttack(game) {
        if (!this.isTransforming) {
            this.playAnimation('attack');
        }
        
        const projectile = {
            x: this.x + this.width/2,
            y: this.y + this.height/2,
            width: 16,
            height: 16,
            vx: (player.x - this.x) > 0 ? 250 : -250,
            vy: -150,
            damage: 15,
            owner: this,
            active: true,
            rotation: 0,
            type: 'coin',
            
            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += 600 * deltaTime;
                this.rotation += deltaTime * 10;
                
                if (this.y > 400 || this.x < -50 || this.x > 850) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                // 繪製旋轉金幣
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);
                
                ctx.restore();
            }
        };
        
        game.projectiles.push(projectile);
    }
    
    // 第一階段 - 咬擊攻擊
    biteAttack(game) {
        if (!this.isTransforming) {
            // 使用咬擊動畫
            this.playAnimation('bite');
        }
        
        // 近距離攻擊判定
        const attackBox = {
            x: this.x + (this.facing === 1 ? this.width : -40),
            y: this.y + 40,
            width: 40,
            height: 60,
            damage: 25,
            owner: this,
            active: true,
            life: 0.2,
            type: 'bite',
            
            update(deltaTime) {
                this.life -= deltaTime;
                if (this.life <= 0) {
                    this.active = false;
                }
            },
            
            render(ctx) {
                // 不繪製任何視覺效果，因為咬擊動畫已經有動畫圖檔
                // 攻擊判定仍然存在，只是不顯示紅色方塊
            }
        };
        
        game.projectiles.push(attackBox);
    }
    
    // 第三階段專屬 - 火球連射（發射3顆火球，有6幀專屬動畫）
    fireballBarrage(game) {
        // 播放火球連射動畫
        if (this.animations.fireballBarrage && this.animations.fireballBarrage.length > 0) {
            this.playAnimation('fireballBarrage');
        }
        
        let fireballCount = 0;
        const shootFireball = () => {
            if (fireballCount >= 3) return; // 總共發射3顆
            
            const fireball = {
                x: this.x + this.width/2,
                y: this.y + this.height/2,
                width: 24,
                height: 24,
                vx: (player.x - this.x) > 0 ? 300 : -300,
                vy: -50 - (fireballCount * 50),
                damage: 20,
                owner: this,
                active: true,
                type: 'fireball',
                time: 0,
                
                update(deltaTime) {
                    this.x += this.vx * deltaTime;
                    this.y += this.vy * deltaTime;
                    this.vy += 400 * deltaTime;
                    this.time += deltaTime;
                    
                    if (this.y > 400 || this.x < -50 || this.x > 850) {
                        this.active = false;
                    }
                },
                
                render(ctx) {
                    // 火球漸層效果
                    const gradient = ctx.createRadialGradient(
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        0,
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        this.width/2
                    );
                    gradient.addColorStop(0, '#FFFF00');
                    gradient.addColorStop(0.5, '#FF6600');
                    gradient.addColorStop(1, '#FF0000');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 火焰尾跡
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2 - this.vx * 0.05, this.y + this.height/2, this.width/3, 0, Math.PI * 2);
                    ctx.fill();
                }
            };
            
            game.projectiles.push(fireball);
            fireballCount++;
            
            if (fireballCount < 3) {
                setTimeout(shootFireball, 200);
            }
        };
        
        shootFireball();
    }
    
    // 第二階段 - 跳躍震地
    jumpSlam(game) {
        if (!this.grounded) return;
        
        // 大跳躍
        this.vy = -600;
        this.grounded = false;
        
        // 延遲創建震波
        setTimeout(() => {
            if (!this.grounded) return;
            
            // 左右兩個震波
            [-1, 1].forEach(direction => {
                const shockwave = {
                    x: this.x + this.width/2,
                    y: game.height - 60,
                    width: 20,
                    height: 40,
                    vx: direction * 200,
                    vy: 0,
                    damage: 15,
                    owner: this,
                    active: true,
                    life: 1,
                    type: 'shockwave',
                    
                    update(deltaTime) {
                        this.x += this.vx * deltaTime;
                        this.width += 100 * deltaTime;
                        this.life -= deltaTime;
                        
                        if (this.life <= 0 || this.x < -100 || this.x > 900) {
                            this.active = false;
                        }
                    },
                    
                    render(ctx) {
                        ctx.fillStyle = `rgba(139, 69, 19, ${this.life})`;
                        ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
                    }
                };
                
                game.projectiles.push(shockwave);
            });
        }, 800);
    }
    
    // 3D變身特效
    triggerTransformationEffect() {
        // 播放變身動畫
        this.playAnimation('transform');
        console.log('開始播放變身動畫, 總幀數:', this.animations.transform ? this.animations.transform.length : 0);
        
        // 停止Boss移動
        this.savedVx = this.vx;
        this.savedVy = this.vy;
        this.vx = 0;
        this.vy = 0;
        
        // 重新啟用3D特效覆蓋層
        create3DTransformationEffect(this.x + this.width/2, this.y + this.height/2);
        
        // 不暫停遊戲，讓動畫可以繼續更新
        setTimeout(() => {
            showGameMessage('PHASE 3 - FINAL FORM!', 1500);
            // 恢復移動
            this.vx = this.savedVx || 0;
            this.vy = this.savedVy || 0;
        }, 3240); // 27幀 * 0.12秒
    }
    
    // 3D死亡特效
    // 觸發逃脫機制
    triggerEscape() {
        this.escaping = true;
        this.comboTaken = 0;  // 重置連擊計數
        
        // 快速後跳逃脫
        this.vy = -400;  // 向上跳
        this.vx = this.facing * -300;  // 向後退
        this.aiState = 'retreat';
        
        // 0.5秒後結束逃脫狀態
        setTimeout(() => {
            this.escaping = false;
            this.aiState = 'defensive';
        }, 500);
        
        // 特效
        this.game.addParticle(this.x + this.width/2, this.y + this.height/2, 'escape');
        console.log('Boss triggered escape mechanism!');
    }
    
    triggerDeathEffect() {
        console.log('Triggering Boss death 3D effect');
        // 創建死亡3D特效
        create3DDeathEffect(this.x + this.width/2, this.y + this.height/2);
    }
    
    takeDamage(damage) {
        // 變身期間無敵
        if (this.isTransforming) {
            console.log('Boss is invincible during transformation!');
            this.game.addParticle(this.x + this.width/2, this.y, 'blocked');
            return;
        }
        
        // 正在逃脫中，短暫無敵
        if (this.escaping) {
            this.game.addParticle(this.x + this.width/2, this.y, 'blocked');
            return;
        }
        
        this.health -= damage;
        this.health = Math.max(0, this.health);
        
        // 設定受傷僵直
        this.hurtStunTime = this.maxHurtStun;
        this.comboTaken++;  // 增加被連擊計數
        
        // 被連擊7次後觸發逃脫機制
        if (this.comboTaken >= this.maxComboBeforeEscape) {
            this.triggerEscape();
        }
        
        // 打斷當前動作
        this.vx *= 0.5;  // 減速
        this.aiState = 'hurt';  // 進入受傷狀態
        
        // 第一次受傷變身
        if (this.state === 'chest') {
            this.state = 'monster';
        }
        
        // 階段變化 - 血量降到50%時變身到第三階段
        if (this.health <= this.maxHealth * 0.5 && this.phase === 1) {
            this.phase = 2; // 暫時設為2，變身完成後會變成3
            // 觸發3D變身特效
            this.triggerTransformationEffect();
            // 變身期間設定標記，避免被其他動畫覆蓋且無敵
            this.isTransforming = true;
            setTimeout(() => {
                this.isTransforming = false;
                this.phase = 3; // 變身完成，進入第三階段
                console.log('Transformation complete! Entering Phase 3!');
            }, 3240); // 變身動畫時長 (27幀 * 0.12秒)
        }
        
        this.updateHealth();
        this.game.addParticle(this.x + this.width/2, this.y, 'damage');
        
        // 播放受擊動畫 (但不在變身期間)
        if (this.health > 0 && this.state === 'monster' && !this.isTransforming) {
            this.playAnimation('hit');
        }
        
        if (this.health <= 0) {
            this.state = 'dying';
            this.playAnimation('death');
            console.log('Boss death animation started');
            
            // 觸發3D死亡特效
            this.triggerDeathEffect();
            
            // 設定死亡完成回調
            this.onDeathComplete = () => {
                console.log('Boss death animation complete, showing victory');
                this.game.gameOver = true;
                this.game.score += 1000;
                this.game.victory = true;
                showGameOverScreen(true);
            };
            
            // 備用計時器，如果動畫沒有正常結束
            setTimeout(() => {
                if (this.state === 'dying' && !this.game.gameOver) {
                    console.log('Death animation timeout, forcing victory');
                    this.onDeathComplete();
                }
            }, 3000); // 3秒後強制結束
        }
    }
    
    updateHealth() {
        const percent = (this.health / this.maxHealth) * 100;
        document.getElementById('bossHP').textContent = `${this.health}/${this.maxHealth}`;
        document.getElementById('bossHealthBar').style.width = percent + '%';
    }
    
    render(ctx) {
        ctx.save();
        
        // 鏡像處理 - 根據面向翻轉
        if (this.facing === 1) {  // facing = 1 時面向右，需要翻轉圖像
            ctx.scale(-1, 1);
            ctx.translate(-this.x * 2 - this.width, 0);
        }
        
        // 處理程式化動畫效果
        if (this.currentAnimation === 'hit') {
            // 受擊閃紅效果
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
            
            // 0.3秒後結束受擊動畫
            if (this.animationTimer > 0.3) {
                this.currentAnimation = null;
                this.animationTimer = 0;
            }
        } else if (this.currentAnimation === 'movement') {
            // 移動動畫效果 - 添加殘影
            ctx.fillStyle = 'rgba(100, 0, 0, 0.2)';
            const offsetX = this.vx > 0 ? -10 : 10;
            ctx.fillRect(this.x + offsetX, this.y, this.width, this.height);
            
            // 0.5秒後結束移動動畫
            if (this.animationTimer > 0.5) {
                this.currentAnimation = null;
                this.animationTimer = 0;
            }
        }
        
        // 如果有動畫正在播放，顯示動畫幀（排除程式化動畫）
        if (this.currentAnimation && 
            this.currentAnimation !== 'hit' && 
            this.currentAnimation !== 'movement' &&
            this.animations[this.currentAnimation]) {
            const frames = this.animations[this.currentAnimation];
            // 確保動畫幀索引不超出範圍
            const frameIndex = Math.min(this.animationFrame, frames.length - 1);
            const currentFrame = frames[frameIndex];
            
            // 檢查圖片是否存在，不管是否完全載入
            if (currentFrame) {
                try {
                    // 如果圖片已載入（寬高大於0）就繪製
                    if (currentFrame.width > 0 && currentFrame.height > 0) {
                        ctx.drawImage(currentFrame, this.x, this.y, this.width, this.height);
                        // 變身動畫顯示特殊序列資訊
                        if (this.currentAnimation === 'transform' && this.transformFrameSequence) {
                            console.log(`Drawing transform animation: sequence index ${this.transformFrameIndex}/${this.transformFrameSequence.length-1}, frame ${frameIndex+1}`);
                        } else {
                            console.log(`Drawing ${this.currentAnimation} frame ${frameIndex}/${frames.length-1}`);
                        }
                        ctx.restore();
                        return; // 顯示動畫時不顯示其他圖形
                    } else {
                        console.log(`Frame not ready: ${this.currentAnimation} frame ${frameIndex}, size: ${currentFrame.width}x${currentFrame.height}`);
                    }
                } catch (e) {
                    console.log('動畫幀繪製失敗:', e);
                }
            } else {
                console.log(`No frame at index ${frameIndex} for ${this.currentAnimation}`);
            }
        }
        
        // 怪物形態且沒有其他動畫時，顯示待機動畫
        if (this.state === 'monster' && !this.currentAnimation) {
            // 根據階段選擇待機動畫
            let idleAnim;
            if (this.phase === 3) {
                // 第三階段使用5幀待機動畫
                idleAnim = this.animations.idlePhase3;
                // 播放多幀動畫
                if (idleAnim && idleAnim.length > 1) {
                    if (!this.phase3IdleTimer) this.phase3IdleTimer = 0;
                    if (!this.phase3IdleFrame) this.phase3IdleFrame = 0;
                    
                    this.phase3IdleTimer += 0.016; // 假設60 FPS
                    if (this.phase3IdleTimer >= 0.15) { // 每0.15秒切換一幀（狂暴階段更快）
                        this.phase3IdleTimer = 0;
                        this.phase3IdleFrame = (this.phase3IdleFrame + 1) % idleAnim.length;
                    }
                    
                    const idleFrame = idleAnim[this.phase3IdleFrame];
                    if (idleFrame && idleFrame.width > 0 && idleFrame.height > 0) {
                        ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                        ctx.restore();
                        return;
                    }
                }
            } else if (this.phase === 1 && this.state === 'monster') {
                // 覺醒狀態（HP > 50%）使用覺醒待機動畫
                idleAnim = this.animations.awakenedIdle;
                // 如果有多幀，播放動畫
                if (idleAnim && idleAnim.length > 1) {
                    if (!this.idleAnimTimer) this.idleAnimTimer = 0;
                    if (!this.idleAnimFrame) this.idleAnimFrame = 0;
                    
                    this.idleAnimTimer += 0.016; // 假設60 FPS
                    if (this.idleAnimTimer >= 0.3) { // 每0.3秒切換一幀
                        this.idleAnimTimer = 0;
                        this.idleAnimFrame = (this.idleAnimFrame + 1) % idleAnim.length;
                    }
                    
                    const idleFrame = idleAnim[this.idleAnimFrame];
                    if (idleFrame && idleFrame.width > 0 && idleFrame.height > 0) {
                        ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                        ctx.restore();
                        return;
                    }
                }
            } else {
                idleAnim = this.animations.idle;
            }
            
            if (idleAnim && idleAnim[0]) {
                const idleFrame = idleAnim[0];
                if (idleFrame.width > 0 && idleFrame.height > 0) {
                    ctx.drawImage(idleFrame, this.x, this.y, this.width, this.height);
                    ctx.restore();
                    return;
                }
            }
        }
        
        // 沒有動畫時顯示預設圖形
        if (this.state === 'chest') {
            // 嘗試顯示偽裝待機圖片
            if (this.animations.idle && this.animations.idle.length > 0 && this.animations.idle[0].complete) {
                ctx.drawImage(this.animations.idle[0], this.x, this.y, this.width, this.height);
            } else {
                // 如果圖片未載入，顯示程式化的寶箱
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(this.x + 24, this.y + 48, 80, 60);
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x + 24, this.y + 36, 80, 20);
                
                // 寶箱鎖
                ctx.fillStyle = '#ffcc66';
                ctx.fillRect(this.x + 56, this.y + 30, 16, 24);
                
                // 寶箱細節
                ctx.fillStyle = '#6b3410';
                ctx.fillRect(this.x + 24, this.y + 64, 80, 4);
                ctx.fillRect(this.x + 24, this.y + 88, 80, 4);
            }
        } else {
            // 放大的怪物形態
            // 主體 (第三階段有特殊顏色)
            if (this.phase === 3) {
                // 第三階段 - 暗紫色帶紅光
                const gradient = ctx.createLinearGradient(this.x + 32, this.y + 40, this.x + 96, this.y + 96);
                gradient.addColorStop(0, '#440044');
                gradient.addColorStop(0.5, '#660033');
                gradient.addColorStop(1, '#330011');
                ctx.fillStyle = gradient;
            } else {
                ctx.fillStyle = this.phase === 2 ? '#660000' : '#8b4513';
            }
            ctx.fillRect(this.x + 32, this.y + 40, 64, 56);
            
            // 大嘴巴
            ctx.fillStyle = this.phase === 3 ? '#110011' : '#330000';
            ctx.fillRect(this.x + 40, this.y + 60, 48, 24);
            
            // 牙齒 (更大更兇)
            ctx.fillStyle = this.phase === 3 ? '#ffccff' : '#ffffff';
            for (let i = 0; i < 6; i++) {
                // 上排牙齒
                ctx.fillRect(this.x + 42 + i * 7, this.y + 60, 5, 10);
                // 下排牙齒
                ctx.fillRect(this.x + 42 + i * 7, this.y + 74, 5, 10);
            }
            
            // 眼睛 (第三階段發光的紫色眼睛)
            if (this.phase === 3) {
                // 發光效果
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ff00ff';
            } else {
                ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#ffff00';
            }
            ctx.fillRect(this.x + 40, this.y + 44, 12, 12);
            ctx.fillRect(this.x + 76, this.y + 44, 12, 12);
            ctx.shadowBlur = 0;
            
            // 瞳孔
            ctx.fillStyle = '#000000';
            ctx.fillRect(this.x + 44, this.y + 48, 4, 4);
            ctx.fillRect(this.x + 80, this.y + 48, 4, 4);
            
            // 腿 (更粗壯)
            if (this.state === 'monster') {
                ctx.fillStyle = this.phase === 3 ? '#220022' : (this.phase === 2 ? '#330000' : '#660000');
                ctx.fillRect(this.x + 36, this.y + 96, 20, 32);
                ctx.fillRect(this.x + 72, this.y + 96, 20, 32);
                
                // 腳爪
                ctx.fillStyle = this.phase === 3 ? '#ffccff' : '#ffffff';
                ctx.fillRect(this.x + 36, this.y + 124, 20, 4);
                ctx.fillRect(this.x + 72, this.y + 124, 20, 4);
            }
            
            // 階段特效
            if (this.phase === 2) {
                // 憤怒的氣場
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x + 20, this.y + 30, 88, 98);
            } else if (this.phase === 3) {
                // 第三階段 - 紫色能量場
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x + 20, this.y + 30, 88, 98);
                
                // 漂浮的能量粒子
                const time = Date.now() / 1000;
                ctx.fillStyle = 'rgba(255, 0, 255, 0.8)';
                for (let i = 0; i < 3; i++) {
                    const offsetX = Math.sin(time * 2 + i * 2) * 15;
                    const offsetY = Math.cos(time * 3 + i * 2) * 10;
                    ctx.fillRect(this.x + 50 + offsetX, this.y + 20 + offsetY, 4, 4);
                }
            }
        }
        
        ctx.restore();
    }
}

// 禮盒類
class GiftBox {
    constructor(x, y, game) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;
        this.game = game;
        this.vy = 0;
        this.grounded = false;
        this.collected = false;
        this.isGiftBox = true;
        
        // 禮盒效果列表
        this.effects = [
            { type: 'invincible', name: '這是一個很棒的想法', description: '無視攻擊10秒，結束後血量全滿', color: '#00ff00', image: 'Assets/GiftStates/invincible.png' },
            { type: 'speed', name: 'Run Don\'t walk', description: '速度與攻速提升2.5倍，持續10秒', color: '#00ffff', image: 'Assets/GiftStates/run_dont_walk.png' },
            { type: 'vampire', name: '複製貼上', description: '攻擊力1.5倍並吸血，持續10秒', color: '#ff00ff', image: 'Assets/GiftStates/copy_paste.png' },
            { type: 'cursed', name: '被祖了', description: '你被祖了', color: '#ff0000', image: 'Assets/GiftStates/cursed.png' }
        ];
    }
    
    update(deltaTime, game) {
        if (this.collected) return;
        
        // 重力
        this.vy += 800 * deltaTime;
        this.y += this.vy * deltaTime;
        
        // 落地
        if (this.y + this.height >= game.height - 60) {
            this.y = game.height - 60 - this.height;
            this.vy = 0;
            this.grounded = true;
        }
    }
    
    collect(player) {
        if (this.collected) return;
        this.collected = true;
        
        // 隨機選擇效果
        const effect = this.effects[Math.floor(Math.random() * this.effects.length)];
        
        // 顯示效果 UI（先顯示UI）
        this.showEffectUI(effect);
        
        // 延遲一點播放語音，確保UI已經顯示
        setTimeout(() => {
            this.playGiftSound(effect.type);
        }, 100);
        
        // 應用效果到玩家
        setTimeout(() => {
            player.applyBuff(effect.type);
            // 從實體列表移除禮盒
            const index = this.game.entities.indexOf(this);
            if (index > -1) {
                this.game.entities.splice(index, 1);
            }
        }, 1500);  // 1.5秒後應用效果
    }
    
    playGiftSound(effectType) {
        // 使用預載入的音效
        if (giftSounds[effectType]) {
            // 重置音頻到開始位置
            giftSounds[effectType].currentTime = 0;
            giftSounds[effectType].volume = 1.0;  // 確保音量最大
            
            // 播放音效
            giftSounds[effectType].play().then(() => {
                console.log('Playing gift sound:', effectType);
            }).catch(error => {
                console.error('Failed to play gift sound:', effectType, error);
                // 如果預載入的音效失敗，嘗試創建新的
                const fallbackAudio = new Audio(`Assets/Audio/GiftBox/gift_${effectType}.mp3`);
                fallbackAudio.volume = 1.0;  // 最大音量
                fallbackAudio.play().catch(e => console.error('Fallback audio also failed:', e));
            });
        } else {
            console.log('Gift sound not found for effect:', effectType);
        }
    }
    
    showEffectUI(effect) {
        // 凍結遊戲
        this.game.paused = true;
        
        // 創建效果顯示層
        const effectDiv = document.createElement('div');
        effectDiv.style.position = 'fixed';
        effectDiv.style.top = '50%';
        effectDiv.style.left = '50%';
        effectDiv.style.transform = 'translate(-50%, -50%)';
        effectDiv.style.zIndex = '5000';
        effectDiv.style.background = 'rgba(0, 0, 0, 0.9)';
        effectDiv.style.border = `3px solid ${effect.color}`;
        effectDiv.style.padding = '40px';
        effectDiv.style.borderRadius = '10px';
        effectDiv.style.textAlign = 'center';
        effectDiv.style.fontFamily = '"Press Start 2P", cursive';
        effectDiv.style.animation = 'fadeIn 0.5s';
        
        // 效果圖標容器（顯示對應圖片）
        const iconContainer = document.createElement('div');
        iconContainer.style.width = '250px';
        iconContainer.style.height = '250px';
        iconContainer.style.margin = '0 auto 30px';
        iconContainer.style.position = 'relative';
        iconContainer.style.display = 'flex';
        iconContainer.style.alignItems = 'center';
        iconContainer.style.justifyContent = 'center';
        
        // 背景光環效果（改為脈動而非旋轉）
        const bgGlow = document.createElement('div');
        bgGlow.style.position = 'absolute';
        bgGlow.style.width = '280px';
        bgGlow.style.height = '280px';
        bgGlow.style.background = `radial-gradient(circle, ${effect.color}60 0%, ${effect.color}30 40%, transparent 70%)`;
        bgGlow.style.animation = 'glowPulse 2s ease-in-out infinite';
        bgGlow.style.pointerEvents = 'none';
        iconContainer.appendChild(bgGlow);
        
        // 圖片容器
        const icon = document.createElement('div');
        icon.style.width = '200px';
        icon.style.height = '200px';
        icon.style.position = 'relative';
        icon.style.borderRadius = '15px';
        icon.style.overflow = 'hidden';
        icon.style.zIndex = '2';
        
        // 如果有圖片，載入圖片
        if (effect.image) {
            const img = document.createElement('img');
            img.src = effect.image;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.borderRadius = '15px';
            // 增強的光暈效果（配合動畫的閃爍）
            img.style.filter = `
                drop-shadow(0 0 30px ${effect.color}) 
                drop-shadow(0 0 60px ${effect.color}) 
                drop-shadow(0 0 90px ${effect.color}80)
            `;
            icon.appendChild(img);
            
            // 圖片不需要額外動畫，由容器動畫控制
            
            // 如果圖片載入失敗，顯示顏色方塊
            img.onerror = () => {
                img.remove();
                icon.style.background = `linear-gradient(135deg, ${effect.color}, ${effect.color}80)`;
                icon.style.boxShadow = `
                    0 0 40px ${effect.color}, 
                    0 0 80px ${effect.color}80,
                    inset 0 0 20px rgba(255,255,255,0.3)
                `;
            };
        } else {
            // 沒有圖片時顯示漸層方塊
            icon.style.background = `linear-gradient(135deg, ${effect.color}, ${effect.color}80)`;
            icon.style.boxShadow = `
                0 0 40px ${effect.color}, 
                0 0 80px ${effect.color}80,
                inset 0 0 20px rgba(255,255,255,0.3)
            `;
        }
        
        // 添加主要動畫（放大閃爍縮小效果）
        icon.style.animation = 'scaleFlash 1.5s ease-out forwards';
        
        // 添加粒子效果
        for (let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.background = effect.color;
            particle.style.borderRadius = '50%';
            particle.style.left = '50%';
            particle.style.top = '50%';
            particle.style.transform = `translate(-50%, -50%)`;
            particle.style.boxShadow = `0 0 10px ${effect.color}`;
            particle.style.animation = `particleFloat${i} 3s infinite`;
            particle.style.animationDelay = `${i * 0.2}s`;
            iconContainer.appendChild(particle);
        }
        
        iconContainer.appendChild(icon);
        
        effectDiv.appendChild(iconContainer);
        
        // 效果名稱
        const title = document.createElement('h2');
        title.style.color = effect.color;
        title.style.fontSize = '24px';
        title.style.marginBottom = '20px';
        title.style.textShadow = `0 0 10px ${effect.color}`;
        title.textContent = effect.name;
        effectDiv.appendChild(title);
        
        // 效果描述
        const desc = document.createElement('p');
        desc.style.color = '#ffffff';
        desc.style.fontSize = '14px';
        desc.style.lineHeight = '1.5';
        desc.textContent = effect.description;
        effectDiv.appendChild(desc);
        
        document.body.appendChild(effectDiv);
        
        // 播放音效（如果有音效系統的話）
        this.playEffectSound(effect.type);
        
        // 1.5秒後移除UI並解除暫停
        setTimeout(() => {
            effectDiv.remove();
            this.game.paused = false;
        }, 1500);
    }
    
    playEffectSound(type) {
        // 創建簡單的音效
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // 根據效果類型設置不同音調
        switch(type) {
            case 'invincible':
                oscillator.frequency.value = 800;  // 高音
                break;
            case 'speed':
                oscillator.frequency.value = 600;  // 中高音
                break;
            case 'vampire':
                oscillator.frequency.value = 400;  // 中音
                break;
            case 'cursed':
                oscillator.frequency.value = 200;  // 低音
                break;
        }
        
        gainNode.gain.value = 0.1;
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    }
    
    render(ctx) {
        if (this.collected) return;
        
        ctx.save();
        
        // 繪製禮盒
        // 盒子主體
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(this.x, this.y + 15, this.width, this.height - 15);
        
        // 盒子蓋子
        ctx.fillStyle = '#ff8800';
        ctx.fillRect(this.x - 2, this.y + 10, this.width + 4, 8);
        
        // 絲帶（垂直）
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(this.x + this.width/2 - 4, this.y, 8, this.height);
        
        // 絲帶（水平）
        ctx.fillRect(this.x, this.y + 12, this.width, 4);
        
        // 蝴蝶結
        ctx.fillStyle = '#ffcc00';
        // 左邊
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2, this.y + 5);
        ctx.lineTo(this.x + this.width/2 - 10, this.y);
        ctx.lineTo(this.x + this.width/2 - 10, this.y + 10);
        ctx.closePath();
        ctx.fill();
        
        // 右邊
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2, this.y + 5);
        ctx.lineTo(this.x + this.width/2 + 10, this.y);
        ctx.lineTo(this.x + this.width/2 + 10, this.y + 10);
        ctx.closePath();
        ctx.fill();
        
        // 發光效果
        ctx.shadowColor = '#ffcc00';
        ctx.shadowBlur = 20;
        ctx.fillStyle = 'rgba(255, 204, 0, 0.3)';
        ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
        
        ctx.restore();
    }
}

// 遊戲循環
let lastTime = 0;

function gameLoop(currentTime) {
    if (!lastTime) lastTime = currentTime;
    const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
    lastTime = currentTime;
    
    if (game) {
        // 總是渲染，即使暫停
        game.render();
        // 只在非暫停和非結束時更新
        if (!game.paused && !game.gameOver) {
            game.update(deltaTime);
        }
    }
    
    animationId = requestAnimationFrame(gameLoop);
}

// 工具函數
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// 測試模式：在URL加上 ?debug=true 可以在電腦上看到觸控按鈕
function isDebugMode() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('debug') === 'true';
}

function initMobileControls() {
    // 顯示手機控制
    const mobileControls = document.getElementById('mobileControls');
    if (mobileControls) {
        mobileControls.style.display = 'block';
    }
    
    const controls = document.querySelectorAll('.control-btn');
    
    // 為每個按鈕添加事件
    controls.forEach(btn => {
        const key = btn.dataset.key;
        
        // 觸控事件
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = true;
                console.log('Touch start:', key);
                // 特別處理攻擊按鈕
                if (key === ' ' && player) {
                    player.attack(game);
                }
            }
            btn.style.background = 'rgba(255, 204, 102, 0.9)';
        });
        
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
                console.log('Touch end:', key);
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        btn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        // 滑鼠事件（用於電腦測試）
        btn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = true;
                console.log('Mouse down:', key);
                // 特別處理攻擊按鈕
                if (key === ' ' && player) {
                    player.attack(game);
                }
            }
            btn.style.background = 'rgba(255, 204, 102, 0.9)';
        });
        
        btn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (game && game.keys) {
                game.keys[key] = false;
                console.log('Mouse up:', key);
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
        
        btn.addEventListener('mouseleave', (e) => {
            if (game && game.keys) {
                game.keys[key] = false;
            }
            btn.style.background = 'rgba(139, 105, 20, 0.7)';
        });
    });
    
    console.log('Mobile controls initialized');
}

// Three.js 3D transformation effect (positioned at Boss location)
function create3DTransformationEffect(bossX, bossY) {
    // Convert boss canvas coordinates to screen coordinates
    const canvas = document.getElementById('gameCanvas');
    const rect = canvas.getBoundingClientRect();
    const screenX = rect.left + (bossX / 800) * rect.width;
    const screenY = rect.top + (bossY / 400) * rect.height;
    
    // Create a temporary div for the 3D effect centered on boss
    const effectDiv = document.createElement('div');
    effectDiv.style.position = 'fixed';
    effectDiv.style.left = (screenX - 200) + 'px';
    effectDiv.style.top = (screenY - 200) + 'px';
    effectDiv.style.width = '400px';
    effectDiv.style.height = '400px';
    effectDiv.style.pointerEvents = 'none';
    effectDiv.style.zIndex = '1000';
    document.body.appendChild(effectDiv);

    // Initialize Three.js with smaller viewport
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(400, 400);
    effectDiv.appendChild(renderer.domElement);

    // Create particle system and cubes for transformation effect
    const particles = [];
    const cubes = [];
    
    // Create rotating cubes
    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cubeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        wireframe: true,
        opacity: 0.8,
        transparent: true
    });
    
    for (let i = 0; i < 8; i++) {
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial.clone());
        const angle = (i / 8) * Math.PI * 2;
        cube.position.x = Math.cos(angle) * 3;
        cube.position.z = Math.sin(angle) * 3;
        cube.rotation.x = Math.random() * Math.PI;
        cube.rotation.y = Math.random() * Math.PI;
        scene.add(cube);
        cubes.push(cube);
    }

    // Create particle effect
    const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xFF00FF,
        transparent: true,
        opacity: 1
    });
    
    for (let i = 0; i < 50; i++) {
        const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
        particle.position.x = (Math.random() - 0.5) * 2;
        particle.position.y = (Math.random() - 0.5) * 2;
        particle.position.z = (Math.random() - 0.5) * 2;
        particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2
        );
        scene.add(particle);
        particles.push(particle);
    }

    camera.position.z = 10;

    // Animation variables
    let animationTime = 0;
    const maxAnimationTime = 3240; // Match transformation duration (27 frames * 0.12s)

    // Animate the effect
    function animate() {
        animationTime += 16; // Approximate 60fps
        
        if (animationTime >= maxAnimationTime) {
            // Clean up
            effectDiv.remove();
            return;
        }

        requestAnimationFrame(animate);

        const progress = animationTime / maxAnimationTime;
        
        // Rotate and expand cubes
        cubes.forEach((cube, i) => {
            cube.rotation.x += 0.05;
            cube.rotation.y += 0.05;
            const angle = (i / 8) * Math.PI * 2 + animationTime * 0.001;
            const radius = 3 + progress * 5;
            cube.position.x = Math.cos(angle) * radius;
            cube.position.z = Math.sin(angle) * radius;
            cube.material.opacity = Math.max(0, 1 - progress);
        });

        // Move and fade particles
        particles.forEach(particle => {
            particle.position.add(particle.velocity);
            particle.material.opacity = Math.max(0, 1 - progress);
            particle.scale.setScalar(1 + progress * 2);
        });

        // Rotate camera slightly for dynamic effect
        camera.position.x = Math.sin(animationTime * 0.001) * 2;
        camera.position.y = Math.cos(animationTime * 0.001) * 1;

        renderer.render(scene, camera);
    }

    animate();
}

// 3D死亡特效函數
function create3DDeathEffect(bossX, bossY) {
    // Convert boss canvas coordinates to screen coordinates
    const canvas = document.getElementById('gameCanvas');
    const rect = canvas.getBoundingClientRect();
    const screenX = rect.left + (bossX / 800) * rect.width;
    const screenY = rect.top + (bossY / 400) * rect.height;
    
    // Create a temporary div for the 3D effect centered on boss
    const effectDiv = document.createElement('div');
    effectDiv.style.position = 'fixed';
    effectDiv.style.left = (screenX - 250) + 'px';
    effectDiv.style.top = (screenY - 250) + 'px';
    effectDiv.style.width = '500px';
    effectDiv.style.height = '500px';
    effectDiv.style.pointerEvents = 'none';
    effectDiv.style.zIndex = '1000';
    document.body.appendChild(effectDiv);
    
    // Initialize Three.js with larger viewport for death effect
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(500, 500);
    effectDiv.appendChild(renderer.domElement);
    
    // Create explosion particles
    const particles = [];
    const fragments = [];
    
    // Create fragmenting cubes (Boss breaking apart)
    const fragmentGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    
    for (let i = 0; i < 20; i++) {
        const fragmentMaterial = new THREE.MeshBasicMaterial({ 
            color: Math.random() > 0.5 ? 0xff0000 : 0x8b0000,
            transparent: true,
            opacity: 1
        });
        const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
        fragment.position.x = (Math.random() - 0.5) * 2;
        fragment.position.y = (Math.random() - 0.5) * 2;
        fragment.position.z = (Math.random() - 0.5) * 2;
        fragment.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.3 + 0.1,
            (Math.random() - 0.5) * 0.5
        );
        fragment.rotationSpeed = new THREE.Vector3(
            Math.random() * 0.2,
            Math.random() * 0.2,
            Math.random() * 0.2
        );
        scene.add(fragment);
        fragments.push(fragment);
    }
    
    // Create explosion particles
    const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
    
    for (let i = 0; i < 100; i++) {
        const particleMaterial = new THREE.MeshBasicMaterial({ 
            color: Math.random() > 0.7 ? 0xffff00 : (Math.random() > 0.5 ? 0xff6600 : 0xff0000),
            transparent: true,
            opacity: 1
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.5;
        particle.position.x = Math.cos(angle) * radius;
        particle.position.y = 0;
        particle.position.z = Math.sin(angle) * radius;
        particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            Math.random() * 0.5 + 0.2,
            (Math.random() - 0.5) * 0.8
        );
        scene.add(particle);
        particles.push(particle);
    }
    
    // Create energy ring effect
    const ringGeometry = new THREE.TorusGeometry(2, 0.2, 8, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        wireframe: true,
        transparent: true,
        opacity: 1
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.rotation.x = Math.PI / 2;
    scene.add(ring);
    
    camera.position.z = 12;
    camera.position.y = 3;
    camera.lookAt(0, 0, 0);
    
    // Animation variables
    let animationTime = 0;
    const maxAnimationTime = 3000; // 3 seconds for death effect
    
    // Animate the death effect
    function animateDeath() {
        animationTime += 16; // Approximate 60fps
        
        if (animationTime >= maxAnimationTime) {
            // Clean up
            effectDiv.remove();
            return;
        }
        
        requestAnimationFrame(animateDeath);
        const progress = animationTime / maxAnimationTime;
        
        // Expand and fade ring
        ring.scale.setScalar(1 + progress * 3);
        ring.material.opacity = Math.max(0, 1 - progress);
        ring.rotation.z += 0.05;
        
        // Move fragments outward with gravity
        fragments.forEach(fragment => {
            fragment.position.add(fragment.velocity);
            fragment.velocity.y -= 0.01; // Gravity
            fragment.rotation.x += fragment.rotationSpeed.x;
            fragment.rotation.y += fragment.rotationSpeed.y;
            fragment.rotation.z += fragment.rotationSpeed.z;
            fragment.material.opacity = Math.max(0, 1 - progress * 0.8);
        });
        
        // Explode particles outward
        particles.forEach(particle => {
            particle.position.add(particle.velocity);
            particle.velocity.y -= 0.005; // Slight gravity
            particle.material.opacity = Math.max(0, 1 - progress);
            particle.scale.setScalar(1 - progress * 0.5);
        });
        
        // Camera shake effect
        if (progress < 0.3) {
            camera.position.x = Math.sin(animationTime * 0.05) * (1 - progress * 3) * 0.5;
            camera.position.z = 12 + Math.cos(animationTime * 0.05) * (1 - progress * 3) * 0.5;
        }
        
        renderer.render(scene, camera);
    }
    
    animateDeath();
}
    </script>
</body>
</html>